<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Spring.Threading</name>
    </assembly>
    <members>
        <member name="T:Spring.Collections.Generic.AbstractCollection`1">
            <summary>
            Serve as based class to be inherited by the classes that needs to
            implement both the <see cref="T:System.Collections.ICollection"/> and 
            the <see cref="T:System.Collections.Generic.ICollection`1"/> interfaces.
            </summary>
            <remarks>
            <para>
            By inheriting from this abstract class, subclass is only required
            to implement the <see cref="M:Spring.Collections.Generic.AbstractCollection`1.GetEnumerator"/> to complete a concrete
            read only collection class.
            </para>
            <para>
            <see cref="T:Spring.Collections.Generic.AbstractCollection`1"/> throws <see cref="T:System.NotSupportedException"/> 
            for all access to the collection mutating members. 
            </para>
            </remarks>
            <typeparam name="T">Element type of the collection</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>. This implementation
            always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            
            <param name="item">
            The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. This implementation 
            always throw this exception.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>. This implementation
            always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. This implementation always 
            throw exception.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific 
            value. This implementation searchs the element by iterating through the 
            enumerator returned by <see cref="M:Spring.Collections.Generic.AbstractCollection`1.GetEnumerator"/> method.
            </summary>
            
            <returns>
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            
            <param name="item">
            The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.ToArray">
            <summary> 
            Returns an array containing all of the elements in this collection,
            in proper sequence.
            </summary>
            <remarks> 
            <para>
            The returned array will be "safe" in that no references to it are
            maintained by this collection.  (In other words, this method must
            allocate a new array).  The caller is thus free to modify the
            returned array.
            </para>
            <para>
            This method acts as bridge between array-based and collection-based
            APIs.
            </para>
            </remarks>
            <returns>
            An array containing all of the elements in this collection.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.ToArray(`0[])">
            <summary>
            Returns an array containing all of the elements in this collection, 
            in proper sequence; the runtime type of the returned array is that 
            of the specified array.  If the collection fits in the specified
            array, it is returned therein.  Otherwise, a new array is allocated
            with the runtime type of the specified array and the size of this 
            collection.
            </summary>	 
            <remarks>
            <para>
            Like the <see cref="M:Spring.Collections.Generic.AbstractCollection`1.ToArray"/> method, this method acts as bridge
            between array-based and collection-based APIs.  Further, this
            method allows precise control over the runtime type of the output
            array, and may, under certain circumstances, be used to save
            allocation costs.
            </para>
            <para>
            Suppose <i>x</i> is a collection known to contain only strings.
            The following code can be used to dump the collection into a newly
            allocated array of <see cref="T:System.String"/>s:
            
            <code language="c#">
            	string[] y = (string[]) x.ToArray(new string[0]);
            </code>
            </para>
            <para>
            Note that <i>ToArray(new T[0])</i> is identical in function to
            <see cref="M:Spring.Collections.Generic.AbstractCollection`1.ToArray"/>.
            </para>
            </remarks>
            <param name="targetArray">
            The array into which the elements of the colleciton are to be
            stored, if it is big enough; otherwise, a new array of the same 
            runtime type is allocated for this purpose.
            </param>
            <returns>
            An array containing all of the elements in this collection.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the supplied <paramref name="targetArray"/> is
            <c>null</c>.
            </exception>
            <exception cref="T:System.ArrayTypeMismatchException">
            If type of <paramref name="targetArray"/> is a derived type of
            <typeparamref name="T"/> and the collection contains element that
            is not that derived type.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an 
            <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> 
            index.
            </summary>
            <remarks>
            This method is intentionally sealed. Subclass should override
            <see cref="M:Spring.Collections.Generic.AbstractCollection`1.DoCopyTo(`0[],System.Int32,System.Boolean)"/> instead.
            </remarks>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            arrayIndex is less than 0.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            array is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            array is multidimensional.<br/>-or-<br/>
            arrayIndex is equal to or greater than the length of array. <br/>-or-<br/>
            The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> 
            is greater than the available space from arrayIndex to the end of 
            the destination array. <br/>-or-<br/>
            Type T cannot be cast automatically to the type of the destination array.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does the actual work of copying to array. Subclass is recommended to 
            override this method instead of <see cref="M:Spring.Collections.Generic.AbstractCollection`1.CopyTo(`0[],System.Int32)"/> method, which 
            does all neccessary parameter checking and raises proper exception
            before calling this method.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <param name="ensureCapacity">
            If is <c>true</c>, calls <see cref="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)"/>
            </param>
            <returns>
            A new array of same runtime type as <paramref name="array"/> if 
            <paramref name="array"/> is too small to hold all elements and 
            <paramref name="ensureCapacity"/> is <c>false</c>. Otherwise
            the <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)">
            <summary>
            Ensures the returned array has capacity specified by <paramref name="length"/>.
            </summary>
            <remarks>
            If <typeparamref name="T"/> is <see cref="T:System.Object"/> but array is 
            actaully <c>string[]</c>, the returned array is always <c>string[]</c>.
            </remarks>
            <param name="array">
            The source array.
            </param>
            <param name="length">
            Expected length of array.
            </param>
            <returns>
            <paramref name="array"/> itself if <c>array.Length &gt;= length</c>. 
            Otherwise a new array of same type of <paramref name="array"/> of given
            <paramref name="length"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            This implementation always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; 
            otherwise, false. This method also returns false if item is not found in the 
            original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <exception cref="T:System.NotSupportedException">
            When the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. This implementation always 
            throw this exception.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <remarks>
            Subclass must implement this method.
            </remarks>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate 
            through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> 
             object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> 
             to an <see cref="T:System.Array"></see>, starting at a particular 
             <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> 
             that is the destination of the elements copied from 
             <see cref="T:System.Collections.ICollection"></see>. The 
             <see cref="T:System.Array"></see> must have zero-based indexing. </param>
            <param name="index">The zero-based index in array at which copying begins. </param>
            <exception cref="T:System.ArgumentNullException">array is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
            <exception cref="T:System.ArgumentException">
             array is multidimensional.-or- index is equal to or greater than 
             the length of array.-or- The number of elements in the source 
             <see cref="T:System.Collections.ICollection"></see> is greater 
             than the available space from index to the end of the destination 
             array. </exception>
            <exception cref="T:System.InvalidCastException">
             The type of the source <see cref="T:System.Collections.ICollection"></see> 
             cannot be cast automatically to the type of the destination array. </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <remarks>
            This implmentation list out all the elements separated by comma.
            </remarks>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.CopyTo(System.Array,System.Int32)">
             <summary>
             Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an 
             <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> 
             index.
             </summary>
            
             <param name="array">
             The one-dimensional <see cref="T:System.Array"/> that is the destination 
             of the elements copied from <see cref="T:System.Collections.ICollection"/>. The 
             <see cref="T:System.Array"/> must have zero-based indexing. 
             </param>
             <param name="index">
             The zero-based index in array at which copying begins. 
             </param>
             <exception cref="T:System.ArgumentNullException">array is null. </exception>
             <exception cref="T:System.ArgumentOutOfRangeException">
             index is less than zero. 
             </exception>
             <exception cref="T:System.ArgumentException">
             array is multidimensional.-or- index is equal to or greater than 
             the length of array.
             -or- 
             The number of elements in the source <see cref="T:System.Collections.ICollection"/> 
             is greater than the available space from index to the end of the 
             destination array. 
             </exception>
             <exception cref="T:System.InvalidCastException">
             The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast 
             automatically to the type of the destination array. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Adds all of the elements in the supplied <paramref name="collection"/>
            to this collection.
            </summary>
            <remarks>
            <para>
            Attempts to <see cref="M:Spring.Collections.Generic.AbstractCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/> of a collection to 
            itself result in <see cref="T:System.ArgumentException"/>. Further, the 
            behavior of this operation is undefined if the specified
            collection is modified while the operation is in progress.
            </para>
            <para>
            This implementation iterates over the specified collection, and 
            adds each element returned by the iterator to this collection, in turn.
            An exception encountered while trying to add an element may result 
            in only some of the elements having been successfully added when 
            the associated exception is thrown.
            </para>
            </remarks>
            <param name="collection">
            The collection containing the elements to be added to this collection.
            </param>
            <returns>
            <c>true</c> if this collection is modified, else <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the supplied <paramref name="collection"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If the collection is the current collection.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractCollection`1.DoAddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Called by <see cref="M:Spring.Collections.Generic.AbstractCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/> after the parameter is validated
            to be neither <c>null</c> nor this collection itself.
            </summary>
            <param name="collection">Collection of items to be added.</param>
            <returns>
            <c>true</c> if this collection is modified, else <c>false</c>.
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractCollection`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            This implementation counts the elements by iterating through the 
            enumerator returned by <see cref="M:Spring.Collections.Generic.AbstractCollection`1.GetEnumerator"/> method.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            
        </member>
        <member name="P:Spring.Collections.Generic.AbstractCollection`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            This implementation always return true;
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            This implementation always return true;
            </returns>
            
        </member>
        <member name="P:Spring.Collections.Generic.AbstractCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the 
             <see cref="T:System.Collections.ICollection"></see> 
             is synchronized (thread safe).
            </summary>
            
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"></see> 
             is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the 
             <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            
            <returns>
            An object that can be used to synchronize access to the 
             <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractCollection`1.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the 
            <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            <remarks>This implementation returns <see langword="null"/>.</remarks>
            <returns>
            An object that can be used to synchronize access to the 
            <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractCollection`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> 
            is synchronized (thread safe).
            </summary>
            <remarks>This implementaiton always return <see langword="false"/>.</remarks>
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"/> 
            is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Spring.Collections.Generic.AbstractEnumerator`1">
            <summary>
            Serve as base class to be inherited by the classes that needs to
            implement both the <see cref="T:System.Collections.IEnumerator"/> and 
            the <see cref="T:System.Collections.Generic.IEnumerator`1"/> interfaces.
            </summary>
            <typeparam name="T">Type of the elements to be iterated.</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Collections.Generic.AbstractEnumerator`1._state">
            <summary>
            Indicates if the enumerator has not startet, is in progress, 
            or has already finished.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> 
             that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.GoNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
            
             <returns>
             true if the enumerator was successfully advanced to the next 
             element; false if the enumerator has passed the end of the collection.
             </returns>
            
             <exception cref="T:System.InvalidOperationException">
             The collection was modified after the enumerator was created. 
             </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.FetchCurrent">
            <summary>
            Fetch the current element of the enumerator.
            </summary>
            <returns>The current element</returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, 
            or resetting unmanaged resources. This implementation does nothing.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
            
             <returns>
             true if the enumerator was successfully advanced to the next 
             element; false if the enumerator has passed the end of the collection.
             </returns>
            
             <exception cref="T:System.InvalidOperationException">
             The collection was modified after the enumerator was created. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before 
            the first element in the collection. This implementation
            always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            <remarks>
            This method is intentionally sealed. Derived class should override
            <see cref="M:Spring.Collections.Generic.AbstractEnumerator`1.DoReset"/> protected method instead.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            Always thown.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created. 
            </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractEnumerator`1.DoReset">
            <summary>
            For derived class to implement the <see cref="M:Spring.Collections.Generic.AbstractEnumerator`1.Reset"/> function. 
            This implmenetation always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractEnumerator`1.Current">
             <summary>
             Gets the element in the collection at the current position of the 
             enumerator.
             </summary>
            
             <returns>
             The element in the collection at the current position of the 
             enumerator.
             </returns>
            
        </member>
        <member name="T:Spring.Collections.Generic.AbstractEnumerator`1.EnumeratorState">
            <summary>
            Indicates if the enumerator has not startet, is in progress, 
            or has already finished.
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.AbstractEnumerator`1.EnumeratorState.BeforeStart">
            <summary>
            Enuemrator has not started.
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.AbstractEnumerator`1.EnumeratorState.InProgress">
            <summary>
            Enuemrator is in progress.
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.AbstractEnumerator`1.EnumeratorState.AfterFinish">
            <summary>
            Enuemrator has already finished.
            </summary>
        </member>
        <member name="T:Spring.Collections.Generic.AbstractList`1">
            <summary>
            Serve as based class to be inherited by the classes that needs to
            implement both the <see cref="T:System.Collections.Generic.IList`1"/> and the <see cref="T:System.Collections.IList"/>
            interfaces.
            </summary>
            <typeparam name="T">Element type of the collection</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Collections.Generic.AbstractList`1.IsValueType">
            <summary>
            <c>true</c> if <typeparamref name="T"/> is value type.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            This implementation search the list by interating through the 
            enumerator returned by the <see cref="M:Spring.Collections.Generic.AbstractCollection`1.GetEnumerator"/> 
            method.
            </summary>
            
            <returns>
            The index of item if found in the list; otherwise, -1.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            This implementation always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            
            <param name="item">
            The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <param name="index">
            The zero-based index at which item should be inserted.</param>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            This implementation always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            
            <param name="index">
            The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific 
            value. This implementation calls <see cref="M:Spring.Collections.Generic.AbstractList`1.IndexOf(`0)"/>.
            </summary>
            
            <param name="item">
            The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param>
            <returns>
            <c>true</c> if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; 
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#Add(System.Object)">
             <summary>
             Adds an item to the <see cref="T:System.Collections.IList"></see>.
             </summary>
            
             <returns>
             The position into which the new element was inserted.
             </returns>
            
             <param name="value">The <see cref="T:System.Object"></see> to add 
             to the <see cref="T:System.Collections.IList"></see>. </param>
             <exception cref="T:System.NotSupportedException">
             The <see cref="T:System.Collections.IList"></see> is read-only.
             -or- 
             The <see cref="T:System.Collections.IList"></see> has a fixed size. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IList"></see> 
             contains a specific value.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Object"></see> is found in the 
             <see cref="T:System.Collections.IList"></see>; otherwise, false.
            </returns>
            
            <param name="value">
             The <see cref="T:System.Object"></see> to locate in the 
             <see cref="T:System.Collections.IList"></see>. 
             </param>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the 
             <see cref="T:System.Collections.IList"></see>.
            </summary>
            
            <returns>
            The index of value if found in the list; otherwise, -1.
            </returns>
            
            <param name="value">
             The <see cref="T:System.Object"></see> to locate in the 
             <see cref="T:System.Collections.IList"></see>. 
             </param>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.IList"></see> 
             at the specified index.
            </summary>
            
            <param name="value">
             The <see cref="T:System.Object"></see> to insert into the 
             <see cref="T:System.Collections.IList"></see>. 
             </param>
            <param name="index">
             The zero-based index at which value should be inserted. 
             </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
             index is not a valid index in the <see cref="T:System.Collections.IList"></see>. 
             </exception>
            <exception cref="T:System.NotSupportedException">
             The <see cref="T:System.Collections.IList"></see> is read-only.
             -or- 
             The <see cref="T:System.Collections.IList"></see> has a fixed size. 
             </exception>
            <exception cref="T:System.NullReferenceException">
             value is null reference in the <see cref="T:System.Collections.IList"></see>.
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of a specific object from 
             the <see cref="T:System.Collections.IList"></see>.
            </summary>
            
            <param name="value">
             The <see cref="T:System.Object"></see> to remove from the 
             <see cref="T:System.Collections.IList"></see>. 
             </param>
            <exception cref="T:System.NotSupportedException">
             The <see cref="T:System.Collections.IList"></see> is read-only.
             -or- 
             The <see cref="T:System.Collections.IList"></see> has a fixed size. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <remarks>
            <para>
            The implementation of getter search the list by interating through the 
            enumerator returned by the <see cref="M:Spring.Collections.Generic.AbstractCollection`1.GetEnumerator"/> method.
            </para>
            <para>
            The setter throws the <see cref="T:System.NotSupportedException"/>.
            </para>
            </remarks>
            <returns>
            The element at the specified index.
            </returns>
            
            <param name="index">
            The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the 
            <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#IsFixedSize">
            <summary>
            Gets a value indicating whether the 
             <see cref="T:System.Collections.IList"></see> 
             has a fixed size.
            </summary>
            <remarks>Calls <see cref="P:Spring.Collections.Generic.AbstractList`1.IsFixedSize"/>.</remarks>
            <returns>
            true if the <see cref="T:System.Collections.IList"></see> 
             has a fixed size; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractList`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            
            <returns>
            The element at the specified index.
            </returns>
            
            <param name="index">
             The zero-based index of the element to get or set. 
             </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
             index is not a valid index in the <see cref="T:System.Collections.IList"></see>. 
             </exception>
            <exception cref="T:System.NotSupportedException">
             The property is set and the <see cref="T:System.Collections.IList"></see> 
             is read-only. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractList`1.IsFixedSize">
            <summary>
            Called by implicit implementation of <see cref="P:System.Collections.IList.IsFixedSize"/>.
            This implementation always return <c>false</c>.
            </summary>
        </member>
        <member name="T:Spring.Collections.Generic.AbstractQueue`1">
            <summary> 
            This class provides skeletal implementations for some of <see cref="T:Spring.Collections.Generic.IQueue`1"/>
            operations.
            </summary>
            <remarks>
            <para>
            The methods <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Add(`0)"/>, <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Remove"/>, and
            <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Element"/> are based on the <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Offer(`0)"/>,
            <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Poll(`0@)"/>, and <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Peek(`0@)"/> methods respectively but 
            throw exceptions instead of indicating failure via
            <see langword="false"/> returns.
            </para>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Collections.Generic.IQueue`1">
            <summary>
            A collection designed for holding elements prior to processing.
            </summary>
            <remarks>
            <para>
            Besides basic <see cref="T:System.Collections.Generic.ICollection`1"/> operations, queues provide 
            additional insertion, extraction, and inspection operations. 
            </para>
            <para>
            Each of these methods exists in two forms: one throws an exception if 
            the operation fails, the other returns a special value. The latter 
            form of the insert operation is designed specifically for use with 
            capacity-restricted <see cref="T:Spring.Collections.Generic.IQueue`1"/> implementations; in most 
            implementations, insert operations cannot fail. 
            </para>
            <para>
            Queues typically, but do not necessarily, order elements in a FIFO 
            (first-in-first-out) manner. Among the exceptions are priority queues, 
            which order elements according to a supplied comparator, or the 
            elements' natural ordering, and LIFO queues (or stacks) which order 
            the elements LIFO (last-in-first-out). Whatever the ordering used,
             the head of the queue is that element which would be removed by a call 
            to <see cref="M:Spring.Collections.Generic.IQueue`1.Remove"/> or <see cref="M:Spring.Collections.Generic.IQueue`1.Poll(`0@)"/>. In a FIFO queue, all new 
            elements are inserted at the tail of the queue. Other kinds of queues 
            may use different placement rules. Every <see cref="T:Spring.Collections.Generic.IQueue`1"/> 
            implementation must specify its ordering properties. 
            </para>
            <para>
            The <see cref="M:Spring.Collections.Generic.IQueue`1.Offer(`0)"/> method inserts an element if possible, 
            otherwise returning <c>false</c>. This differs from the 
            <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/> method, which can fail to add an 
            element only by throwing an exception. The <see cref="M:Spring.Collections.Generic.IQueue`1.Offer(`0)"/> method 
            is designed for use when failure is a normal, rather than exceptional 
            occurrence, for example, in fixed-capacity (or "bounded") queues. 
            </para>
            <para>
            The <see cref="M:Spring.Collections.Generic.IQueue`1.Remove"/> and <see cref="M:Spring.Collections.Generic.IQueue`1.Poll(`0@)"/> methods remove and 
            return the head of the queue. Exactly which element is removed from 
            the queue is a function of the queue's ordering policy, which differs 
            from implementation to implementation. The <see cref="M:Spring.Collections.Generic.IQueue`1.Remove"/> and Poll
            <see cref="M:Spring.Collections.Generic.IQueue`1.Poll(`0@)"/> methods differ only in their behavior when the queue 
            is empty: the <see cref="M:Spring.Collections.Generic.IQueue`1.Remove"/> method throws an exception, while 
            the <see cref="M:Spring.Collections.Generic.IQueue`1.Poll(`0@)"/> method returns <c>false</c>. 
            </para>
            <para>
            The <see cref="M:Spring.Collections.Generic.IQueue`1.Element"/> and <see cref="M:Spring.Collections.Generic.IQueue`1.Peek(`0@)"/> methods return, but do 
            not remove, the head of the queue. 
            </para>
            <para>
            The <see cref="T:Spring.Collections.Generic.IQueue`1"/> interface does not define the blocking queue 
            methods, which are common in concurrent programming. 
            </para>
            <para>
            <see cref="T:Spring.Collections.Generic.IQueue`1"/> implementations generally do not define 
            element-based versions of methods <see cref="M:System.Object.Equals(System.Object)"/> 
            and  <see cref="M:System.Object.GetHashCode"/>, but instead inherit the identity 
            based versions from the class object, because element-based equality is 
            not always well-defined for queues with the same elements but different 
            ordering properties. 
            </para>
            <para>
            Based on the back port of JCP JSR-166.
            </para>
            </remarks>
            <typeparam name="T">The type of the elements in the queue.</typeparam>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Element">
            <summary>
            Retrieves, but does not remove, the head of this queue. 
            </summary>
            <remarks>
            This method differs from <see cref="M:Spring.Collections.Generic.IQueue`1.Peek(`0@)"/> in that it throws an 
            exception if this queue is empty. 
            </remarks>
            <returns>The head of this queue.</returns>
            <exception cref="T:System.InvalidOperationException">
            If this queue is empty.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Offer(`0)">
            <summary>
            Inserts the specified element into this queue if it is possible to 
            do so immediately without violating capacity restrictions. 
            </summary>
            <remarks>
            When using a capacity-restricted queue, this method is generally 
            preferable to <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>, which can fail to 
            insert an element only by throwing an exception. 
            </remarks>
            <param name="element">The element to add.</param>
            <returns>
            <c>true</c> if the element was added to this queue. Otherwise 
            <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="element"/> is <c>null</c> and the queue 
            implementation doesn't allow <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> 
            prevents it from being added to this queue. 
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Peek(`0@)">
            <summary>
            Retrieves, but does not remove, the head of this queue into out
            parameter <paramref name="element"/>.
            </summary>
            <param name="element">
            The head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> is the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Poll(`0@)">
            <summary>
            Retrieves and removes the head of this queue into out parameter
            <paramref name="element"/>. 
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> if the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Remove">
            <summary>
            Retrieves and removes the head of this queue. 
            </summary>
            <returns>The head of this queue</returns>
            <exception cref="T:System.InvalidOperationException">
            If this queue is empty.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})">
            <summary> 
            Removes all available elements from this queue and invoke the given
            <paramref name="action"/> on each element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            <example> Drain to a non-generic list.
            <code language="c#">
            IList c = ...;
            int count = Drain(delegate(T e) {c.Add(e);});
            </code>
            </example>
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})">
            <summary> 
            Removes all available elements that meet the criteria defined by 
            <paramref name="criteria"/> from this queue and invoke the given
            <paramref name="action"/> on each element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            <example> Drain to a non-generic list.
            <code language="c#">
            IList c = ...;
            int count = Drain(delegate(T e) {c.Add(e);});
            </code>
            </example>
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="criteria">The criteria to filter the elements.</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)">
            <summary> 
            Removes at most the given number of available elements from this 
            queue and invoke the given <paramref name="action"/> on each 
            element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Removes at most the given number of available elements that meet 
            the criteria defined by <paramref name="criteria"/> from this 
            queue and invoke the given <paramref name="action"/> on each 
            element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <param name="criteria">The criteria to filter the elements.</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
        </member>
        <member name="P:Spring.Collections.Generic.IQueue`1.RemainingCapacity">
            <summary>
            Gets the remaining capacity of a bounded queue or
            <see cref="F:System.Int32.MaxValue"/> if the queue is un-bounded.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Offer(`0)">
            <summary>
            Inserts the specified element into this queue if it is possible to 
            do so immediately without violating capacity restrictions. 
            </summary>
            <remarks>
            When using a capacity-restricted queue, this method is generally 
            preferable to <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Add(`0)"/>, which can fail to 
            insert an element only by throwing an exception. 
            </remarks>
            <param name="element">The element to add.</param>
            <returns>
            <c>true</c> if the element was added to this queue. Otherwise 
            <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="element"/> is <c>null</c> and the queue 
            implementation doesn't allow <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> 
            prevents it from being added to this queue. 
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Element">
            <summary>
            Retrieves, but does not remove, the head of this queue. 
            </summary>
            <remarks>
            <para>
            This method differs from <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Peek(`0@)"/> in that it throws an 
            exception if this queue is empty. 
            </para>
            <para>
            this implementation returns the result of <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Peek(`0@)"/> 
            unless the queue is empty.
            </para>
            </remarks>
            <returns>The head of this queue.</returns>
            <exception cref="T:System.InvalidOperationException">
            If this queue is empty.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Peek(`0@)">
            <summary>
            Retrieves, but does not remove, the head of this queue into out
            parameter <paramref name="element"/>.
            </summary>
            <param name="element">
            The head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> is the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Remove">
            <summary>
            Retrieves and removes the head of this queue. 
            </summary>
            <returns>The head of this queue</returns>
            <exception cref="T:System.InvalidOperationException">
            If this queue is empty.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Poll(`0@)">
            <summary>
            Retrieves and removes the head of this queue into out parameter
            <paramref name="element"/>. 
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> if the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Add(`0)">
            <summary>
            Inserts the specified <paramref name="element"/> into this queue 
            if it is possible to do so immediately without violating capacity 
            restrictions. Throws an <see cref="T:System.InvalidOperationException"/> 
            if no space is currently available.
            </summary>
            <param name="element">The element to add.</param>
            <exception cref="T:System.InvalidOperationException">
            If the <paramref name="element"/> cannot be added at this time due 
            to capacity restrictions. 
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Clear">
            <summary>
            Removes all items from the queue.
            </summary>
            <remarks>
            This implementation repeatedly calls the <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Poll(`0@)"/> moethod
            until it returns <c>false</c>.
            </remarks>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Spring#Collections#IQueue#Add(System.Object)">
            <summary>
            Add differ from <see cref="M:Spring.Collections.IQueue.Offer(System.Object)"/> by throwing exception
            When queue is full.
            </summary>
            <param name="objectToAdd"></param>
            <returns>
            TODO: The should be changed to void! in java Queue inherits 
            from Collection, which has abstract method <c>boolean Add(object)</c>, 
            in .Net, there is no such limitation!
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Spring#Collections#IQueue#Remove">
            <summary>
            Remove differ from <see cref="M:Spring.Collections.IQueue.Poll"/> by throwing exception
            When queue is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0})">
            <summary> 
            Removes all available elements from this queue and invoke the given
            <paramref name="action"/> on each element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            <example> Drain to a non-generic list.
            <code language="c#">
            IList c = ...;
            int count = Drain(delegate(T e) {c.Add(e);});
            </code>
            </example>
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Predicate{`0})">
            <summary> 
            Removes all elements that pass the given <paramref name="criteria"/> 
            from this queue and invoke the given <paramref name="action"/> on 
            each element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            <example> Drain to a non-generic list.
            <code language="c#">
            IList c = ...;
            int count = Drain(delegate(T e) {c.Add(e);});
            </code>
            </example>
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="criteria">
            The criteria to select the elements. <c>null</c> selects any element.
            </param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Int32)">
            <summary> 
            Removes at most the given number of available elements from this 
            queue and invoke the given <paramref name="action"/> on each 
            element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Removes at most the given number of elements that pass the given 
            <paramref name="criteria"/>from this queue and invoke the given 
            <paramref name="action"/> on each element in order.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <param name="criteria">
            The criteria to select the elements. <c>null</c> selects any element.
            </param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractQueue`1.DoDrain(System.Action{`0},System.Predicate{`0})">
            <summary>
            Does the real work for the <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0})"/>
            and <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractQueue`1.RemainingCapacity">
            <summary>
            Returns the remaining capacity of this queue.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractQueue`1.IsEmpty">
            <summary>
            Returns <see langword="true"/> if there are no elements in the 
            <see cref="T:Spring.Collections.Generic.IQueue`1"/>, <see langword="false"/> otherwise.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractQueue`1.Capacity">
            <summary>
            Returns the current capacity of this queue.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractQueue`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            This implementation always return true;
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            This implementation always return false as typically a queue should not
            be read only.
            </returns>
            
        </member>
        <member name="T:Spring.Collections.Generic.AbstractTransformingList`2">
            <summary>
            Provide basic functions to construct a new strongly typed list
            of type <typeparamref name="TTo"/> from another strongly typed list
            of type <typeparamref name="TFrom"/> without copying the elements.
            </summary>
            <remarks>
            <para>
            The constructed new list is a shallow copy of the source list.
            Changes to any one of the list will be seen by another.
            </para>
            </remarks>
            <typeparam name="TFrom">the element type of the constructed list</typeparam>
            <typeparam name="TTo">the element type of the source list</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Constructor that takes the <paramref name="source"/> list.
            </summary>
            <param name="source">the original source list</param>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Insert(System.Int32,`1)">
            <summary>
            Inserts an item to the <see cref="T:Spring.Collections.Generic.AbstractTransformingList`2"/> 
            at the specified index.
            </summary>
            <remarks>
            Reverse converts the <paramref name="item"/> to type 
            <typeparamref name="TFrom"/> and insert the result data into the 
            underlaying source list.
            </remarks>
            <param name="item">
            The object to insert into the list.</param>
            <param name="index">
            The zero-based index at which item should be inserted.</param>
            <exception cref="T:System.NotSupportedException">
            When the underlaying source list is read-only or the 
            <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)"/> method throws this exception.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the underlaying source list"/&gt;.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.RemoveAt(System.Int32)">
            <summary>
            Removes the list item at the specified index.
            </summary>
            <remarks>
            Removes the underlaying source list item at the specified
            index.
            </remarks>
            <param name="index">
            The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">
            When the underlaying source list is read-only.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the underlaying source list"/&gt;.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Add(`1)">
            <summary>
            Adds an item to this list.
            </summary>
            <remarks>
            Converts the <paramref name="item"/> to <typeparamref name="TFrom"/>
            using the <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)"/> method. Then add converted
            item into the source list.
            </remarks>
            <param name="item">
            The object to add to the list.
            </param>
            <exception cref="T:System.NotSupportedException">
            The underlaying source list is read-only or the <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)"/> 
            method throws this exception.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Clear">
            <summary>
            Removes all items from this list.
            </summary>
            <remarks>
            Remove all item from the underlaying source list.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            When the underlaying source list is read-only.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Contains(`1)">
            <summary>
            Determines whether this list contains a specific <paramref name="item"/>.
            </summary>
            <remarks>
            <para>
            This implementation <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.TryReverse(`1,`0@)">try to reverse</see>
            the item to source element type using <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)"/> and call the
            <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> method on the underlaying source list;
            Otherwise, calls the <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> method of
            base class.
            </para>
            </remarks>
            <returns>
            true if item is found in this list; otherwise, false.
            </returns>
            <param name="item">
            The object to locate in this list.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Remove(`1)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; 
            otherwise, false. This method also returns false if item is not found in the 
            original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <exception cref="T:System.NotSupportedException">
            When the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the list.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate 
            through the list.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)">
            <summary>
            Converts the object of type <typeparamref name="TTo"/> to
            object of type <typeparamref name="TFrom"/>.
            </summary>
            <remarks>
            This implementaiton calls <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.TryReverse(`1,`0@)"/> and throws 
            <see cref="T:System.NotSupportedException"/> if <c>TryReverse</c> returns
            <c>false</c>.
            Subclass that supports reverse convertion should override this
            method of <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.TryReverse(`1,`0@)"/> to provide correct 
            implementation.
            </remarks>
            <param name="target">item passed to this list</param>
            <returns>
            Converted item that can be passed to the underlaying source list.
            </returns>
            <exception cref="T:System.NotSupportedException">
            When <c>TryReverse(target, out source)</c> returns false.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.TryReverse(`1,`0@)">
            <summary>
            Try converts object of type <typeparamref name="TTo"/> to
            <typeparamref name="TFrom"/>.
            </summary>
            <remarks>
            This implementation always return <c>false</c>. Subclasses that
            support reversing should override this method.
            </remarks>
            <param name="target">
            Instance of <typeparamref name="TTo"/> to be converted.
            </param>
            <param name="source">
            Converted object of type <typeparamref name="TFrom"/>.
            </param>
            <returns>
            <c>true</c> when reserving is supported, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.AbstractTransformingList`2.Transform(`0)">
            <summary>
            Converts the object of type <typeparamref name="TFrom"/> to
            object of type <typeparamref name="TTo"/>.
            </summary>
            <param name="source">item that is from the underlaying source list</param>
            <returns>converted item that can be returned by this list</returns>
        </member>
        <member name="F:Spring.Collections.Generic.AbstractTransformingList`2.SourceList">
            <summary>
            The underlaying source list.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractTransformingList`2.Count">
            <summary>
            Gets the number of elements contained in this list.
            </summary>
            <remarks>
            This implementation returns the count of the source list.
            </remarks>
            <returns>
            The number of elements contained in this list.
            </returns>
            
        </member>
        <member name="P:Spring.Collections.Generic.AbstractTransformingList`2.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <remarks>
            <para>
            Getter retrieves the element from the underlaying source list
            and then converts to the <typeparamref name="TTo"/> type using
            the <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Transform(`0)"/> method.
            </para>
            <para>
            Setter reverse converts the <paramref name="value"/> using the
            <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)"/> mehtod and then set the converted data to 
            the underlaying source list.
            </para>
            </remarks>
            <returns>
            The element at the specified index.
            </returns>
            
            <param name="index">
            The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the underlaying source list/&gt;.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The property is set and the underlaying source list is read-only 
            or the <see cref="M:Spring.Collections.Generic.AbstractTransformingList`2.Reverse(`1)"/> method throws this exception.
            </exception>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractTransformingList`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
            
        </member>
        <member name="P:Spring.Collections.Generic.AbstractTransformingList`2.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
            <remarks>This implementaiton always return <see langword="false"/>.</remarks>
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Collections.Generic.AbstractTransformingList`2.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            <remarks>This implementation returns <see langword="null"/>.</remarks>
            <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Spring.Collections.Generic.ArrayQueue`1">
            <summary> 
            A bounded <see cref="T:Spring.Collections.Generic.IQueue`1"/> backed by an array.  This queue orders 
            elements FIFO (first-in-first-out).  The <i>head</i> of the queue is 
            that element that has been on the queue the longest time.  The <i>tail</i> 
            of the queue is that element that has been on the queue the shortest time. 
            New elements are inserted at the tail of the queue, and the queue retrieval
            operations obtain elements at the head of the queue.
            </summary>
            <remarks>
            <para>
            This is a classic "bounded buffer", in which a fixed-sized array 
            holds elements inserted by producers and extracted by consumers.  Once 
            created, the capacity cannot be increased.
            </para>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1._capacity">
            <summary>The intial capacity of this queue.</summary>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1._count">
            <summary>Number of items in the queue </summary>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1._items">
            <summary>The queued items  </summary>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1._takeIndex">
            <summary>items index for next take, poll or remove </summary>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1._putIndex">
            <summary>items index for next put, offer, or add. </summary>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.RemoveAt(System.Int32)">
            <summary> 
            Utility for remove: Delete item at position <paramref name="index"/>.
            and return the next item position. Call only when holding lock.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Increment(System.Int32)">
            <summary> Circularly increment i.</summary>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Insert(`0)">
            <summary> 
            Inserts element at current put position, advances, and signals.
            Call only when holding lock.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Extract">
            <summary> 
            Extracts element at current take position, advances, and signals.
            Call only when holding lock.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Creates an <see cref="T:Spring.Collections.Generic.ArrayQueue`1"/> with the given (fixed)
            <paramref name="capacity"/> and initially containing the elements 
            of the given collection, added in traversal order of the 
            collection's iterator.
            </summary>
            <param name="capacity">
            The capacity of this queue.
            </param>
            <param name="collection">
            The collection of elements to initially contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is less than 1 or is less than the 
            size of <pararef name="collection"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="collection"/> is <see langword="null"/>.
            </exception> 
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.#ctor(System.Int32)">
            <summary> 
            Creates an <see cref="T:Spring.Collections.Generic.ArrayQueue`1"/> with the given (fixed)
            <paramref name="capacity"/> and default fairness access policy.
            </summary>
            <param name="capacity">
            The capacity of this queue.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Clear">
            <summary>
            Clear the queue without locking, this is for subclass to provide
            the clear implementation without worrying about concurrency.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Contains(`0)">
            <summary> 
            Returns <see langword="true"/> if this queue contains the specified element.
            </summary>
            <remarks>
            More formally, returns <see langword="true"/> if and only if this queue contains
            at least one element <i>element</i> such that <i>elementToSearchFor.equals(element)</i>.
            </remarks>
            <param name="elementToSearchFor">object to be checked for containment in this queue</param>
            <returns> <see langword="true"/> if this queue contains the specified element</returns>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Remove(`0)">
            <summary> 
            Removes a single instance of the specified element from this queue,
            if it is present.  More formally, removes an <i>element</i> such
            that <i>elementToRemove.Equals(element)</i>, if this queue contains one or more such
            elements.
            </summary>
            <param name="elementToRemove">element to be removed from this queue, if present
            </param>
            <returns> <see langword="true"/> if this queue contained the specified element or
             if this queue changed as a result of the call, <see langword="false"/> otherwise
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Offer(`0)">
            <summary> 
            Inserts the specified element into this queue if it is possible to do
            so immediately without violating capacity restrictions.
            </summary>
            <remarks>
            <p/>
            When using a capacity-restricted queue, this method is generally
            preferable to <see cref="T:System.ArgumentException"/>,
            which can fail to insert an element only by throwing an exception.
            </remarks>
            <param name="element">
            The element to add.
            </param>
            <returns>
            <see langword="true"/> if the element was added to this queue.
            </returns>
            <exception cref="T:System.Object">
            If the element cannot be added at this time due to capacity restrictions.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the supplied <paramref name="element"/> is <see langword="null"/> 
            and this queue does not permit <see langword="null"/> elements.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Remove">
            <summary> 
            Retrieves and removes the head of this queue.
            </summary>
            <remarks>
            <p/>
            This method differs from <see cref="M:Spring.Collections.Generic.IQueue`1.Poll(`0@)"/>
            only in that it throws an exception if this queue is empty.
            </remarks>
            <returns> 
            The head of this queue
            </returns>
            <exception cref="T:System.InvalidOperationException">if this queue is empty</exception>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Poll(`0@)">
            <summary> 
            Retrieves and removes the head of this queue,
            or returns <see langword="null"/> if this queue is empty.
            </summary>
            <returns> 
            The head of this queue, or <see langword="null"/> if this queue is empty.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.Peek(`0@)">
            <summary> 
            Retrieves, but does not remove, the head of this queue,
            or returns <see langword="null"/> if this queue is empty.
            </summary>
            <returns> 
            The head of this queue, or <see langword="null"/> if this queue is empty.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.ToArray">
            <summary> 
            Returns an array of <typeparamref name="T"/> containing all of the 
            elements in this queue, in proper sequence.
            </summary>
            <remarks>
            The returned array will be "safe" in that no references to it are
            maintained by this queue.  (In other words, this method must allocate
            a new array).  The caller is thus free to modify the returned array.
            </remarks>
            <returns> an <c>T[]</c> containing all of the elements in this queue</returns>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.ToArray(`0[])">
            <summary> 
            Returns an array containing all of the elements in this queue, in
            proper sequence; the runtime type of the returned array is that of
            the specified array.  
            </summary>
            <remarks>
            If the queue fits in the specified array, it
            is returned therein.  Otherwise, a new array is allocated with the
            runtime type of the specified array and the size of this queue.
            
            <p/>
            If this queue fits in the specified array with room to spare
            (i.e., the array has more elements than this queue), the element in
            the array immediately following the end of the queue is set to
            <see langword="null"/>.
            
            <p/>
            Like the <see cref="M:Spring.Collections.Generic.ArrayQueue`1.ToArray"/> method, 
            this method acts as bridge between
            array-based and collection-based APIs.  Further, this method allows
            precise control over the runtime type of the output array, and may,
            under certain circumstances, be used to save allocation costs.
            
            <p/>
            Suppose <i>x</i> is a queue known to contain only strings.
            The following code can be used to dump the queue into a newly
            allocated array of <see cref="T:System.String"/> objects:
            
            <code>
            	string[] y = x.ToArray(new string[0]);
            </code>
            
            Note that <see cref="M:Spring.Collections.Generic.ArrayQueue`1.ToArray(`0[])"/> with an empty
            arry is identical in function to
            <see cref="M:Spring.Collections.Generic.ArrayQueue`1.ToArray"/>.
            </remarks>
            <param name="targetArray">
            the array into which the elements of the queue are to
            be stored, if it is big enough; otherwise, a new array of the
            same runtime type is allocated for this purpose
            </param>
            <returns> an array containing all of the elements in this queue</returns>
            <exception cref="T:System.ArrayTypeMismatchException">if the runtime type of the <pararef name="targetArray"/> 
            is not a super tyoe of the runtime tye of every element in this queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">If the <paramref name="targetArray"/> is <see langword="null"/>
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.ArrayQueue`1.GetEnumerator">
            <summary> 
            Returns an <see cref="T:System.Collections.Generic.IEnumerator`1"/> over the elements in this 
            queue in proper sequence.
            </summary>
            <remarks>
            The returned <see cref="T:System.Collections.Generic.IEnumerator`1"/> is a "weakly consistent" 
            enumerator that will not throw <see cref="T:System.InvalidOperationException"/> 
            when the queue is concurrently modified, and guarantees to traverse
            elements as they existed upon construction of the enumerator, and
            may (but is not guaranteed to) reflect any modifications subsequent
            to construction.
            </remarks>
            <returns>
            An enumerator over the elements in this queue in proper sequence.
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.ArrayQueue`1.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.ArrayQueue`1.RemainingCapacity">
            <summary>
            Gets the capacity of the queue.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.ArrayQueue`1.Count">
            <summary> 
            Returns the number of elements in this queue.
            </summary>
            <returns> the number of elements in this queue</returns>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1.ArrayQueueEnumerator._nextIndex">
            <summary> 
            Index of element to be returned by next,
            or a negative number if no such element.
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1.ArrayQueueEnumerator._queue">
            <summary>
            Parent <see cref="T:Spring.Collections.Generic.ArrayQueue`1"/> 
            for this <see cref="T:System.Collections.Generic.IEnumerator`1"/>
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.ArrayQueue`1.ArrayQueueEnumerator._nextItem">
            <summary> 
            nextItem holds on to item fields because once we claim
            that an element exists in hasNext(), we must return it in
            the following next() call even if it was in the process of
            being removed when hasNext() was called.
            </summary>
        </member>
        <member name="T:Spring.Collections.Generic.DictionarySet`1">
            <summary>
            <see cref="T:Spring.Collections.Generic.DictionarySet`1"/> is an
            <see langword="abstract"/> class that supports the creation of new
            <see cref="T:Spring.Collections.Generic.ISet`1"/> types where the underlying data
            store is an <see cref="T:System.Collections.Generic.IDictionary`2"/> instance.
            </summary>
            <remarks>
            <p>
            You can use any object that implements the
            <see cref="T:System.Collections.Generic.IDictionary`2"/> interface to hold set
            data. You can define your own, or you can use one of the objects
            provided in the framework. The type of
            <see cref="T:System.Collections.Generic.IDictionary`2"/> you
            choose will affect both the performance and the behavior of the
            <see cref="T:Spring.Collections.Generic.ISet`1"/> using it.
            </p>
            <p>
            This object overrides the <see cref="M:System.Object.Equals(System.Object)"/> method,
            but not the <see cref="M:System.Object.GetHashCode"/> method, because
            the <see cref="T:Spring.Collections.DictionarySet"/> class is mutable.
            Therefore, it is not safe to use as a key value in a dictionary.
            </p>
            <p>
            To make a <see cref="T:Spring.Collections.Generic.ISet`1"/> typed based on your
            own <see cref="T:System.Collections.Generic.IDictionary`2"/>, simply derive a new
            class with a constructor that takes no parameters. Some
            <see cref="T:Spring.Collections.ISet"/> implmentations cannot be defined
            with a default constructor. If this is the case for your class, you
            will need to override <b>clone</b> as well.
            </p>
            <p>
            It is also standard practice that at least one of your constructors
            takes an <see cref="T:System.Collections.ICollection"/> or an
            <see cref="T:Spring.Collections.Generic.ISet`1"/> as an argument.
            </p>
            </remarks>
            <seealso cref="T:Spring.Collections.Generic.ISet`1"/>
        </member>
        <member name="T:Spring.Collections.Generic.Set`1">
            <summary>
            A collection that contains no duplicate elements.
            </summary>
            <seealso cref="T:Spring.Collections.ISet"/>
        </member>
        <member name="T:Spring.Collections.Generic.ISet`1">
            <summary>
            A collection that contains no duplicate elements.
            </summary>
            <remarks>
            <p>
            This interface models the mathematical
            <see cref="T:Spring.Collections.ISet"/> abstraction. The order of
            elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various
            <see cref="T:Spring.Collections.ISet"/> methods, and thus is not
            guaranteed.
            </p>
            <p>
            <see cref="T:Spring.Collections.ISet"/> overrides the
            <see cref="M:System.Object.Equals(System.Object)"/> method to test for "equivalency":
            whether the two sets contain the same elements. The "==" and "!="
            operators are not overridden by design, since it is often desirable to
            compare object references for equality.
            </p>
            <p>
            Also, the <see cref="M:System.Object.GetHashCode"/> method is not
            implemented on any of the set implementations, since none of them are
            truly immutable. This is by design, and it is the way almost all
            collections in the .NET framework function. So as a general rule, don't
            store collection objects inside <see cref="T:Spring.Collections.ISet"/>
            instances. You would typically want to use a keyed
            <see cref="T:System.Collections.IDictionary"/> instead.
            </p>
            <p>
            None of the <see cref="T:Spring.Collections.ISet"/> implementations in
            this library are guaranteed to be thread-safe in any way unless wrapped
            in a <see cref="T:Spring.Collections.SynchronizedSet"/>.
            </p>
            <p>
            The following table summarizes the binary operators that are supported
            by the <see cref="T:Spring.Collections.ISet"/> class.
            </p>
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>
            		Element included in result if it exists in either <c>A</c> OR
            		<c>B</c>.
            		</term>
            		<term><c>Union()</c></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>
            		Element included in result if it exists in both <c>A</c> AND
            		<c>B</c>.
            		</term>
            		<term><c>InterSect()</c></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>
            		Element included in result if it exists in one, but not both,
            		of <c>A</c> and <c>B</c>.
            		</term>
            		<term><c>ExclusiveOr()</c></term>
            	</item>
            	<item>
            		<term>Minus (n/a)</term>
            		<term>
            		Take all the elements in <c>A</c>. Now, if any of them exist in
            		 <c>B</c>, remove them. Note that unlike the other operators,
            		 <c>A - B</c> is not the same as <c>B - A</c>.
            		 </term>
            		<term><c>Minus()</c></term>
            	</item>
            </list>
            </remarks>
            <author>Griffin Caprio</author>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Union(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present. 
            </summary>
            <remarks>
            <p>
            That is, the element is included if it is in either
            <paramref name="setOne"/> or this set. Neither this set nor the input
            set are modified during the operation. The return value is a
            <b>clone</b> of this set with the extra elements added in.
            </p>
            </remarks>
            <param name="setOne">A collection of elements.</param>
            <returns>
            A new <see cref="T:Spring.Collections.ISet"/> containing the union of
            this <see cref="T:Spring.Collections.ISet"/> with the specified
            collection. Neither of the input objects is modified by the union.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Intersect(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.
            </summary>
            <remarks>
            <p>
            That is, the element is included if it exists in both sets. The
            <c>Intersect()</c> operation does not modify the input sets. It
            returns a <b>clone</b> of this set with the appropriate elements
            removed.
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <returns>
            The intersection of this set with <paramref name="setOne"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Minus(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of this set from the <paramref name="setOne"/>
            set.
            </summary>
            <remarks>
            <p>
            This returns a set of all the elements in set
            <paramref name="setOne"/>, removing the elements that are also in
            this set. The original sets are not modified during this operation.
            The result set is a <b>clone</b> of this
            <see cref="T:Spring.Collections.ISet"/> containing the elements from
            the operation.
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <returns>
            A set containing the elements from this set with the elements in
            <paramref name="setOne"/> removed.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.ExclusiveOr(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only those
            elements that are in one of the sets, but not in both.
            </summary>
            <remarks>
            <p>
            The original sets are not modified during this operation. The
            result set is a <b>clone</b> of this set containing the elements
            from the exclusive-or operation.
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <returns>
            A set containing the result of
            <c><paramref name="setOne"/> ^ this</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Contains(`0)">
            <summary>
            Returns <see langword="true"/> if this set contains the specified
            element.
            </summary>
            <param name="element">The element to look for.</param>
            <returns>
            <see langword="true"/> if this set contains the specified element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <see langword="true"/> if the set contains all the
            elements in the specified collection.
            </summary>
            <param name="collection">A collection of objects.</param>
            <returns>
            <see langword="true"/> if the set contains all the elements in the
            specified collection.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="element">The object to add to the set.</param>
            <returns>
            <see langword="true"/> is the object was added,
            <see langword="true"/> if the object was already present.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if
            they are not already present.
            </summary>
            <param name="collection">A collection of objects to add to the set.</param>
            <returns>
            <see langword="true"/> is the set changed as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="element">The element to be removed.</param>
            <returns>
            <see langword="true"/> if the set contained the specified element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in
            this set.
            </summary>
            <param name="collection">A collection of elements to remove.</param>
            <returns>
            <see langword="true"/> if the set was modified as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the
            specified collection.
            </summary>
            <param name="collection">
            The collection that defines the set of elements to be retained.
            </param>
            <returns>
            <see langword="true"/> if this set changed as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISet`1.Clear">
            <summary>
            Removes all objects from this set.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.ISet`1.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this set contains no elements.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Union(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present. 
            </summary>
            <param name="setOne">A collection of elements.</param>
            <returns>
            A new <see cref="T:Spring.Collections.ISet"/> containing the union of
            this <see cref="T:Spring.Collections.ISet"/> with the specified
            collection. Neither of the input objects is modified by the union.
            </returns>
            <see cref="M:Spring.Collections.ISet.Union(Spring.Collections.ISet)"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Union(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of two sets, where all the elements in both are
            present.
            </summary>
            <remarks>
            <p>
            That is, the element is included if it is in either
            <paramref name="setOne"/> or <paramref name="anotherSet"/>. The return
            value is a <b>clone</b> of one of the sets (<paramref name="setOne"/>
            if it is not <see langword="null"/>) with elements of the other set
            added in. Neither of the input sets is modified by the operation.
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            A set containing the union of the input sets;
            <see langword="null"/> if both sets are <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.op_BitwiseOr(Spring.Collections.Generic.Set{`0},Spring.Collections.Generic.Set{`0})">
            <summary>
            Performs a "union" of two sets, where all the elements in both are
            present.
            </summary>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            A set containing the union of the input sets;
            <see langword="null"/> if both sets are <see langword="null"/>.
            </returns>
            <seealso cref="M:Spring.Collections.Generic.Set`1.Union(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Intersect(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.
            </summary>
            <param name="setOne">A set of elements.</param>
            <returns>
            The intersection of this set with <paramref name="setOne"/>.
            </returns>
            <see cref="M:Spring.Collections.ISet.Intersect(Spring.Collections.ISet)"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Intersect(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain. 
            </summary>
            <remarks>
            <p>
            That is, the element is included only if it exists in both
            <paramref name="setOne"/> and <paramref name="anotherSet"/>. Neither input
            object is modified by the operation. The result object is a
            <b>clone</b> of one of the input objects (<paramref name="setOne"/>
            if it is not <see langword="null"/>) containing the elements from
            the intersect operation.
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            The intersection of the two input sets; <see langword="null"/> if
            both sets are <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.op_BitwiseAnd(Spring.Collections.Generic.Set{`0},Spring.Collections.Generic.Set{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain. 
            </summary>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            The intersection of the two input sets; <see langword="null"/> if
            both sets are <see langword="null"/>.
            </returns>
            <seealso cref="M:Spring.Collections.Generic.Set`1.Intersect(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Minus(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of this set from the <paramref name="setOne"/>
            set.
            </summary>
            <param name="setOne">A set of elements.</param>
            <returns>
            A set containing the elements from this set with the elements in
            <paramref name="setOne"/> removed.
            </returns>
            <seealso cref="M:Spring.Collections.ISet.Minus(Spring.Collections.ISet)"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Minus(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <paramref name="anotherSet"/> from set
            <paramref name="setOne"/>.
            </summary>
            <remarks>
            <p>
            This returns a set of all the elements in set
            <paramref name="setOne"/>, removing the elements that are also in
            set <paramref name="anotherSet"/>. The original sets are not modified
            during this operation. The result set is a <b>clone</b> of set
            <paramref name="setOne"/> containing the elements from the operation. 
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            A set containing
            <c><paramref name="setOne"/> - <paramref name="anotherSet"/></c> elements.
            <see langword="null"/> if <paramref name="setOne"/> is
            <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.op_Subtraction(Spring.Collections.Generic.Set{`0},Spring.Collections.Generic.Set{`0})">
            <summary>
            Performs a "minus" of set <paramref name="anotherSet"/> from set
            <paramref name="setOne"/>.
            </summary>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            A set containing
            <c><paramref name="setOne"/> - <paramref name="anotherSet"/></c> elements.
            <see langword="null"/> if <paramref name="setOne"/> is
            <see langword="null"/>.
            </returns>
            <seealso cref="M:Spring.Collections.Generic.Set`1.Minus(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.ExclusiveOr(Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only those
            elements that are in one of the sets, but not in both.
            </summary>
            <param name="setOne">A set of elements.</param>
            <returns>
            A set containing the result of
            <c><paramref name="setOne"/> ^ this</c>.
            </returns>
            <seealso cref="M:Spring.Collections.ISet.ExclusiveOr(Spring.Collections.ISet)"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.ExclusiveOr(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only those
            elements that are in one of the sets, but not in both.
            </summary>
            <remarks>
            <p>
            The original sets are not modified during this operation. The
            result set is a <b>clone</b> of one of the sets (
            <paramref name="setOne"/> if it is not <see langword="null"/>)
            containing the elements from the exclusive-or operation.
            </p>
            </remarks>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            A set containing the result of
            <c><paramref name="setOne"/> ^ <paramref name="anotherSet"/></c>.
            <see langword="null"/> if both sets are <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.op_ExclusiveOr(Spring.Collections.Generic.Set{`0},Spring.Collections.Generic.Set{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only those
            elements that are in one of the sets, but not in both.
            </summary>
            <param name="setOne">A set of elements.</param>
            <param name="anotherSet">A set of elements.</param>
            <returns>
            A set containing the result of
            <c><paramref name="setOne"/> ^ <paramref name="anotherSet"/></c>.
            <see langword="null"/> if both sets are <see langword="null"/>.
            </returns>
            <seealso cref="M:Spring.Collections.Generic.Set`1.ExclusiveOr(Spring.Collections.Generic.ISet{`0},Spring.Collections.Generic.ISet{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="element">The object to add to the set.</param>
            <returns>
            <see langword="true"/> is the object was added,
            <see langword="true"/> if the object was already present.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if
            they are not already present.
            </summary>
            <param name="collection">A collection of objects to add to the set.</param>
            <returns>
            <see langword="true"/> is the set changed as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Clear">
            <summary>
            Removes all objects from this set.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Contains(`0)">
            <summary>
            Returns <see langword="true"/> if this set contains the specified
            element.
            </summary>
            <param name="element">The element to look for.</param>
            <returns>
            <see langword="true"/> if this set contains the specified element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <see langword="true"/> if the set contains all the
            elements in the specified collection.
            </summary>
            <param name="collection">A collection of objects.</param>
            <returns>
            <see langword="true"/> if the set contains all the elements in the
            specified collection.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="element">The element to be removed.</param>
            <returns>
            <see langword="true"/> if the set contained the specified element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in
            this set.
            </summary>
            <param name="collection">A collection of elements to remove.</param>
            <returns>
            <see langword="true"/> if the set was modified as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the
            specified collection.
            </summary>
            <param name="collection">
            The collection that defines the set of elements to be retained.
            </param>
            <returns>
            <see langword="true"/> if this set changed as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Clone">
            <summary>
            Returns a clone of the <see cref="T:Spring.Collections.ISet"/>
            instance.
            </summary>
            <remarks>
            <p>
            This will work for derived <see cref="T:Spring.Collections.ISet"/>
            classes if the derived class implements a constructor that takes no
            arguments.
            </p>
            </remarks>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <see cref="T:Spring.Collections.ISet"/> to
            an array.
            </summary>
            <remarks>
            <p>
            The type of array needs to be compatible with the objects in the
            <see cref="T:Spring.Collections.ISet"/>, obviously.
            </p>
            </remarks>
            <param name="array">
            An array that will be the target of the copy operation.
            </param>
            <param name="index">
            The zero-based index where copying will start.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the
            <see cref="T:Spring.Collections.ISet"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> over the elements
            in the <see cref="T:Spring.Collections.ISet"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Equals(System.Object)">
            <summary>
            This method will test the <see cref="T:Spring.Collections.ISet"/>
            against another <see cref="T:Spring.Collections.ISet"/> for
            "equality".
            </summary>
            <remarks>
            <p>
            In this case, "equality" means that the two sets contain the same
            elements. The "==" and "!=" operators are not overridden by design.
            If you wish to check for "equivalent"
            <see cref="T:Spring.Collections.ISet"/> instances, use
            <c>Equals()</c>. If you wish to check to see if two references are
            actually the same object, use "==" and "!=".  
            </p>
            </remarks>
            <param name="obj">
            A <see cref="T:Spring.Collections.ISet"/> object to compare to.
            </param>
            <returns>
            <see langword="true"/> if the two sets contain the same elements.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.Equals(Spring.Collections.Generic.Set{`0})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Spring.Collections.Generic.Set`1.GetHashCode">
            <summary>
            Gets the hashcode for the object.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.Set`1.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.Set`1.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.Set`1.IsSynchronized">
            <summary>
            Returns <see langword="true"/> if the
            <see cref="T:Spring.Collections.ISet"/> is synchronized across
            threads.
            </summary>
            <remarks>
            <p>
            Note that enumeration is inherently not thread-safe. Use the
            <see cref="P:Spring.Collections.Generic.Set`1.SyncRoot"/> to lock the object during enumeration.
            </p>
            </remarks>
        </member>
        <member name="P:Spring.Collections.Generic.Set`1.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make
            it thread-safe.
            </summary>
            <remarks>
            <p>
            When implementing this, if your object uses a base object, like an
            <see cref="T:System.Collections.IDictionary"/>, or anything that has
            a <c>SyncRoot</c>, return that object instead of "<c>this</c>".
            </p>
            </remarks>
            <value>
            An object that can be used to synchronize this collection to make
            it thread-safe.
            </value>
        </member>
        <member name="P:Spring.Collections.Generic.Set`1.IsReadOnly">
            <summary>
            set is not readonly by default. derived classes may override this property
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="element">The object to add to the set.</param>
            <returns>
            <see langword="true"/> is the object was added,
            <see langword="false"/> if the object was already present.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if
            they are not already present.
            </summary>
            <param name="collection">A collection of objects to add to the set.</param>
            <returns>
            <see langword="true"/> is the set changed as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.Clear">
            <summary>
            Removes all objects from this set.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.Contains(`0)">
            <summary>
            Returns <see langword="true"/> if this set contains the specified
            element.
            </summary>
            <param name="element">The element to look for.</param>
            <returns>
            <see langword="true"/> if this set contains the specified element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <see langword="true"/> if the set contains all the
            elements in the specified collection.
            </summary>
            <param name="collection">A collection of objects.</param>
            <returns>
            <see langword="true"/> if the set contains all the elements in the
            specified collection; also <see langword="false"/> if the
            supplied <paramref name="collection"/> is <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="element">The element to be removed.</param>
            <returns>
            <see langword="true"/> if the set contained the specified element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in
            this set.
            </summary>
            <param name="collection">A collection of elements to remove.</param>
            <returns>
            <see langword="true"/> if the set was modified as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the
            specified collection.
            </summary>
            <param name="collection">
            The collection that defines the set of elements to be retained.
            </param>
            <returns>
            <see langword="true"/> if this set changed as a result of this
            operation.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <see cref="T:Spring.Collections.ISet"/> to
            an array.
            </summary>
            <remarks>
            <p>
            The type of array needs to be compatible with the objects in the
            <see cref="T:Spring.Collections.ISet"/>, obviously.
            </p>
            </remarks>
            <param name="array">
            An array that will be the target of the copy operation.
            </param>
            <param name="index">
            The zero-based index where copying will start.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.DictionarySet`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the
            <see cref="T:Spring.Collections.ISet"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> over the elements
            in the <see cref="T:Spring.Collections.ISet"/>.
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.DictionarySet`1.InternalDictionary">
            <summary>
            Provides the storage for elements in the
            <see cref="T:Spring.Collections.ISet"/>, stored as the key-set
            of the <see cref="T:System.Collections.IDictionary"/> object.  
            </summary>
            <remarks>
            <p>
            Set this object in the constructor if you create your own
            <see cref="T:Spring.Collections.ISet"/> class.
            </p>
            </remarks>
        </member>
        <member name="P:Spring.Collections.Generic.DictionarySet`1.Placeholder">
            <summary>
            The placeholder object used as the value for the
            <see cref="T:System.Collections.IDictionary"/> instance.
            </summary>
            <remarks>
            There is a single instance of this object globally, used for all
            <see cref="T:Spring.Collections.ISet"/>s.
            </remarks>
        </member>
        <member name="P:Spring.Collections.Generic.DictionarySet`1.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.DictionarySet`1.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.DictionarySet`1.IsSynchronized">
            <summary>
            Returns <see langword="true"/> if the
            <see cref="T:Spring.Collections.ISet"/> is synchronized across
            threads.
            </summary>
            <seealso cref="P:Spring.Collections.Set.IsSynchronized"/>
        </member>
        <member name="P:Spring.Collections.Generic.DictionarySet`1.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make
            it thread-safe.
            </summary>
            <value>
            An object that can be used to synchronize this collection to make
            it thread-safe.
            </value>
            <seealso cref="P:Spring.Collections.Set.SyncRoot"/>
        </member>
        <member name="T:Spring.Collections.Generic.DownCastList`2">
            <summary>
            Transforms a <see cref="T:System.Collections.Generic.IList`1">IList(Of TBase)</see>
            to a <see cref="T:System.Collections.Generic.IList`1">IList(Of TSub)</see> by
            simply casting the elements when <typeparamref name="TSub"/> is a
            derived type of <typeparamref name="TBase"/>.
            </summary>
            <typeparam name="TSub">The sub type.</typeparam>
            <typeparam name="TBase">The base type.</typeparam>
        </member>
        <member name="M:Spring.Collections.Generic.DownCastList`2.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Construct a collection of <typeparamref name="TBase"/> by 
            transforming the elemnts from <paramref name="source"/>.
            </summary>
            <remarks>
            The resulting collection is mutable by down casting 
            <typeparamref name="TBase"/> to <typeparamref name="TSub"/>
            when necessary.
            </remarks>
            <param name="source">
            The source collection of <typeparamref name="TSub"/>.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.DownCastList`2.Contains(`1)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IList`1"/> contains a specific 
            value. 
            </summary>
            <returns>
            true if item is found in the <see cref="T:System.Collections.Generic.IList`1"/>; otherwise, false.
            </returns>
            
            <param name="item">
            The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.DownCastList`2.Remove(`1)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.IList`1"/>; 
            otherwise, false. This method also returns false if item is not found in the 
            original <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <exception cref="T:System.NotSupportedException">
            When the <see cref="T:System.Collections.Generic.IList`1"/> is read-only.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.DownCastList`2.Transform(`0)">
            <summary>
            No-op tranformation, simply return the <paramref name="source"/>
            as is.
            </summary>
            <param name="source">
            Instace of <typeparamref name="TSub"/> to be upcasted.
            </param>
            <returns>
            The same instance of <paramref name="source"/>.
            </returns>
            <exception cref="T:System.InvalidCastException">
            When <paramref name="source"/> is not of type <typeparamref name="TSub"/>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.DownCastList`2.TryReverse(`1,`0@)">
            <summary>
            Converts object of type <typeparamref name="TBase"/> to
            <typeparamref name="TSub"/>.
            </summary>
            <remarks>
            This implementation always return <c>false</c>. Subclasses that
            support reversing should override this method.
            </remarks>
            <param name="target">
            Instance of <typeparamref name="TBase"/> to be converted.
            </param>
            <param name="source">
            Converted object of type <typeparamref name="TSub"/>.
            </param>
            <returns>
            <c>true</c> when reserving is supported, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.DownCastList`2.Reverse(`1)">
            <summary>
            Converts the object of type <typeparamref name="TSub"/> to
            object of type <typeparamref name="TBase"/>.
            </summary>
            <remarks>
            This implementaiton simply returns the <paramref name="target"/>.
            </remarks>
            <param name="target">item passed to this list</param>
            <returns>converted item that can be passed to the underlaying source list</returns>
        </member>
        <member name="T:Spring.Collections.Generic.HashedSet`1">
            <summary>
            Implements an <see cref="T:Spring.Collections.ISet"/> based on a
            hash table.
            </summary>
            <remarks>
            <p>
            This will give the best lookup, add, and remove performance for very
            large data-sets, but iteration will occur in no particular order.
            </p>
            </remarks>
            <seealso cref="T:Spring.Collections.ISet"/>
        </member>
        <member name="M:Spring.Collections.Generic.HashedSet`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Collections.HashedSet"/> class.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.HashedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Collections.HashedSet"/> class, and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">
            A collection of elements that defines the initial set contents.
            </param>
        </member>
        <member name="T:Spring.Collections.Generic.INavigableDictionary`2">
            <summary> 
            A <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> extended with navigation methods returning the
            closest matches for given search targets. 
            </summary>
            <remarks>
            Methods <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.LowerEntry(`0)"/>, 
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.FloorEntry(`0)"/>, 
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.CeilingEntry(`0)"/>,
            and <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.HigherEntry(`0)"/> 
            return objects associated with keys respectively less than, less than or equal,
            greater than or equal, and greater than a given key, returning
            <c>null</c> if there is no such key.  Similarly, methods
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.LowerKey(`0)"/>, 
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.FloorKey(`0)"/>, 
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.CeilingKey(`0)"/>, and
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.HigherKey(`0)"/> 
            return only the associated keys. All of these
            methods are designed for locating, not traversing entries.
            
            <p/>
            A <see cref="T:Spring.Collections.Generic.INavigableDictionary`2"/> may be viewed and traversed in either
            ascending or descending key order.  The <see cref="T:System.Collections.IDictionary"/> properties
            <see cref="P:System.Collections.IDictionary.Keys"/> and <see cref="P:System.Collections.IDictionary.Values"/> return ascending views, and
            the additional methods <see cref="P:Spring.Collections.Generic.INavigableDictionary`2.DescendingKeys"/> and
            <see cref="P:Spring.Collections.Generic.INavigableDictionary`2.DescendingEntries"/> return descending views. The
            performance of ascending traversals is likely to be faster than
            descending traversals.  Notice that it is possible to perform
            subrange traversals in either direction using <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableSubDictionary(`0,`0)"/>.
            Methods <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableSubDictionary(`0,`0)"/>, <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableHeadDictionary(`0)"/>, and
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableTailDictionary(`0)"/> differ from the similarly named
            <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> methods only in that the returned maps
            are guaranteed to obey the <see cref="T:Spring.Collections.Generic.INavigableDictionary`2"/> interface.
            <p/>
            This interface additionally defines methods <see cref="P:Spring.Collections.Generic.INavigableDictionary`2.FirstEntry"/>,
            <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.PollFirstEntry"/>, 
            <see cref="P:Spring.Collections.Generic.INavigableDictionary`2.LastEntry"/>, 
            and <see cref="M:Spring.Collections.Generic.INavigableDictionary`2.PollLastEntry"/> that return and/or remove the least and
            greatest mappings, if any exist, else returning <c>null</c>.
            </remarks>
            
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET) </author>
        </member>
        <member name="T:Spring.Collections.Generic.ISortedDictionary`2">
            <summary>
            An interface representing a <see cref="T:System.Collections.IDictionary"/>, sorted in ascending order.
            </summary>
            <author>Griffin Caprio</author>
        </member>
        <member name="M:Spring.Collections.Generic.ISortedDictionary`2.HeadDictionary(`0)">
            <summary>
            Returns a <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> view of this dictionary, where all elements have keys less
            than <paramref name="ceilingKey"/>
            </summary>
            <param name="ceilingKey">the key</param>
            <returns>A <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> view of this dictionary, where all elements have keys less
            than <paramref name="ceilingKey"/></returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISortedDictionary`2.SubDictionary(`0,`0)">
            <summary>
            Returns a <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> view of this dictionary, where all elements have keys greater than
            <paramref name="floorKey"/> inclusive and less than <paramref name="ceilingKey"/> exclusive.
            </summary>
            <param name="floorKey">lowest key</param>
            <param name="ceilingKey">highest key</param>
            <returns>A <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> view of this dictionary, where all elements have keys greater than
            <paramref name="floorKey"/> inclusive and less than <paramref name="ceilingKey"/> exclusive.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISortedDictionary`2.TailDictionary(`0)">
            <summary>
            Returns a <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/>  view of this dictionary, where all elements have keys greater than
            <paramref name="floorKey"/>
            </summary>
            <param name="floorKey">the key</param>
            <returns>A <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/>  view of this dictionary, where all elements have keys greater than
            <paramref name="floorKey"/></returns>
        </member>
        <member name="P:Spring.Collections.Generic.ISortedDictionary`2.IsEmpty">
            <summary>
            Gets a flag indicating if the <see cref="T:Spring.Collections.Generic.ISortedDictionary`2"/> is empty.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.ISortedDictionary`2.FirstKey">
            <summary>
            Gets the first (lowest) key in this dictionary
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.ISortedDictionary`2.LastKey">
            <summary>
            Gets the last ( highest ) key in this dictionary
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.LowerEntry(`0)">
            <summary> 
            Returns a <see cref="T:System.Collections.DictionaryEntry"/>  associated with the greatest key
            strictly less than the given key, or <c>null</c> if there is
            no such key.
            </summary>
            <param name="key">the key</param>
            <returns> 
            an entry with the greatest key less than <paramref name="key"/>,
            or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.LowerKey(`0)">
            <summary> 
            Returns the greatest key strictly less than the given key, or
            <c>null</c> if there is no such key.
            </summary>
            <param name="key">the key</param>
            <returns> the greatest key less than <paramref name="key"/>,
            or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.FloorEntry(`0)">
            <summary> 
            Returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with the greatest key
            less than or equal to the given key, or <c>null</c> if there
            is no such key.
            </summary>
            <param name="key">the key</param>
            <returns> an entry with the greatest key less than or equal to
            <paramref name="key"/>, or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.FloorKey(`0)">
            <summary> 
            Returns the greatest key less than or equal to the given key,
            or <c>null</c> if there is no such key.
            </summary>
            <param name="key">the key
            </param>
            <returns> the greatest key less than or equal to <paramref name="key"/>,
            or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.CeilingEntry(`0)">
            <summary> 
            Returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with the least key
            greater than or equal to the given key, or <c>null</c> if
            there is no such key.
            </summary>
            <param name="key">the key</param>
            <returns> an entry with the least key greater than or equal to
            <paramref name="key"/>, or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.CeilingKey(`0)">
            <summary> 
            Returns the least key greater than or equal to the given key,
            or <c>null</c> if there is no such key.
            </summary>
            <param name="key">the key
            </param>
            <returns> the least key greater than or equal to <paramref name="key"/>,
            or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.HigherEntry(`0)">
            <summary> 
            Returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with the least key
            strictly greater than the given key, or <c>null</c> if there
            is no such key.
            </summary>
            <param name="key">the key</param>
            <returns> an entry with the least key greater than <paramref name="key"/>,
            or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.HigherKey(`0)">
            <summary> 
            Returns the least key strictly greater than the given key, or
            <c>null</c> if there is no such key.
            </summary>
            <param name="key">the key</param>
            <returns> the least key greater than <paramref name="key"/>,
            or <c>null</c> if there is no such key
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.PollFirstEntry">
            <summary> 
            Removes and returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with
            the least key in this dictionary, or <c>null</c> if the dictionary is empty.
            </summary>
            <returns> the removed first entry of this dictionary,
            or <c>null</c> if this dictionary is empty
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.PollLastEntry">
            <summary> 
            Removes and returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with
            the greatest key in this dictionary, or <c>null</c> if the dictionary is empty.
            </summary>
            <returns> the removed last entry of this dictionary,
            or <c>null</c> if this dictionary is empty
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableSubDictionary(`0,`0)">
            <summary> 
            Returns a view of the portion of this dictionary whose keys range from
            <paramref name="fromKey"/>, inclusive, to <parmref name="toKey"/> , exclusive.  
            </summary>
            <remarks>
            If <paramref name="fromKey"/> and <parmref name="toKey"/> are equal, the returned dictionary
            is empty.  The returned dictionary is backed by this dictionary, so changes
            in the returned dictionary are reflected in this dictionary, and vice-versa.
            The returned dictionary supports all optional dictionary operations that this
            dictionary supports.
            
            <p/>
            The returned dictionary will throw an <see cref="T:System.ArgumentException"/> 
            on an attempt to insert a key outside its range.
            </remarks>
            <param name="fromKey">
            low endpoint (inclusive) of the keys in the returned dictionary
            </param>
            <param name="toKey">
            high endpoint (exclusive) of the keys in the returned dictionary
            </param>
            <returns> a view of the portion of this dictionary whose keys range from
            <paramref name="fromKey"/>, inclusive, to <parmref name="toKey"/>, exclusive
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableHeadDictionary(`0)">
            <summary> 
            Returns a view of the portion of this dictionary whose keys are
            strictly less than <paramref name="toKey"/>.  
            </summary>
            <remarks> 
            The returned dictionary is backed
            by this dictionary, so changes in the returned dictionary are reflected in
            this dictionary, and vice-versa.  The returned dictionary supports all
            optional dictionary operations that this dictionary supports.
            
            <p/>
            The returned dictionary will throw an <see cref="T:System.ArgumentException"/>
            on an attempt to insert a key outside its range.
            </remarks>
            <param name="toKey">
            high endpoint (exclusive) of the keys in the returned dictionary
            </param>
            <returns> 
            a view of the portion of this dictionary whose keys are strictly
            less than <paramref name="toKey"/>
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableDictionary`2.NavigableTailDictionary(`0)">
            <summary> 
            Returns a view of the portion of this dictionary whose keys are
            greater than or equal to <paramref name="fromKey"/>.  
            </summary>
            <remarks> 
            The returned dictionary is backed by this dictionary, so changes in the returned dictionary are
            reflected in this dictionary, and vice-versa.  The returned dictionary
            supports all optional dictionary operations that this dictionary supports.
            
            <p/>
            The returned dictionary will throw an <see cref="T:System.ArgumentException"/>
            on an attempt to insert a key outside its range.
            </remarks>
            <param name="fromKey">low endpoint (inclusive) of the keys in the returned dictionary
            </param>
            <returns> a view of the portion of this dictionary whose keys are greater
            than or equal to <paramref name="fromKey"/>
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.INavigableDictionary`2.FirstEntry">
            <summary> 
            Returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with the least
            key in this dictionary, or <c>null</c> if the dictionary is empty.
            </summary>
            <returns> an entry with the least key,
            or <c>null</c> if this dictionary is empty
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.INavigableDictionary`2.LastEntry">
            <summary> 
            Returns a <see cref="T:System.Collections.DictionaryEntry"/> associated with the greatest
            key in this dictionary, or <c>null</c> if the dictionary is empty.
            </summary>
            <returns> an entry with the greatest key,
            or <c>null</c> if this dictionary is empty
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.INavigableDictionary`2.DescendingKeys">
            <summary> 
            Returns a <see cref="T:Spring.Collections.Generic.ISet`1"/> view of the keys contained in this dictionary.
            </summary>
            <remarks>
            The set's iterator returns the keys in descending order.
            The set is backed by the dictionary, so changes to the dictionary are
            reflected in the set, and vice-versa.  If the dictionary is modified
            while an iteration over the set is in progress (except through
            the iterator's own remove operation), the results of
            the iteration are undefined.  The set supports element removal,
            which removes the corresponding mapping from the dictionary, via the
            <see cref="M:Spring.Collections.Generic.ISet`1.Remove(`0)"/>,
            <see cref="M:Spring.Collections.Generic.ISet`1.RemoveAll(System.Collections.Generic.ICollection{`0})"/>, <see cref="M:Spring.Collections.Generic.ISet`1.RetainAll(System.Collections.Generic.ICollection{`0})"/>, 
            and <see cref="M:Spring.Collections.Generic.ISet`1.Clear"/> operations.  
            It does not support the <see cref="M:Spring.Collections.Generic.ISet`1.Add(`0)"/> or <see cref="M:Spring.Collections.Generic.ISet`1.AddAll(System.Collections.Generic.ICollection{`0})"/>
            operations.
            </remarks>
            <returns> 
            a set view of the keys contained in this dictionary, sorted indescending order
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.INavigableDictionary`2.DescendingEntries">
            <summary> 
            Returns a <see cref="T:Spring.Collections.ISet"/> view of the key / value pairs contained in this dictionary.
            </summary>
            <remarks>
            The set's iterator returns the entries in descending order.
            The set is backed by the dictionary, so changes to the dictionary are
            reflected in the set, and vice-versa.  If the dictionary is modified
            while an iteration over the set is in progress (except through
            the iterator's own remove operation), the results of
            the iteration are undefined.  The set supports element removal,
            which removes the corresponding mapping from the dictionary, via the
            <see cref="M:Spring.Collections.Generic.ISet`1.Remove(`0)"/>,
            <see cref="M:Spring.Collections.Generic.ISet`1.RemoveAll(System.Collections.Generic.ICollection{`0})"/>, <see cref="M:Spring.Collections.Generic.ISet`1.RetainAll(System.Collections.Generic.ICollection{`0})"/>, 
            and <see cref="M:Spring.Collections.Generic.ISet`1.Clear"/> operations.  
            It does not support the <see cref="M:Spring.Collections.Generic.ISet`1.Add(`0)"/> or <see cref="M:Spring.Collections.Generic.ISet`1.AddAll(System.Collections.Generic.ICollection{`0})"/>
            operations.
            </remarks>
            <returns> 
            a set view of the mappings contained in this dictionary,
            sorted in descending key order
            </returns>
        </member>
        <member name="T:Spring.Collections.Generic.INavigableSet`1">
            <summary> 
            An extension of the <see cref="T:Spring.Collections.ISet"/> interface that provides a number of
            navigation methods reporting closest matches for given search targets.
            </summary>
            <remarks>
            <p>
            Methods <see cref="M:Spring.Collections.Generic.INavigableSet`1.Lower(`0)"/>, 
            <see cref="M:Spring.Collections.Generic.INavigableSet`1.Floor(`0)"/>,
            <see cref="M:Spring.Collections.Generic.INavigableSet`1.Ceiling(`0)"/>,
            and <see cref="M:Spring.Collections.Generic.INavigableSet`1.Higher(`0)"/>
            return elements respectively less than, less than or equal,
            greater than or equal, and greater than a given element, returning
            <c>null</c> if there is no such element.
            </p>
            <p>
            A <see cref="T:Spring.Collections.Generic.INavigableSet`1"/> may be viewed and traversed
            in either ascending or descending order. The
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            method returns an ascending
            <see cref="T:System.Collections.IEnumerator"/> and
            the additional method
            <see cref="M:Spring.Collections.Generic.INavigableSet`1.GetDescendingEnumerator"/>
            returns a descending <see cref="T:System.Collections.IEnumerator"/>.
            The performance of ascending traversals is likely to be faster
            than descending traversals.  This interface additionally defines the
            methods <see cref="M:Spring.Collections.Generic.INavigableSet`1.PollFirst"/> and
            <see cref="M:Spring.Collections.Generic.INavigableSet`1.PollLast"/> that return and
            remove the lowest and highest element, if one exists, else returning
            <c>null</c>. Methods <see cref="M:Spring.Collections.Generic.INavigableSet`1.NavigableSubSet(`0,`0)"/>
            <see cref="M:Spring.Collections.Generic.INavigableSet`1.NavigableHeadSet(`0)"/>, and
            <see cref="M:Spring.Collections.Generic.INavigableSet`1.NavigableTailSet(`0)"/> differ from
            the similarly named <see cref="T:Spring.Collections.SortedSet"/> methods only
            in that the returned <see cref="T:Spring.Collections.ISet"/> references are guaranteed to obey the
            <see cref="T:Spring.Collections.Generic.INavigableSet`1"/> interface.
            </p>
            <p>
            The return values of navigation methods may be ambiguous in implementations
            that permit <c>null</c> elements. However, even in this case the
            result can be disambiguated by checking the return value of the
            <see cref="M:Spring.Collections.Generic.ISet`1.Contains(`0)"/> (via <c>Contains(null)</c>).
            To avoid such issues, implementations of this interface are encouraged to
            <em>not</em> permit the insertion of <c>null</c> elements.
            </p>
            </remarks>
            <author>Griffin Caprio</author>
            <version>$Id: INavigableSet.cs,v 1.2 2006/10/02 02:36:07 gcaprio Exp $</version>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.Lower(`0)">
            <summary>
            Returns the greatest element in this set strictly less than the
            supplied <paramref name="element"/>, or <c>null</c> if there
            is no such element.
            </summary>
            <param name="element">The value to match.</param>
            <returns>
            The greatest element less than <paramref name="element"/>, or
            <c>null</c> if there is no such element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.Floor(`0)">
            <summary>
            Returns the greatest element in this set less than or equal to
            the supplied <paramref name="element"/>, or <c>null</c> if there
            is no such element.
            </summary>
            <param name="element">The value to match.</param>
            <returns>
            The greatest element less than or equal to <paramref name="element"/>,
            or <c>null</c> if there is no such element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.Ceiling(`0)">
            <summary>
            Returns the least element in this set greater than or equal to
            the supplied <paramref name="element"/>, or <c>null</c> if there
            is no such element.
            </summary>
            <param name="element">The value to match.</param>
            <returns>
            The least element greater than or equal to <paramref name="element"/>,
            or <c>null</c> if there is no such element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.Higher(`0)">
            <summary>
            Returns the least element in this set strictly greater than the
            supplied <paramref name="element"/>, or <c>null</c> if there
            is no such element.
            </summary>
            <param name="element">The value to match.</param>
            <returns>
            The least element greater than <paramref name="element"/>,
            or <c>null</c> if there is no such element.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.PollFirst">
            <summary>
            Retrieves and removes the first (lowest) element.
            </summary>
            <returns>
            The first element, or <c>null</c> if this set is empty.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.PollLast">
            <summary>
            Retrieves and removes the last (highest) element.
            </summary>
            <returns>
            The last element, or <c>null</c> if this set is empty.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.GetDescendingEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the elements
            in this set, in descending order.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> over the elements in this
            set, in descending order.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.NavigableSubSet(`0,`0)">
            <summary>
            Returns a view of the portion of this set whose elements range
            from <paramref name="fromElement"/>, inclusive, to <paramref name="toElement"/>,
            exclusive.
            </summary>
            <remarks>
            <p>
            If <paramref name="fromElement"/> and <paramref name="toElement"/> are
            equal, the returned set is empty. The returned set is backed by this set,
            so changes in the returned set are reflected in this set, and vice-versa.
            The returned set supports all optional set operations that this set
            supports.
            </p>
            <p>
            The returned set must throw an <see cref="T:System.ArgumentException"/> 
            on an attempt to insert an element outside its range.
            </p>
            </remarks>
            <param name="fromElement">
            The low endpoint (inclusive) of the returned set.
            </param>
            <param name="toElement">
            The high endpoint (exclusive) of the returned set.
            </param>
            <returns>
            A view of the portion of this set whose elements range from
            <paramref name="fromElement"/>, inclusive, to
            <paramref name="toElement"/>, exclusive
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.NavigableHeadSet(`0)">
            <summary>
            Returns a view of the portion of this set whose elements are
            strictly less than <paramref name="toElement"/>. 
            </summary>
            <remarks>
            <p>
            The returned set is backed by this set, so changes in the returned
            set are reflected in this set, and vice-versa. The returned set
            supports all optional set operations that this set supports.
            </p>
            <p>
            The returned set must throw an <see cref="T:System.ArgumentException"/>
            on an attempt to insert an element outside its range.
            </p>
            </remarks>
            <param name="toElement">high endpoint (exclusive) of the returned set
            </param>
            <returns>
            A view of the portion of this set whose elements are strictly less than
            <paramref name="toElement"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.NavigableTailSet(`0)">
            <summary>
            Returns a view of the portion of this set whose elements are
            greater than or equal to <paramref name="fromElement"/>.
            </summary>
            <remarks>
            <p>
            The returned set is backed by this set, so changes in the returned set
            are reflected in this set, and vice-versa. The returned set supports all
            optional set operations that this set supports.
            </p>
            <p>
            The returned set will throw an <see cref="T:System.ArgumentException"/>
            on an attempt to insert an element outside its range.
            </p>
            </remarks>
            <param name="fromElement">
            The low endpoint (inclusive) of the returned set.
            </param>
            <returns>
            A view of the portion of this set whose elements are greater
            than or equal to <paramref name="fromElement"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.HeadSet(`0)">
            <summary>
            Returns a portion of the list whose elements are less than the
            supplied <paramref name="limit"/>.
            </summary>
            <param name="limit">
            The end element of the portion to extract.
            </param>
            <returns>
            The portion of the collection whose elements are less than the
            supplied <paramref name="limit"/>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.SubSet(`0,`0)">
            <summary>
            Returns a portion of the list whose elements are greater than the
            supplied <paramref name="lowerLimit"/> parameter and less than the
            supplied <paramref name="upperLimit"/> parameter.
            </summary>
            <param name="upperLimit">
            The start element of the portion to extract.</param>
            <param name="lowerLimit">
            The end element of the portion to extract.
            </param>
            <returns>The relevant portion of the collection.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.INavigableSet`1.TailSet(`0)">
            <summary>
            Returns a portion of the list whose elements are greater than the
            supplied <paramref name="limit"/>.
            </summary>
            <param name="limit">
            The start element of the portion to extract.
            </param>
            <returns>
            The portion of the collection whose elements are greater than the
            supplied <paramref name="limit"/>.
            </returns>
        </member>
        <member name="T:Spring.Collections.Generic.ISortedSet`1">
            <summary>
            An interface representing a <see cref="T:Spring.Collections.ISet"/>, sorted in ascending order.
            </summary>
            <author>Griffin Caprio</author>
        </member>
        <member name="M:Spring.Collections.Generic.ISortedSet`1.HeadSet(`0)">
            <summary>
            Returns a portion of the list whose elements are less than the limit object parameter.
            </summary>
            <param name="limit">The end element of the portion to extract.</param>
            <returns>The portion of the collection whose elements are less than the limit object parameter.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISortedSet`1.SubSet(`0,`0)">
            <summary>
            Returns a portion of the list whose elements are greater that the lowerLimit parameter less than the upperLimit parameter.
            </summary>
            <param name="lowerLimit">The start element of the portion to extract.</param>
            <param name="upperLimit">The end element of the portion to extract.</param>
            <returns>The portion of the collection.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.ISortedSet`1.TailSet(`0)">
            <summary>
            Returns a portion of the list whose elements are greater than the limit object parameter.
            </summary>
            <param name="limit">The start element of the portion to extract.</param>
            <returns>The portion of the collection whose elements are greater than the limit object parameter.</returns>
        </member>
        <member name="T:Spring.Collections.Generic.PriorityQueue`1">
            <summary> 
            An unbounded priority <see cref="T:Spring.Collections.Generic.IQueue`1"/> based on a priority
            heap. The elements of priority queue are ordered according their
            <see cref="T:System.IComparable`1">natural ordering</see>, or by an
            <see cref="T:System.Collections.IComparer"/> provided at queue construction time, 
            depending on which constructor is used. A priority queue does not 
            permit <c>null</c> elements. A priority queue relying on 
            natural ordering also does not permit insertion of non-comparable 
            objects (doing so will result in <see cref="T:System.InvalidCastException"/>.
            </summary>
            <remarks>
            <para>
            The <i>head</i> of this queue is the <i>least</i> element
            with respect to the specified ordering.  If multiple elements are
            tied for least value, the head is one of those elements -- ties are
            broken arbitrarily. The queue retrieval operations <c>Poll</c>, 
            <c>Remove</c>, <c>Peek</c>, and <c>Element</c> access the element at 
            the head of the queue.
            </para>
            <para>
            A priority queue is unbounded, but has an internal
            <i>capacity</i> governing the size of an array used to store the
            elements on the queue.  It is always at least as large as the queue
            size.  As elements are added to a priority queue, its capacity
            grows automatically.  The details of the growth policy are not
            specified.
            </para>
            <para>
            This class and its enumerator implement all of the <i>optional</i> 
            methods of the <see cref="T:System.Collections.Generic.ICollection`1"/> and 
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> interfaces. The enumerator provided in 
            method <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> is <b>not</b> 
            guaranteed to traverse the elements of the priority queue in any
            particular order. If you need ordered traversal, consider using 
            <c>Array.Sort(pq.ToArray())</c>.
            </para>
            <para>
            <b>Note that this implementation is NOT synchronized.</b> Multiple 
            threads should not access a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> instance 
            concurrently if any of the threads modifies the list structurally. 
            Instead, use the thread-safe <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> .
            </para>
            <para>
            Implementation note: this implementation provides O(log(n)) time for 
            the enqueing and dequeing methods (<c>Offer</c>, <c>Poll</c>, 
            <c>Remove</c> and <c>Add</c>); linear time for the <c>Remove(T)</c> 
            and <c>Contains(T)</c> methods; and constant time for the retrieval 
            methods (<c>Peek</c>, <c>Element</c>, and <c>Count</c>).
            </para>
            </remarks>
            <author>Josh Bloch</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Collections.Generic.PriorityQueue`1._queue">
            <summary> 
            Priority queue represented as a balanced binary heap: the two children
            of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The priority queue is
            ordered by comparator, or by the elements' natural ordering, if
            comparator is null:  For each node n in the heap and each descendant d
            of n, n &lt;= d.
            
            The element with the lowest value is in queue[0], assuming the queue is
            nonempty.
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.PriorityQueue`1._size">
            <summary> The number of elements in the priority queue.</summary>
        </member>
        <member name="F:Spring.Collections.Generic.PriorityQueue`1._comparer">
            <summary> 
            The comparator, or null if priority queue uses elements'
            natural ordering.
            </summary>
        </member>
        <member name="F:Spring.Collections.Generic.PriorityQueue`1._modCount">
            <summary> 
            The number of times this priority queue has been
            <i>structurally modified</i>.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor">
            <summary>
            Creates a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> with the default initial 
            capacity (11) that orders its elements according to their natural
            ordering (using <see cref="T:System.IComparable"/>).
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor(System.Int32)">
            <summary> 
            Creates a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> with the specified initial 
            capacity that orders its elements according to their natural ordering
            (using <see cref="T:System.IComparable"/>).
            </summary>
            <param name="initialCapacity">
            The initial capacity for this priority queue.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="initialCapacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor(System.Int32,System.Comparison{`0})">
            <summary> 
            Creates a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> with the specified initial
            capacity that orders its elements according to the specified 
            <paramref name="comparison"/>.
            </summary>
            <param name="initialCapacity">
            The initial capacity for this priority queue.
            </param>
            <param name="comparison">
            The comparison delegate used to order this priority queue. If 
            <c>null</c> then the order depends on the elements' natural 
            ordering.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="initialCapacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary> 
            Creates a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> with the specified initial
            capacity that orders its elements according to the specified 
            <paramref name="comparer"/>.
            </summary>
            <param name="initialCapacity">
            The initial capacity for this priority queue.
            </param>
            <param name="comparer">
            The comparer used to order this priority queue. If <c>null</c>
            then the order depends on the elements' natural ordering.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="initialCapacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Creates a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> containing the elements in
            the specified source.  If the specified source is another 
            <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/>, this priority queue will be ordered
            according to the same order.  Otherwise, the priority queue is ordered 
            according to its elements' <see cref="T:System.IComparable">natural order</see>.
            </summary>
            <param name="source">
            The collection whose elements are to be placed into this priority queue.
            </param>
            <exception cref="T:System.InvalidCastException">
            If elements of <paramref name="source"/> cannot be compared to 
            one another according to the priority queue's ordering.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="source"/> or any element with it is
            <c>null</c>.
            </exception>
            <exception cref="T:System.NullReferenceException">
            If there is <c>null</c> in source.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor(Spring.Collections.Generic.PriorityQueue{`0})">
            <summary> 
            Creates a <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> containing the elements in
            the specified priority queue.  This priority queue will be ordered
            according to the same ordering as the given priority queue.
            </summary>
            <param name="soruce">
            The priority queue whose elements are to be placed into this 
            priority queue.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="soruce"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.InitFromCollection(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes queue array with elements from the given
            <paramref name="source"/>.
            </summary>
            <param name="source">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create queue array from.
            </param>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.SiftUp(System.Int32,`0)">
            <summary> 
            Establishes the heap invariant assuming the heap
            satisfies the invariant except possibly for the leaf-node indexed by k
            (which may have a nextExecutionTime less than its parent's).
            </summary>
            <remarks>
            This method functions by "promoting" queue[k] up the hierarchy
            (by swapping it with its parent) repeatedly until queue[k]
            is greater than or equal to its parent.
            </remarks>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.SiftDown(System.Int32,`0)">
            <summary> 
            Establishes the heap invariant (described above) in the subtree
            rooted at k, which is assumed to satisfy the heap invariant except
            possibly for node k itself (which may be greater than its children).
            </summary>
            <remarks>
            This method functions by "demoting" queue[k] down the hierarchy
            (by swapping it with its smaller child) repeatedly until queue[k]
            is less than or equal to its children.
            </remarks>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Heapify">
            <summary> 
            Establishes the heap invariant in the entire tree,
            assuming nothing about the order of the elements prior to the call.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.RemoveAt(System.Int32)">
            <summary> 
            Removes and returns element located at <paramref name="i"/> from queue.  (Recall that the queue
            is one-based, so 1 &lt;= i &lt;= size.)
            </summary>
            <remarks>
            Normally this method leaves the elements at positions from 1 up to i-1,
            inclusive, untouched.  Under these circumstances, it returns <c>null</c>.
            Occasionally, in order to maintain the heap invariant, it must move
            the last element of the list to some index in the range [2, i-1],
            and move the element previously at position (i/2) to position i.
            Under these circumstances, this method returns the element that was
            previously at the end of the list and is now at some position between
            2 and i-1 inclusive.
            </remarks>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Grow(System.Int32)">
            <summary>Increases the capacity of the array.</summary>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Offer(`0)">
            <summary> 
            Inserts the specified element into this queue if it is possible to do
            so immediately without violating capacity restrictions.
            </summary>
            <remarks>
            <p>
            When using a capacity-restricted queue, this method is generally
            preferable to <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Add(`0)"/>,
            which can fail to insert an element only by throwing an exception.
            </p>
            </remarks>
            <param name="element">
            The element to add.
            </param>
            <returns>
            <c>true</c> if the element was added to this queue.
            </returns>
            <exception cref="T:System.InvalidCastException">
            if the specified element cannot be compared
            with elements currently in the priority queue according
            to the priority queue's ordering.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If the element cannot be added at this time due to capacity restrictions.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the supplied <paramref name="element"/> is
            <c>null</c> and this queue does not permit <c>null</c>
            elements.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Peek(`0@)">
            <summary> 
            Retrieves, but does not remove, the head of this queue into the
            out parameter <paramref name="element"/>, or returns <c>false</c>
            if this queue is empty.
            </summary>
            <returns> 
            <c>true</c> when the the head of this queue is return. <c>false</c>
            when the queue is empty.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Remove(`0)">
            <summary> 
            Removes a single instance of the specified element from this
            queue, if it is present.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.GetEnumerator">
            <summary> 
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the elements in this queue. 
            The enumeratoar does not return the elements in any particular order.
            </summary>
            <returns> an enumerator over the elements in this queue.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Clear">
            <summary> 
            Removes all elements from the priority queue.
            The queue will be empty after this call returns.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Poll(`0@)">
            <summary> 
            Retrieves and removes the head of this queue into the out parameter
            <paramref name="element"/>, or returns <c>false</c> if this queue
            is empty.
            </summary>
            <returns> 
            <c>true</c> when the the head of this queue is return. <c>false</c>
            when the queue is empty.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Contains(`0)">
            <summary>
            Queries the queue to see if it contains the specified <paramref name="item"/>
            </summary>
            <param name="item">element to look for.</param>
            <returns><c>true</c> if the queue contains the <paramref name="item"/>, 
            <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0},System.Predicate{`0})">
            <summary> 
            Removes at most the given number of available elements that meet 
            the criteria defined by <paramref name="selectCriteria"/> from this 
            queue and invoke the given <paramref name="action"/> on each 
            element in order until the <paramref name="stopCriteria"/> is met.
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to invoke the 
            <paramref name="action"/> on the elements may result in elements 
            being neither, either or both in the queue or processed when the 
            associated exception is thrown.
            </remarks>
            <param name="action">The action to performe on each element.</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <param name="selectCriteria">The criteria to filter the elements.</param>
            <param name="stopCriteria">The criteria to stop drain</param>
            <returns>The number of elements processed.</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified action is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> 
            Save the state of the instance to a stream (that
            is, serialize it).
            </summary>
            <serialData> The length of the array backing the instance is
            emitted (int), followed by all of its elements (each an
            <see cref="T:System.Object"/>) in the proper order.
            </serialData>
            <param name="serializationInfo">the stream</param>
            <param name="context">the context</param>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> 
            Reconstitute the <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/> instance from a stream (that is,
            deserialize it).
            </summary>
            <param name="serializationInfo">the stream</param>
            <param name="context">the context</param>
        </member>
        <member name="M:Spring.Collections.Generic.PriorityQueue`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does the actual work of copying to array.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <param name="ensureCapacity">
            If is <c>true</c>, calls <see cref="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)"/>
            </param>
            <returns>
            A new array of same runtime type as <paramref name="array"/> if 
            <paramref name="array"/> is too small to hold all elements and 
            <paramref name="ensureCapacity"/> is <c>false</c>. Otherwise
            the <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="P:Spring.Collections.Generic.PriorityQueue`1.RemainingCapacity">
            <summary>
            Return <see cref="F:System.Int32.MaxValue"/> as <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/>
            is unbounded.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.PriorityQueue`1.Capacity">
            <summary>
            Returns <see cref="F:System.Int32.MaxValue"/> as <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/>
            is unbounded.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.PriorityQueue`1.Count">
            <summary>
            Returns the queue count.
            </summary>
        </member>
        <member name="P:Spring.Collections.Generic.PriorityQueue`1.Comparer">
            <summary> Returns the comparator used to order this collection, or <c>null</c>
            if this collection is sorted according to its elements natural ordering
            (using <see cref="T:System.IComparable"/>).
            
            </summary>
            <returns> the comparator used to order this collection, or <c>null</c>
            if this collection is sorted according to its elements natural ordering.
            </returns>
        </member>
        <member name="T:Spring.Collections.Generic.SortedSet`1">
            <summary>
            Implements an <see cref="T:Spring.Collections.ISet"/> based on a sorted
            tree.
            </summary>
            <remarks>
            <p>
            This gives good performance for operations on very large data-sets,
            though not as good - asymptotically - as a
            <see cref="T:Spring.Collections.HashedSet"/>. However, iteration occurs
            in order.
            </p>
            <p>
            Elements that you put into this type of collection must implement
            <see cref="T:System.IComparable"/>, and they must actually be comparable.
            You can't mix <see cref="T:System.String"/> and
            <see cref="T:System.Int32"/> values, for example.
            </p>
            <p>
            This <see cref="T:Spring.Collections.ISet"/> implementation does
            <b>not</b> support elements that are <see langword="null"/>.
            </p>
            </remarks>
            <seealso cref="T:Spring.Collections.ISet"/>
        </member>
        <member name="M:Spring.Collections.Generic.SortedSet`1.#ctor">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new set instance based on a sorted tree using <param name="comparer"/> for ordering.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on a sorted tree and initializes
            it based on a collection of elements.
            </summary>
            <param name="initialValues">
            A collection of elements that defines the initial set contents.
            </param>
        </member>
        <member name="T:Spring.Collections.Generic.TransformingEnumerator`2">
            <summary>
            <see cref="T:Spring.Collections.Generic.TransformingEnumerator`2"/> transforms the elements
            from the source instance of <see cref="T:System.Collections.Generic.IEnumerator`1"/> using a given transformer.
            </summary>
            <typeparam name="TTarget">
            Type of the data element after the transformed
            </typeparam>
            <typeparam name="TSource">
            Type of the data element of the orignal enumerator
            </typeparam>
            <seealso cref="T:System.Converter`2"/>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`2.#ctor(System.Collections.Generic.IEnumerator{`0},System.Converter{`0,`1})">
            <summary>
            The only constructor of <c>TransformingEnumerator</c>
            </summary>
            <param name="source">
            The source enumerator of which the elements will be transformed
            </param>
            <param name="transformer">
            The transformer to transform the elements.
            </param>
            <exception cref="T:System.ArgumentNullException">
            when parameter <paramref name="source"/> or <paramref name="transformer"/> 
            is null.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`2.Dispose">
            <summary>
            Disposes the enumerator causes the source enumerator to be disposed 
             as well.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`2.DoReset">
            <summary>
            Implement the <see cref="M:Spring.Collections.Generic.AbstractEnumerator`1.Reset"/> function.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`2.GoNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            
            <returns>
            true if the enumerator was successfully advanced to the next 
             element; false if the enumerator has passed the end of the 
             collection.
            </returns>
            
            <exception cref="T:System.InvalidOperationException">
             The collection was modified after the enumerator was created. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`2.FetchCurrent">
            <summary>
            Gets the element in the collection at the current position of the 
             enumerator.
            </summary>
            
            <returns>
            The element in the collection at the current position of the 
             enumerator.
            </returns>
            
        </member>
        <member name="T:Spring.Collections.Generic.TransformingEnumerator`1">
            <summary>
            <see cref="T:Spring.Collections.Generic.TransformingEnumerator`1"/> transforms the elements
            from a source instance of <see cref="T:System.Collections.IEnumerator"/> using a given transformer.
            </summary>
            <typeparam name="TTarget">
            Type of the data element after the transformed
            </typeparam>
            <seealso cref="T:System.Converter`2"/>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`1.#ctor(System.Collections.IEnumerator,System.Converter{System.Object,`0})">
            <summary>
            The only constructor of <c>TransformingEnumerator</c>
            </summary>
            <param name="source">
            The source enumerator of which the elements will be transformed
            </param>
            <param name="transformer">
            The transformer to transform the elements.
            </param>
            <exception cref="T:System.ArgumentNullException">
            when parameter <paramref name="source"/> or <paramref name="transformer"/> 
            is null.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`1.Dispose">
            <summary>
            Disposes the enumerator causes the source enumerator to be disposed
             if it implements the <see cref="T:System.IDisposable"/>. Otherwise, nothing
             is done.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`1.DoReset">
            <summary>
            Implements the <see cref="M:Spring.Collections.Generic.AbstractEnumerator`1.Reset"/> function.
            </summary>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`1.FetchCurrent">
            <summary>
            Gets the element in the collection at the current position of the 
             enumerator.
            </summary>
            
            <returns>
            The element in the collection at the current position of the 
             enumerator.
            </returns>
            
        </member>
        <member name="M:Spring.Collections.Generic.TransformingEnumerator`1.GoNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            
            <returns>
            true if the enumerator was successfully advanced to the next 
             element; false if the enumerator has passed the end of the 
             collection.
            </returns>
            
            <exception cref="T:System.InvalidOperationException">
             The collection was modified after the enumerator was created. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="T:Spring.Collections.Generic.TransformingList`2">
            <summary>
            Class to provide a new strong typed list of type 
            <typeparamref name="TTo"/> from anothe strong typed list
            of type <typeparamref name="TFrom"/> without copying the elements.
            </summary>
            <remarks>
            <para>
            The constructed new list is a shadow copy of the source list.
            Changes to any one of the list will be seen by another.
            </para>
            </remarks>
            <typeparam name="TFrom">the element type of the new list</typeparam>
            <typeparam name="TTo">the element type of the source list</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingList`2.#ctor(System.Collections.Generic.IList{`0},System.Converter{`0,`1})">
            <summary>
            Construct a new list of type <typeparamref name="TTo"/> based on
            <paramref name="source"/> list.
            </summary>
            <param name="source">the source list</param>
            <param name="transformer">
            Transformer that converts type <typeparamref name="TFrom"/> to 
            <typeparamref name="TTo"/>
            </param>
            <exception cref="T:System.ArgumentNullException">
            When parameter <paramref name="transformer"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingList`2.#ctor(System.Collections.Generic.IList{`0},System.Converter{`0,`1},System.Converter{`1,`0})">
            <summary>
            Construct a new list of type <typeparamref name="TTo"/> based on
            <paramref name="source"/> list.
            </summary>
            <param name="source">the source list</param>
            <param name="transformer">
            Converts type <typeparamref name="TFrom"/> to <typeparamref name="TTo"/>
            </param>
            <param name="reverser">
            Converts type <typeparamref name="TTo"/> to <typeparamref name="TFrom"/>
            </param>
            <exception cref="T:System.ArgumentNullException">
            When parameter <paramref name="transformer"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingList`2.TryReverse(`1,`0@)">
            <summary>
            Try converts object of type <typeparamref name="TTo"/> to
            <typeparamref name="TFrom"/>.
            </summary>
            <remarks>
            This implementation return <c>false</c> if and only if the
            reverser is given during the instance construction.
            </remarks>
            <param name="target">
            Instance of <typeparamref name="TTo"/> to be converted.
            </param>
            <param name="source">
            Converted object of type <typeparamref name="TFrom"/>.
            </param>
            <returns>
            <c>true</c> when reserving is supported, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Collections.Generic.TransformingList`2.Transform(`0)">
            <summary>
            Converts the object of type <typeparamref name="TFrom"/> to
            object of type <typeparamref name="TTo"/> using the transformer
            provided to the constructor.
            </summary>
            <param name="source">item that is from the underlaying source list</param>
            <returns>converted item that can be returned by this list</returns>
        </member>
        <member name="T:Spring.SystemExtensions">
            <summary>
            Static class to provide extension methods to basic system function.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.SystemExtensions.ToArrayOptimized``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convert source to an array possibly in a more optimized way then
            <see cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <remarks>
            <para>
            If the source is a <see cref="T:System.Collections.Generic.List`1"/>, returns the result of
            <see cref="M:System.Collections.Generic.List`1.ToArray"/>.
            </para>
            <para>
            If the source is a <see cref="T:Spring.Collections.Generic.AbstractCollection`1"/>, returns the
            result of <see cref="M:Spring.Collections.Generic.AbstractCollection`1.ToArray"/>.
            </para>
            <para>
            Else, returns the result of <see cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the elements of <paramref name="source"/>.
            </typeparam>
            <param name="source">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an array from.
            </param>
            <returns>
            An array that contains the elements from <paramref name="source"/>.
            </returns>
        </member>
        <member name="M:Spring.SystemExtensions.IsCurrentThreadInterrupted">
            <summary>
            Tests whether the current thread has been interrupted.  The
            <i>interrupted status</i> of the thread is cleared by this method.
            In other words, if this method were to be called twice in 
            succession, the second call would return false (unless the current 
            thread were interrupted again, after the first call had cleared 
            its interrupted status and before the second call had examined it).
            </summary>
            <remarks>
            A thread interruption ignored because a thread was not alive at the 
            time of the interrupt will be reflected by this method returning 
            false.
            </remarks>
            <returns>
            <c>true</c> if the current thread has been interrupted; <c>false</c> 
            otherwise.
            </returns>
        </member>
        <member name="M:Spring.SystemExtensions.PreserveStackTrace``1(``0)">
            <summary>
            Lock the stack trace information of the given <paramref name="exception"/>
            so that it can be rethrow without losing the stack information.
            </summary>
            <remarks>
            <example>
                <code>
                try
                {
                    //...
                }
                catch( Exception e )
                {
                    //...
                    throw e.PreserveStackTrace(); //rethrow the exception - preserving the full call stack trace!
                }
                </code>
            </example>
            </remarks>
            <param name="exception">The exception to lock the statck trace.</param>
            <returns>The same <paramref name="exception"/> with stack traced locked.</returns>
        </member>
        <member name="T:Spring.Threading.BoundedBuffer">
            <summary> Efficient array-based bounded buffer class.
            </summary>
        </member>
        <member name="T:Spring.Threading.IBoundedChannel">
            <summary> A channel that is known to have a capacity, signifying
            that <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/> operations may block when the
            capacity is reached. Various implementations may have
            intrinsically hard-wired capacities, capacities that are fixed upon
            construction, or dynamically adjustable capacities.
            </summary>
            <seealso cref="T:Spring.Threading.DefaultChannelCapacity">
            
            </seealso>
        </member>
        <member name="T:Spring.Threading.IChannel">
            <summary> Main interface for buffers, queues, pipes, conduits, etc.
            <p>
            An <see cref="T:Spring.Threading.IChannel"/> represents anything that you can put items
            into and take them out of. As with the <see cref="T:Spring.Threading.ISync"/>
            interface, both blocking (<see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>, <see cref="M:Spring.Threading.ITakable.Take"/>),
            and timeouts (<see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>, <see cref="M:Spring.Threading.ITakable.Poll(System.Int64)"/>) policies
            are provided. Using a
            zero timeout for offer and poll results in a pure balking policy.
            </p>
            <p>
            To aid in efforts to use <see cref="T:Spring.Threading.IChannel"/>s in a more typesafe manner,
            this interface extends <see cref="T:Spring.Threading.IPuttable"/> and <see cref="T:Spring.Threading.ITakable"/>. 
            You can restrict
            arguments of instance variables to this type as a way of
            guaranteeing that producers never try to take, or consumers put.
            </p>
            <p>
            A given channel implementation might or might not have bounded
            capacity or other insertion constraints, so in general, you cannot tell if
            a given put will block. However, channels that are designed to 
            have an element capacity (and so always block when full)
            should implement the <see cref="T:Spring.Threading.IBoundedChannel"/> subinterface.
            </p>
            <p>
            Channels may hold any kind of item. However,
            insertion of null is not in general supported. Implementations
            may (all currently do) throw <see cref="T:System.ArgumentException"/> upon attempts to
            insert null. 
            </p>
            <p>
            By design, the <see cref="T:Spring.Threading.IChannel"/> interface does not support any methods to determine
            the current number of elements being held in the channel.
            This decision reflects the fact that in
            concurrent programming, such methods are so rarely useful
            that including them invites misuse; at best they could 
            provide a snapshot of current
            state, that could change immediately after being reported.
            It is better practice to instead use poll and offer to try
            to take and put elements without blocking. For example,
            to empty out the current contents of a channel, you could write:
            </p>
            <example>
             try 
             {
                for (;;) 
                {
                    object item = channel.Poll(0);
                    if (item != null)
                        Process(item);
                    else
                        break;
                }
             }
             catch(ThreadInterruptedException ex) { ... }
            </example>
            <p>
            However, it is possible to determine whether an item
            exists in a <see cref="T:Spring.Threading.IChannel"/> via <see cref="M:Spring.Threading.IChannel.Peek"/>, which returns
            but does NOT remove the next item that can be taken (or null
            if there is no such item). The peek operation has a limited
            range of applicability, and must be used with care. Unless it
            is known that a given thread is the only possible consumer
            of a channel, and that no time-out-based <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/> operations
            are ever invoked, there is no guarantee that the item returned
            by peek will be available for a subsequent take.
            </p>
            <p>
            When appropriate, you can define an <c>IsEmpty</c> method to
            return whether <see cref="M:Spring.Threading.IChannel.Peek"/> returns <c>null</c>.
            </p>
            <p>
            Also, as a compromise, even though it does not appear in interface,
            implementation classes that can readily compute the number
            of elements support a <c>Size</c> property. This allows careful
            use, for example in queue length monitors, appropriate to the
            particular implementation constraints and properties.</p>
            <p>
            All channels allow multiple producers and/or consumers.
            They do not support any kind of <em>Close</em> method
            to shut down operation or indicate completion of particular
            producer or consumer threads. 
            If you need to signal completion, one way to do it is to
            create a class such as
            <example>
            class EndOfStream { 
            // Application-dependent field/methods
            }
            </example>
            And to have producers put an instance of this class into
            the channel when they are done. The consumer side can then
            check this via
            <example>
            object x = aChannel.Take();
            if (x is EndOfStream) 
                // special actions; perhaps terminate
            else
                // process normally
            </example>
            </p>
            <p>
            In time-out based methods (<see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>, <see cref="M:Spring.Threading.ITakable.Poll(System.Int64)"/>), 
            time bounds are interpreted in
            a coarse-grained, best-effort fashion. Since there is no
            way to escape out of a wait for a synchronized
            method/block, time bounds can sometimes be exceeded when
            there is a lot contention for the channel. Additionally,
            some <see cref="T:Spring.Threading.IChannel"/> semantics entail a <em>point of
            no return</em> where, once some parts of the operation have completed,
            others must follow, regardless of time bound.
            </p>
            <p>
            Interruptions are in general handled as early as possible
            in all methods. Normally, <see cref="T:System.Threading.ThreadInterruptedException"/>s are thrown
            in <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>/<see cref="M:Spring.Threading.ITakable.Take"/> and <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/> 
            /<see cref="M:Spring.Threading.ITakable.Take"/> if interruption
            is detected upon entry to the method, as well as in any
            later context surrounding waits. 
            </p>
            <p>
            If a put returns normally, an offer
            returns true, or a put or poll returns non-null, the operation
            completed successfully. 
            In all other cases, the operation fails cleanly: the
            element is not put or taken.</p>
            </summary>
            <seealso cref="T:Spring.Threading.ISync">
            </seealso>
            <seealso cref="T:Spring.Threading.IBoundedChannel">
            
            </seealso>
        </member>
        <member name="T:Spring.Threading.IPuttable">
            <summary> This interface exists to enable stricter type checking
            for <see cref="T:Spring.Threading.IChannel"/>s. A method argument or instance variable
            in a producer object can be declared as only a <see cref="T:Spring.Threading.IPuttable"/>
            rather than a <see cref="T:Spring.Threading.IChannel"/>, in which case the compiler
            will disallow take operations.
            <p>
            Full method descriptions appear in the <see cref="T:Spring.Threading.IChannel"/> interface.</p>
            </summary>
            <seealso cref="T:Spring.Threading.IChannel">
            </seealso>
            <seealso cref="T:Spring.Threading.ITakable">
            
            </seealso>
        </member>
        <member name="M:Spring.Threading.IPuttable.Put(System.Object)">
            <summary> Place item in the channel, possibly waiting indefinitely until
            it can be accepted. <see cref="T:Spring.Threading.IChannel"/>s implementing the 
            <see cref="T:Spring.Threading.IBoundedChannel"/>
            subinterface are generally guaranteed to block on puts upon
            reaching capacity, but other implementations may or may not block.
            </summary>
            <param name="item">the element to be inserted. Should be non-null.
            </param>
            <exception cref="T:System.Threading.ThreadInterruptedException">  if the current thread has
            been interrupted at a point at which interruption
            is detected, in which case the element is guaranteed not
            to be inserted. Otherwise, on normal return, the element is guaranteed
            to have been inserted.
            
            </exception>
        </member>
        <member name="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)">
            <summary> Place item in channel only if it can be accepted within
            msecs milliseconds. The time bound is interpreted in
            a coarse-grained, best-effort fashion. 
            </summary>
            <param name="item">the element to be inserted. Should be non-null.
            </param>
            <param name="msecs">the number of milliseconds to wait. If less than
            or equal to zero, the method does not perform any timed waits,
            but might still require
            access to a synchronization lock, which can impose unbounded
            delay if there is a lot of contention for the channel.
            </param>
            <returns> true if accepted, else false
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException"> if the current thread has
            been interrupted at a point at which interruption
            is detected, in which case the element is guaranteed not
            to be inserted (i.e., is equivalent to a false return).
            
            </exception>
        </member>
        <member name="T:Spring.Threading.ITakable">
            <summary> This interface exists to enable stricter type checking
            for channels. A method argument or instance variable
            in a consumer object can be declared as only a <see cref="T:Spring.Threading.ITakable"/>
            rather than a <see cref="T:Spring.Threading.IChannel"/>, in which case a compiler
            will disallow put operations.
            <p>
            Full method descriptions appear in the <see cref="T:Spring.Threading.IChannel"/> interface.</p>
            </summary>
            <seealso cref="T:Spring.Threading.IChannel">
            </seealso>
            <seealso cref="T:Spring.Threading.IPuttable">
            
            </seealso>
        </member>
        <member name="M:Spring.Threading.ITakable.Take">
            <summary> Return and remove an item from channel, 
            possibly waiting indefinitely until
            such an item exists.
            </summary>
            <returns>  some item from the channel. Different implementations
            may guarantee various properties (such as FIFO) about that item
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException"> if the current thread has
            been interrupted at a point at which interruption
            is detected, in which case state of the channel is unchanged.
            </exception>
        </member>
        <member name="M:Spring.Threading.ITakable.Poll(System.Int64)">
            <summary> Return and remove an item from channel only if one is available within
            msecs milliseconds. The time bound is interpreted in a coarse
            grained, best-effort fashion.
            </summary>
            <param name="msecs">the number of milliseconds to wait. If less than
            or equal to zero, the operation does not perform any timed waits,
            but might still require
            access to a synchronization lock, which can impose unbounded
            delay if there is a lot of contention for the channel.
            </param>
            <returns> some item, or null if the channel is empty.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException"> if the current thread has
            been interrupted at a point at which interruption
            is detected, in which case state of the channel is unchanged
            (i.e., equivalent to a false return).
            </exception>			
        </member>
        <member name="M:Spring.Threading.IChannel.Peek">
            <summary> Return, but do not remove object at head of <see cref="T:Spring.Threading.IChannel"/>,
            or null if it is empty.
            </summary>			
        </member>
        <member name="P:Spring.Threading.IBoundedChannel.Capacity">
            <summary> Return the maximum number of elements that can be held.</summary>
            <returns> the capacity of this channel.
            
            </returns>
        </member>
        <member name="F:Spring.Threading.BoundedBuffer.array_">
            <summary>
            the elements
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedBuffer.takePtr_">
            <summary>
            circular index for take mechanics
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedBuffer.putPtr_">
            <summary>
            circular index for put mechanics
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedBuffer.usedSlots_">
            <summary>
            length
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedBuffer.emptySlots_">
            <summary>
            capacity - length
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedBuffer.putMonitor_">
            <summary> Helper monitor to handle puts. 
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.#ctor(System.Int32)">
            <summary> Create a BoundedBuffer with the given capacity.</summary>
            <exception cref="T:System.ArgumentException"> if capacity less or equal to zero
            </exception>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.#ctor">
            <summary> Create a buffer with the current default capacity
            </summary>		
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.IncEmptySlots">
            <summary>
            safely increment empty slots
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.IncUsedSlots">
            <summary>
            safely increment used slots
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Insert(System.Object)">
            <summary>
            mechanics of put
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Extract">
            <summary>
            mechanics of take
            </summary>
            <returns>the next available item in the buffer</returns>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Peek">
            <summary>
            <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Put(System.Object)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Offer(System.Object,System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>
            </summary>
            <returns><code>true</code> if the object has been inserted, <code>false</code> otherwise</returns>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Take">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Take"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedBuffer.Poll(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Poll(System.Int64)"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.BoundedBuffer.Size">
            <summary>
            The current buffer size
            </summary>
        </member>
        <member name="P:Spring.Threading.BoundedBuffer.Capacity">
            <summary>
            The capacity of this buffer
            </summary>
        </member>
        <member name="T:Spring.Threading.BoundedLinkedQueue">
            <summary> A bounded variant of 
            LinkedQueue 
            class. 
            <p>This class may be
            preferable to 
            <see cref="T:Spring.Threading.BoundedBuffer"/>
            because it allows a bit more
            concurency among puts and takes,  because it does not
            pre-allocate fixed storage for elements, and allows 
            capacity to be dynamically reset.
            On the other hand, since it allocates a node object
            on each put, it can be slow on systems with slow
            allocation and GC.</p>
            <p>Also, it may be preferable to 
            <see cref="T:Spring.Threading.LinkedQueue"/> when you need to limit
            the capacity to prevent resource exhaustion. This protection
            normally does not hurt much performance-wise: when the
            queue is not empty or full, most puts and
            takes are still usually able to execute concurrently.</p>
            </summary>
            <seealso cref="T:Spring.Threading.LinkedQueue"/>
            <seealso cref="T:Spring.Threading.BoundedBuffer"/>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.head_">
            <summary> Dummy header node of list. The first actual node, if it exists, is always 
            at head_.next. After each take, the old first node becomes the head.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.last_">
            <summary> The last node of list. Put() appends to list, so modifies last_
            
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.putGuard_">
            <summary> Helper monitor. Ensures that only one put at a time executes.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.takeGuard_">
            <summary> Helper monitor. Protects and provides wait queue for takes
            
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.capacity_">
            <summary>Number of elements allowed *</summary>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.putSidePutPermits_">
            <summary> One side of a split permit count. 
            <p>The counts represent permits to do a put. (The queue is full when zero).
            Invariant: putSidePutPermits_ + takeSidePutPermits_ = capacity_ - length.
            (The length is never separately recorded, so this cannot be
            checked explicitly.)</p>
            <p>To minimize contention between puts and takes, the
            put side uses up all of its permits before transfering them from
            the take side.</p>
            <p>The take side just increments the count upon each take.
            Thus, most puts and take can run independently of each other unless
            the queue is empty or full.</p>
            Initial value is queue capacity.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedLinkedQueue.takeSidePutPermits_">
            <summary>Number of takes since last reconcile *</summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.#ctor(System.Int32)">
            <summary> Create a queue with the given capacity</summary>
            <exception cref="T:System.ArgumentException"> if capacity less or equal to zero
            
            </exception>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.#ctor">
            <summary> Create a queue with the current default capacity
            
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.ReconcilePutPermits">
            <summary> Move put permits from take side to put side; 
            return the number of put side permits that are available.
            Call only under synch on puGuard_ AND this.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Extract">
            <summary>Main mechanics for take/poll *</summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Peek">
            <summary>
            <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Take">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Take"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Poll(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Poll(System.Int64)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.AllowTake">
            <summary>Notify a waiting take if needed *</summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Insert(System.Object)">
            <summary> Create and insert a node.
            Call only under synch on putGuard_
            
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Put(System.Object)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedLinkedQueue.Offer(System.Object,System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.BoundedLinkedQueue.Capacity">
            <summary> Reset the capacity of this queue.
            If the new capacity is less than the old capacity,
            existing elements are NOT removed, but
            incoming puts will not proceed until the number of elements
            is less than the new capacity.
            </summary>
            <exception cref="T:System.ArgumentException"> if capacity less or equal to zero
            
            </exception>
        </member>
        <member name="P:Spring.Threading.BoundedLinkedQueue.IsEmpty">
            <summary>
            Utility method to avoid to call <see cref="M:Spring.Threading.BoundedLinkedQueue.Peek"/>
            </summary>
            <returns><c>true</c> if there are no items in the queue</returns>
        </member>
        <member name="P:Spring.Threading.BoundedLinkedQueue.Size">
            <summary> Return the number of elements in the queue.
            This is only a snapshot value, that may be in the midst 
            of changing. The returned value will be unreliable in the presence of
            active puts and takes, and should only be used as a heuristic
            estimate, for example for resource monitoring purposes.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.BoundedPriorityQueue">
            <summary> A heap-based priority queue, using semaphores for
            concurrency control. 
            The take operation returns the <em>least</em> element
            with respect to the given ordering. (If more than
            one element is tied for least value, one of them is
            arbitrarily chosen to be returned -- no guarantees
            are made for ordering across ties.)
            Ordering follows the JDK1.2 collection
            conventions: Either the elements must be Comparable, or
            a Comparator must be supplied. Comparison failures throw
            ClassCastExceptions during insertions and extractions.
            The implementation uses a standard array-based heap algorithm,
            as described in just about any data structures textbook.
            <p>
            Put and take operations may throw ClassCastException 
            if elements are not Comparable, or
            not comparable using the supplied comparator. 
            Since not all elements are compared on each operation
            it is possible that an exception will not be thrown 
            during insertion of non-comparable element, but will later be 
            encountered during another insertion or extraction.
            </p>
            </summary>
        </member>
        <member name="T:Spring.Threading.SemaphoreControlledChannel">
            <summary> Abstract class for channels that use Semaphores to
            control puts and takes.
            </summary>
        </member>
        <member name="F:Spring.Threading.SemaphoreControlledChannel.putGuard_">
            <summary>
            guard for put
            </summary>
        </member>
        <member name="F:Spring.Threading.SemaphoreControlledChannel.takeGuard_">
            <summary>
            guard for take
            </summary>
        </member>
        <member name="F:Spring.Threading.SemaphoreControlledChannel.capacity_">
            <summary>
            channel capacity
            </summary>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.#ctor(System.Int32)">
            <summary> Create a channel with the given capacity and default
            semaphore implementation
            </summary>
            <exception cref="T:System.ArgumentException"> if capacity less or equal to zero
            
            </exception>		
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.#ctor(System.Int32,System.Type)">
            <summary> Create a channel with the given capacity and 
            semaphore implementations instantiated from the supplied class
            </summary>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Size">
            <summary> Return the number of elements in the buffer.
            This is only a snapshot value, that may change
            immediately after returning.
            </summary>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Insert(System.Object)">
            <summary> Internal mechanics of put.
            </summary>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Extract">
            <summary> Internal mechanics of take.
            </summary>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Put(System.Object)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Offer(System.Object,System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Take">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Take"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Poll(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Take"/>
            </summary>
            <param name="msecs"></param>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.SemaphoreControlledChannel.Peek">
            <summary>
            Abstract, <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.SemaphoreControlledChannel.Capacity">
            <summary>
            <see cref="T:Spring.Threading.IBoundedChannel"/>
            </summary>
        </member>
        <member name="F:Spring.Threading.BoundedPriorityQueue.heap_">
            <summary>
            The backing heap
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.#ctor(System.Int32,System.Collections.IComparer)">
            <summary> Create a priority queue with the given capacity and comparator</summary>
            <exception cref="T:System.ArgumentException">  if capacity less or equal to zero
            
            </exception>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.#ctor(System.Collections.IComparer)">
            <summary> Create a priority queue with the current default capacity
            and the given comparator
            
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.#ctor(System.Int32)">
            <summary> Create a priority queue with the given capacity,
            and relying on natural ordering.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.#ctor">
            <summary> Create a priority queue with the current default capacity
            and relying on natural ordering.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.#ctor(System.Int32,System.Collections.IComparer,System.Type)">
            <summary> Create a priority queue with the given capacity and comparator, using
            the supplied Semaphore class for semaphores.
            </summary>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.Insert(System.Object)">
            <summary> Internal mechanics of put.
            </summary>
            <remarks>Delegates to heap</remarks>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.Extract">
            <summary> Internal mechanics of take.
            </summary>
            <remarks>Delegates to heap</remarks>
        </member>
        <member name="M:Spring.Threading.BoundedPriorityQueue.Peek">
            <summary>
            <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
            <remarks>Delegates to heap</remarks>
        </member>
        <member name="T:Spring.Threading.BrokenBarrierException">
            <summary> 
            Exception thrown when a thread tries to wait upon a barrier that is in a 
            broken state, or which enters the broken state while the thread is waiting.
            </summary>
            <seealso cref="T:Spring.Threading.CyclicBarrier"/>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.#ctor">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.BrokenBarrierException"/> instance.
            </summary>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.#ctor(System.Int32)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.BrokenBarrierException"/> with given index
            </summary>
            <param name="index">Index that the barrier would have returned upon normal return.</param>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.#ctor(System.Int32,System.String)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.BrokenBarrierException"/> with the specified index and detail message.
            </summary>
            <param name="message">Message for the exception.</param>
            <param name="index">Index that the barrier would have returned upon normal return.</param>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.BrokenBarrierException"/> instance.
            </summary>
            <param name="message">Message for the exception.</param>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.BrokenBarrierException"/> instance.
            </summary>
            <param name="message">Message for the exception.</param>
            <param name="innerException">inner exception</param>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.BrokenBarrierException"/> instance.
            </summary>
            <remarks>
            This constructor is used by serialization/deserialization
            code, so it should not be used directly
            </remarks>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
            that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/>
            that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:Spring.Threading.BrokenBarrierException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Override of GetObjectData to allow for private serialization
            </summary>
            <param name="info">serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="P:Spring.Threading.BrokenBarrierException.Index">
            <summary> 
            The index that barrier would have returned upon normal return;
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1">
            <summary>
            A thread-safe variant of <see cref="T:System.Collections.Generic.List`1"/> in which all mutative
            operations (<see cref="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Add(`0)"/>, <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Item(System.Int32)"/>, and so on) are
            implemented by making a fresh copy of the underlying array.
            </summary>
            <remarks>
            <para>
            This is ordinarily too costly, but may be <i>more</i> efficient
            than alternatives when traversal operations vastly outnumber
            mutations, and is useful when you cannot or don't want to
            synchronize traversals, yet need to preclude interference among
            concurrent threads.  The "snapshot" style enumerator method uses a
            reference to the state of the array at the point that the enumerator
            was created. This array never changes during the lifetime of the
            enumerator, so interference is impossible and the enumerator is
            guaranteed not to throw <see cref="T:System.InvalidOperationException"/>.
            The enumerator will not reflect additions, removals, or changes to
            the list since the enuemrator was created.
            </para>
            <para>
            All elements are permitted, including <c>null</c>.
            </para>
            <para>
            Memory consistency effects: As with other concurrent
            collections, actions in a thread prior to placing an object into a
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> <i>happen-before</i> actions
            subsequent to the access or removal of that element from
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> in another thread.
            </para>
            </remarks>
            <typeparam name="T">Type of the element.</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.#ctor">
            <summary>
            Creates an empty <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> containing the elements
            of the specified <paramref name="collection"/>, in the enumeration
            order.
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.BinarySearch(`0)">
            <summary>
            Searches the entire sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> for an
            element using the default comparer and returns the zero-based index
            of the element.
            </summary>
            <param name="item">
            The object to locate. The value can be <c>null</c> for reference types.
            </param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>,
            if item is found; otherwise, a negative number that is the bitwise
            complement of the index of the next element that is larger than item or,
            if there is no larger element, the bitwise complement of <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Count"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find an
            implementation of the <see cref="T:System.IComparable`1"/> generic interface or
            the <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the entire sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> for an
            element using the specified <paramref name="comparer"/> and returns
            the zero-based index of the element.
            </summary>
            <param name="item">
            The object to locate. The value can be <c>null</c> for reference types.
            </param>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing
            elements.
            <br/>-or-<br/>
            <c>null</c> to use the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.
            </param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>,
            if item is found; otherwise, a negative number that is the bitwise
            complement of the index of the next element that is larger than item or,
            if there is no larger element, the bitwise complement of <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Count"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="comparer"/> is <c>null</c>, and the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find an implementation of the
            <see cref="T:System.IComparable`1"/> generic interface or the
            <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.BinarySearch(`0,System.Comparison{`0})">
            <summary>
            Searches the entire sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> for an
            element using the specified <see cref="T:System.Comparison`1"/>.
            </summary>
            <param name="item">
            The object to locate. The value can be <c>null</c> for reference types.
            </param>
            <param name="comparison">
            The <see cref="T:System.Comparison`1"/> to use when comparing elements.
            </param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>,
            if item is found; otherwise, a negative number that is the bitwise
            complement of the index of the next element that is larger than item or,
            if there is no larger element, the bitwise complement of <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Count"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="comparison"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the entire sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> for an
            element using the specified <paramref name="comparer"/> and returns
            the zero-based index of the element.
            </summary>
            <param name="index">
            The zero-based starting index of the range to search.
            </param>
            <param name="count">
            The length of the range to search.
            </param>
            <param name="item">
            The object to locate. The value can be <c>null</c> for reference types.
            </param>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing
            elements.
            <br/>-or-<br/>
            <c>null</c> to use the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.
            </param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>,
            if item is found; otherwise, a negative number that is the bitwise
            complement of the index of the next element that is larger than item or,
            if there is no larger element, the bitwise complement of <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Count"/>.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            <br/>-or-<br/>
            <paramref name="count"/> is less than 0
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not
            specify a valid section in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="comparer"/> is <c>null</c>, and the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find an implementation of the
            <see cref="T:System.IComparable`1"/> generic interface or the
            <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Returns <c>true</c> if this list contains all of the elements of the
            specified <paramref name="collection"/>.
            </summary>
            <param name="collection">
            Collection to be checked for containment in this list.
            </param>
            <returns>
            <c>true</c> if this list contains all of the elements of the
            specified <paramref name="collection"/>
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="collection"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            Converts the elements in the current <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>
            to another type, and returns a list containing the converted elements.
            </summary>
            <typeparam name="TOutput">
            Type of the converted elements.
            </typeparam>
            <param name="converter">
            A <see cref="T:System.Converter`2"/> delegate that converts each
            element from one type to another type.
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> of the target type containing the
            converted elements from the current <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="converter"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Exists(System.Predicate{`0})">
            <summary>
            Determines whether the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> contains
            elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the
            conditions of the elements to search for.
            </param>
            <returns>
            <c>true</c> if the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> contains one or
            more elements that match the conditions defined by the specified
            predicate; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Find(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the first occurrence within the
            entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The first element that matches the conditions defined by the
            specified predicate, if found; otherwise, the default value for
            type <typeparamref name="T"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindLast(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the last occurrence within the
            entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The last element that matches the conditions defined by the
            specified predicate, if found; otherwise, the default value for
            type <typeparamref name="T"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindAll(System.Predicate{`0})">
            <summary>
            Retrieves the all the elements that match the conditions defined
            by the specified predicate.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> containing all the elements that
            match the conditions defined by the specified predicate, if found;
            otherwise, an empty <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the zero-based index of the first
            occurrence within the entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that
            matches the conditions defined by <paramref name="match"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the zero-based index of the last
            occurrence within the entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that
            matches the conditions defined by <paramref name="match"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the zero-based index of the first
            occurrence within the range of elements in the 
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>  that extends from the specified
            <paramref name="index"/> to the last element.
            </summary>
            <param name="index">
            The zero-based starting index of the search.
            </param>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that
            matches the conditions defined by <paramref name="match"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the zero-based index of the last
            occurrence within the range of elements in the 
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that extends from the first
            element to specified <paramref name="index"/>.
            </summary>
            <param name="index">
            The zero-based starting index of the search.
            </param>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that
            matches the conditions defined by <paramref name="match"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the zero-based index of the first
            occurrence within the range of elements in the 
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that starts at the specified
            <paramref name="index"/> and contains the specified number of elements.
            </summary>
            <param name="index">
            The zero-based starting index of the search.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that
            matches the conditions defined by <paramref name="match"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            <br/>-or-<br/>
            <paramref name="count"/> is less than 0
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not
            specify a valid section in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the
            specified predicate, and returns the zero-based index of the last
            occurrence within the range of elements in the 
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that contains the specified number
            of elements and starts at the specified <paramref name="index"/>.
            </summary>
            <param name="index">
            The zero-based starting index of the search.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the element to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that
            matches the conditions defined by <paramref name="match"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            <br/>-or-<br/>
            <paramref name="count"/> is less than 0
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not
            specify a valid section in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each element of the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="action">
            The <see cref="T:System.Action`1"/> delegate to perform on each element of
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/> is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <remarks>
            Subclass must implement this method.
            </remarks>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate 
            through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            
            <param name="item">
            The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </param>
            <returns>
            The index of item if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.IndexOf(`0,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index
            of the first occurrence within the range of elements in the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that extends from the specified 
            index to the last element.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. The
            value can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search.
            </param>
            <returns>
            The zero-based index of the first occurrence of item within the
            range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that
            extends from index to the last element, if found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is outside the range of valid indexes for the 
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index
            of the first occurrence within the range of elements in the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that starts at the specified index
            and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. The
            value can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <returns>
            The zero-based index of the first occurrence of item within the
            range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that
            starts at index and contains count number of elements, if found;
            otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.<br/>
            -or-<br/>
            <paramref name="count"/> is less than 0.<br/>
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote
            a valid range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. 
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the
            list.
            </summary>
            
            <returns>
            <c>true</c> if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; 
            otherwise, <c>false</c>. This method also returns false if item is not found in the 
            original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes the all the elements that match the conditions defined by
            the specified predicate.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            of the elements to remove.
            </param>
            <returns>
            The number of elements removed from the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="match"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of elements from the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="index">
            The zero-based starting index of the range of elements to remove.
            </param>
            <param name="count">
            The number of elements to remove.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.<br/>
            -or-<br/>
            <paramref name="count"/> is less than 0.<br/>
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote
            a valid range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. 
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Reverse">
            <summary>
            Reverses the order of the elements in the entire
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the order of the elements in the specified range.
            </summary>
            <param name="index">
            The zero-based starting index of the range to reverse.
            </param>
            <param name="count">
            The number of elements in the range to reverse.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less than 0.<br/>
            -or-<br/>
            <paramref name="count"/> is less than 0.<br/>
            -or-<br/>
            <paramref name="index"/> is greater than size of the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote
            a valid range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. 
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            
            <param name="index">
            The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="item">
            The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <param name="index">
            The zero-based index at which item should be inserted.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the elements of a collection into the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> at the specified index.
            </summary>
            <param name="index">
            The zero-based index at which the new elements should be inserted.
            </param>
            <param name="collection">
            The collection whose elements should be inserted into the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. The collection itself cannot be
            <c>null</c>, but it can contain elements that are <c>null</c>, if
            type <typeparamref name="T"/> is a reference type.
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.LastIndexOf(`0)">
            <summary>
            Searches for the specified object and returns the zero-based index
            of the last occurrence within the range of elements within the
            entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. The
            value can be <c>null</c> for reference types.
            </param>
            <returns>
            The zero-based index of the last occurrence of item within the
            entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>, if found; otherwise, –1.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index
            of the last occurrence within the range of elements in the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that extends from the first element
            to the specified <paramref name="index"/>.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. The
            value can be <c>null</c> for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the backward search.
            </param>
            <returns>
            The zero-based index of the last occurrence of item within the
            range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that
            extends from the first element to <paramref name="index"/>, if
            found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index
            of the last occurrence within the range of elements in the
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that contains the specified number
            of elements and ends at the specified <paramref name="index"/>.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. The
            value can be <c>null</c> for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the backward search.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <returns>
            The zero-based index of the last occurrence of item within the
            range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> that
            contains <paramref name="count"/> number of elements and ends at
            <paramref name="index"/>, if found; otherwise, –1.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.<br/>
            -or-<br/>
            <paramref name="count"/> is less than 0.<br/>
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote
            a valid range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. 
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Add(`0)">
            <summary>
            Adds an item to the list.
            </summary>
            <param name="item">
            The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.AddIfAbsent(`0)">
            <summary>
            Append the element if not present.
            </summary>
            <param name="item">
            Element to be added to this list, if absent.
            </param>
            <returns>
            <c>true</c> if the element was added. Otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.AddRangeAbsent(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Appends all of the elements in the specified collection that
            are not already contained in this list, to the end of
            this list. Duplicated elements will be only added once.
            </summary>
            <param name="collection">
            Collection containing elements to be added to this list.
            </param>
            <returns>
            The number of elements added.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="collection"/> is null.
            </exception>
            <seealso cref="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.AddIfAbsent(`0)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.DoAddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Called by <see cref="M:Spring.Collections.Generic.AbstractCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/> to add items
            in <paramref name="collection"/> to this list, after the parameter
            is validated to be neither <c>null</c> nor this collection itself.
            </summary>
            <param name="collection">Collection of items to be added.</param>
            <returns>
            <c>true</c> if this collection is modified, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Sort">
            <summary>
            Sorts the elements in the entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>
            using the default comparer.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in the entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>
            using the specified <paramref name="comparer"/>.
            </summary>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing
            elements, or <c>null</c> to use the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.
            </param>
            <exception cref="T:System.ArgumentException">
            The implementation of <paramref name="comparer"/> caused an error
            during the sort. For example, <paramref name="comparer"/> might not
            return 0 when comparing an item with itself.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="comparer"/> is <c>null</c>, and the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find implementation of the
            <see cref="T:System.IComparable`1"/> generic interface or the 
            <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Sort(System.Comparison{`0})">
            <summary>
            Sorts the elements in the entire <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>
            using the specified.
            </summary>
            <param name="comparison">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing
            elements, or <c>null</c> to use the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.
            </param>
            <exception cref="T:System.ArgumentException">
            The implementation of <paramref name="comparison"/> caused an error
            during the sort. For example, <paramref name="comparison"/> might not
            return 0 when comparing an item with itself.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="comparison"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a range of elements in
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/> using the specified
            <paramref name="comparer"/>.
            </summary>
            <param name="index">
            The zero-based starting index of the range to sort.
            </param>
            <param name="count">
            The length of the range to sort.
            </param>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing
            elements, or <c>null</c> to use the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is outside the range of valid indexes for
            the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>.<br/>
            -or-<br/>
            <paramref name="count"/> is less than 0.<br/>
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote
            a valid range of elements in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>. 
            <br/>-or-<br/>
            The implementation of <paramref name="comparer"/> caused an error
            during the sort. For example, <paramref name="comparer"/> might not
            return 0 when comparing an item with itself.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="comparer"/> is <c>null</c>, and the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find implementation of the
            <see cref="T:System.IComparable`1"/> generic interface or the 
            <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines whether every element in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>
            matches the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions
            to check against the elements.
            </param>
            <returns>
            <c>true</c> if every element in the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteList`1"/>
            matches the conditions defined by the specified predicate; otherwise,
            <c>false</c>. If the list has no elements, the return value is <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.CopyTo(System.Array,System.Int32)">
             <summary>
             Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an 
             <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> 
             index.
             </summary>
            
             <param name="array">
             The one-dimensional <see cref="T:System.Array"/> that is the destination 
             of the elements copied from <see cref="T:System.Collections.ICollection"/>. The 
             <see cref="T:System.Array"/> must have zero-based indexing. 
             </param>
             <param name="index">
             The zero-based index in array at which copying begins. 
             </param>
             <exception cref="T:System.ArgumentNullException">array is null. </exception>
             <exception cref="T:System.ArgumentOutOfRangeException">
             index is less than zero. 
             </exception>
             <exception cref="T:System.ArgumentException">
             array is multidimensional.-or- index is equal to or greater than 
             the length of array.
             -or- 
             The number of elements in the source <see cref="T:System.Collections.ICollection"/> 
             is greater than the available space from index to the end of the 
             destination array. 
             </exception>
             <exception cref="T:System.InvalidCastException">
             The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast 
             automatically to the type of the destination array. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteList`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does the actual work of copying to array. Subclass is recommended to 
            override this method instead of <see cref="M:Spring.Collections.Generic.AbstractCollection`1.CopyTo(`0[],System.Int32)"/> 
            method, which does all neccessary parameter checking and raises proper 
            exception before calling this method.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <param name="ensureCapacity">
            If is <c>true</c>, calls <see cref="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)"/>
            </param>
            <returns>
            A new array of same runtime type as <paramref name="array"/> if 
            <paramref name="array"/> is too small to hold all elements and 
            <paramref name="ensureCapacity"/> is <c>false</c>. Otherwise
            the <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            
            <param name="index">
            The zero-based index of the element to get or set.</param>
            <returns>
            The element at the specified index.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            
            <returns>
            <c>false</c>.
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> 
            is synchronized (thread safe).
            </summary>
            <returns>
            <c>true</c>
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteList`1.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the 
            <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            <returns>
            An object that can be used to synchronize access to the 
            <see cref="T:System.Collections.ICollection"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.EnumerableToArrayBuffer`1.CopyTo(`0[],System.Int32)">
            <summary>
            Caller to guarantee items.Length > index >= 0
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.QueueBrokenException">
            <summary>
            Exception to indicate a queue is already broken.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2">
            <summary>
            Class TransformingBlockingQueue
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1">
            <summary> 
            This class provides skeletal implementations of some
            <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> operations.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.IBlockingQueue`1">
            <summary> 
            A <see cref="T:Spring.Collections.Generic.IQueue`1"/> that additionally supports operations
            that wait for the queue to become non-empty when retrieving an
            element, and wait for space to become available in the queue when
            storing an element.
            </summary>
            <remarks>
            <para>
            <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> methods come in four forms, with different ways
            of handling operations that cannot be satisfied immediately, but may be
            satisfied at some point in the future:
            <list type="bullet">
            <item>
            one throws an exception,
            </item>
            <item>
            the second returns a special value (either <c>default(T)</c> or 
            <see langword="false"/>, depending on the operation), 
            </item>
            <item>
            the third blocks the current thread indefinitely until the operation can succeed,
            and 
            </item>
            <item>
            the fourth blocks for only a given maximum time limit before giving
            up.
            </item>
            </list>
            </para>
            <para>
            A <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> may be capacity bounded. At any given
            time it may have a <see cref="P:Spring.Collections.Generic.IQueue`1.RemainingCapacity"/> beyond which no
            additional elements can be <see cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Put(`0)"/> without blocking.
            A <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> without any intrinsic capacity constraints always
            reports a remaining capacity of <see cref="F:System.Int32.MaxValue"/>.
            </para>
            <para>
            <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> implementations are designed to be used
            primarily for producer-consumer queues, but additionally support
            the <see cref="T:System.Collections.Generic.ICollection`1"/> interface.  So, for example, it is
            possible to remove an arbitrary element from a queue using
            <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>. 
            However, such operations are in general
            <b>not</b> performed very efficiently, and are intended for only
            occasional use, such as when a queued message is cancelled.
            </para>
            <para>
            A <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> does <b>not</b> intrinsically support
            any kind of 'close' or 'shutdown' operation to
            indicate that no more items will be added.  The needs and usage of
            such features tend to be implementation-dependent. For example, a
            common tactic is for producers to insert special
            <b>end-of-stream</b> or <b>poison</b> objects, that are
            interpreted accordingly when taken by consumers.
            </para>
            <para>
            A <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> can safely be used with multiple
            producers and multiple consumers.
            </para>
            <example>
            Usage example, based on a typical producer-consumer scenario. 
            TODO: Convert non-generic example below to using generic version
            <code>
            class Producer : IRunnable {
            	private IBlockingQueue queue;
            	Producer(IBlockingQueue q) { queue = q; }
            	public void Run() {
            		try {
            			while (true) { 
            				queue.Put(produce()); 
            			}
            		} catch (InterruptedException ex) { 
            			... handle ...
            		}
            	}
            	Object Produce() { ... }
            }
            
            class Consumer : IRunnable {
            	private IBlockingQueue queue;
            	Consumer(IBlockingQueue q) { queue = q; }
            	public void Run() {
            		try {
            			while (true) { Consume(queue.Take()); }
            		} catch (InterruptedException ex) { ... handle ...}
            	}
            	void Consume(object x) { ... }
            }
            
            class Setup {
            	void Main() {
            		IBlockingQueue q = new SomeQueueImplementation();
            		Producer p = new Producer(q);
            		Consumer c1 = new Consumer(q);
            		Consumer c2 = new Consumer(q);
            		new Thread(new ThreadStart(p.Run)).Start();
            		new Thread(new ThreadStart(c1.Run)).Start();
            		new Thread(new ThreadStart(c2.Run)).Start();
            	}
            }
            </code>
            </example>
            </remarks>
            <typeparam name="T">The type of the elements in the queue.</typeparam>
            <author>Doug Lea</author>
            <author>Griffin Caprio(.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Put(`0)">
            <summary> 
            Inserts the specified element into this queue, waiting if necessary
            for space to become available.
            </summary>
            <param name="element">the element to add</param>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Offer(`0,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </summary>
            <param name="element">The element to add.</param>
            <param name="duration">How long to wait before giving up.</param>
            <returns>
            <see langword="true"/> if successful, or <see langword="false"/> if
            the specified waiting time elapses before space is available.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the specified element is <see langword="null"/> and this queue 
            does not permit <c>null</c> elements.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element becomes available.
            </summary>
            <returns> the head of this queue</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Poll(System.TimeSpan,`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <param name="duration">How long to wait before giving up.</param>
            <returns> 
            <c>false</c> if the queue is still empty after waited for the time 
            specified by the <paramref name="duration"/>. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})">
            <summary> 
            Removes all available elements from this queue and adds them to the 
            given collection.  
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to add elements to 
            collection <paramref name="collection"/> may result in elements 
            being in neither, either or both collections when the associated 
            exception is thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">the collection to transfer elements into</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Predicate{`0})">
            <summary> 
            Removes all available elements that meet the criteria defined by 
            <paramref name="predicate"/> from this queue and adds them to the 
            given collection.  
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to add elements to 
            collection <paramref name="collection"/> may result in elements 
            being in neither, either or both collections when the associated 
            exception is thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">The collection to transfer elements into</param>
            <param name="predicate">The criteria to filter the elements</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)">
            <summary> 
            Removes at most the given number of available elements from
            this queue and adds them to the given collection.  
            </summary>
            <remarks> 
            This operation may be more
            efficient than repeatedly polling this queue.  A failure
            encountered while attempting to add elements to
            collection <paramref name="collection"/> may result in elements being in neither,
            either or both collections when the associated exception is
            thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">the collection to transfer elements into</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Removes at most the given number of available elements that meet 
            the criteria defined by <paramref name="predicate"/> from this 
            queue and adds them to the given collection.  
            </summary>
            <remarks> 
            This operation may be more
            efficient than repeatedly polling this queue.  A failure
            encountered while attempting to add elements to
            collection <paramref name="collection"/> may result in elements being in neither,
            either or both collections when the associated exception is
            thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">the collection to transfer elements into</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <param name="predicate">The criteria to filter the elements.</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.Put(`0)">
            <summary> 
            Inserts the specified element into this queue, waiting if necessary
            for space to become available.
            </summary>
            <param name="element">the element to add</param>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.Offer(`0,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </summary>
            <param name="element">The element to add.</param>
            <param name="duration">How long to wait before giving up.</param>
            <returns>
            <see langword="true"/> if successful, or <see langword="false"/> if
            the specified waiting time elapses before space is available.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element becomes available.
            </summary>
            <returns> the head of this queue</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.Poll(System.TimeSpan,`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <param name="duration">How long to wait before giving up.</param>
            <returns> 
            <c>false</c> if the queue is still empty after waited for the time 
            specified by the <paramref name="duration"/>. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})">
            <summary> 
            Removes all available elements from this queue and adds them to the 
            given collection.  
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to add elements to 
            collection <paramref name="collection"/> may result in elements 
            being in neither, either or both collections when the associated 
            exception is thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">the collection to transfer elements into</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Predicate{`0})">
            <summary> 
            Removes all available elements that meet the criteria defined by 
            <paramref name="predicate"/> from this queue and adds them to the 
            given collection.  
            </summary>
            <remarks>
            This operation may be more efficient than repeatedly polling this 
            queue.  A failure encountered while attempting to add elements to 
            collection <paramref name="collection"/> may result in elements 
            being in neither, either or both collections when the associated 
            exception is thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">The collection to transfer elements into</param>
            <param name="predicate">The criteria to filter the elements</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)">
            <summary> 
            Removes at most the given number of available elements from
            this queue and adds them to the given collection.  
            </summary>
            <remarks> 
            This operation may be more
            efficient than repeatedly polling this queue.  A failure
            encountered while attempting to add elements to
            collection <paramref name="collection"/> may result in elements being in neither,
            either or both collections when the associated exception is
            thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">the collection to transfer elements into</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Removes at most the given number of available elements that meet 
            the criteria defined by <paramref name="predicate"/> from this 
            queue and adds them to the given collection.  
            </summary>
            <remarks> 
            This operation may be more
            efficient than repeatedly polling this queue.  A failure
            encountered while attempting to add elements to
            collection <paramref name="collection"/> may result in elements being in neither,
            either or both collections when the associated exception is
            thrown.  Attempts to drain a queue to itself result in
            <see cref="T:System.ArgumentException"/>. Further, the behavior of
            this operation is undefined if the specified collection is
            modified while the operation is in progress.
            </remarks>
            <param name="collection">the collection to transfer elements into</param>
            <param name="maxElements">the maximum number of elements to transfer</param>
            <param name="predicate">The criteria to filter the elements.</param>
            <returns> the number of elements transferred</returns>
            <exception cref="T:System.InvalidOperationException">
            If the queue cannot be drained at this time.
            </exception>
            <exception cref="T:System.InvalidCastException">
            If the class of the supplied <paramref name="collection"/> prevents it
            from being used for the elemetns from the queue.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the specified collection is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="collection"/> represents the queue itself.
            </exception>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> 
            is synchronized (thread safe).
            </summary>
            <remarks>This implementaiton always return <see langword="true"/>.</remarks>
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"></see> 
            is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.#ctor(Spring.Threading.Collections.Generic.IBlockingQueue{`0},System.Converter{`0,`1},System.Converter{`1,`0})">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="tranformer"></param>
            <param name="reverser"></param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <remarks>
            Subclass must implement this method.
            </remarks>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate 
            through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Offer(`1)">
            <summary>
            Inserts the specified element into this queue if it is possible to 
            do so immediately without violating capacity restrictions. 
            </summary>
            <remarks>
            When using a capacity-restricted queue, this method is generally 
            preferable to <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>, which can fail to 
            insert an element only by throwing an exception. 
            </remarks>
            <param name="element">The element to add.</param>
            <returns>
            <c>true</c> if the element was added to this queue. Otherwise 
            <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="element"/> is <c>null</c> and the queue 
            implementation doesn't allow <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> 
            prevents it from being added to this queue. 
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Peek(`1@)">
            <summary>
            Retrieves, but does not remove, the head of this queue into out
            parameter <paramref name="element"/>.
            </summary>
            <param name="element">
            The head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> is the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Poll(`1@)">
            <summary>
            Retrieves and removes the head of this queue into out parameter
            <paramref name="element"/>. 
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> if the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.DoDrain(System.Action{`1},System.Int32,System.Predicate{`1})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Put(`1)">
            <summary> 
            Inserts the specified element into this queue, waiting if necessary
            for space to become available.
            </summary>
            <param name="element">the element to add</param>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Offer(`1,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </summary>
            <param name="element">The element to add.</param>
            <param name="duration">How long to wait before giving up.</param>
            <returns>
            <see langword="true"/> if successful, or <see langword="false"/> if
            the specified waiting time elapses before space is available.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element becomes available.
            </summary>
            <returns> the head of this queue</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Poll(System.TimeSpan,`1@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <param name="duration">How long to wait before giving up.</param>
            <returns> 
            <c>false</c> if the queue is still empty after waited for the time 
            specified by the <paramref name="duration"/>. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.RemainingCapacity">
            <summary>
            Returns the remaining capacity of this queue.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.TransformingBlockingQueue`2.Capacity">
            <summary>
            Returns the current capacity of this queue.
            </summary>
        </member>
        <member name="T:Spring.Threading.CountDownLatch">
            <summary> 
            A synchronization aid that allows one or more threads to wait until
            a set of operations being performed in other threads completes.
            </summary>
            <remarks>
            <para>
            A <see cref="T:Spring.Threading.CountDownLatch"/> is initialized with a given <b>count</b>.
            The <see cref="M:Spring.Threading.CountDownLatch.Await"/> and <see cref="M:Spring.Threading.CountDownLatch.Await(System.TimeSpan)"/> methods 
            block until the current <see cref="P:Spring.Threading.CountDownLatch.Count"/> reaches zero due to 
            invocations of the <see cref="M:Spring.Threading.CountDownLatch.CountDown"/> method, after which all 
            waiting threads are released and any subsequent invocations of 
            <see cref="M:Spring.Threading.CountDownLatch.Await"/> or <see cref="M:Spring.Threading.CountDownLatch.Await(System.TimeSpan)"/> return 
            immediately. This is a one-shot phenomenon -- the count cannot be reset.
            If you need a version that resets the count, consider using a 
            <see cref="T:Spring.Threading.CyclicBarrier"/>.
            </para>
            <para>
            A <see cref="T:Spring.Threading.CountDownLatch"/> is a versatile synchronization tool
            and can be used for a number of purposes.  A <see cref="T:Spring.Threading.CountDownLatch"/> 
            initialized with a count of one serves as a simple on/off latch, or 
            gate: all threads invoking <see cref="M:Spring.Threading.CountDownLatch.Await"/> or <see cref="M:Spring.Threading.CountDownLatch.Await(System.TimeSpan)"/>
            wait at the gate until it is opened by a thread invoking <see cref="M:Spring.Threading.CountDownLatch.CountDown"/>.
            A <see cref="T:Spring.Threading.CountDownLatch"/> initialized to <b>N</b> can be used to 
            make one thread wait until <b>N</b> threads have completed some action, 
            or some action has been completed <b>N</b> times.
            </para>
            <para>
            A useful property of a <see cref="T:Spring.Threading.CountDownLatch"/> is that it doesn't 
            require that threads calling <see cref="M:Spring.Threading.CountDownLatch.CountDown"/> wait for
            the count to reach zero before proceeding, it simply prevents any
            thread from proceeding past an <see cref="M:Spring.Threading.CountDownLatch.Await"/> or 
            <see cref="M:Spring.Threading.CountDownLatch.Await(System.TimeSpan)"/> until all threads could pass.
            </para>
            <para>
            <b>Memory consistency effects</b>: Actions in a thread prior to calling
            <see cref="M:Spring.Threading.CountDownLatch.CountDown"/> <i>happen-before</i> actions following a 
            successful return from a corresponding <see cref="M:Spring.Threading.CountDownLatch.Await"/> in another 
            thread.
            </para>
            <example>
            <b>Sample usage:</b> 
            <br/>
            Here is a pair of classes in which a group of worker threads use two 
            countdown latches:
            <list type="bullet">
            <item>
            The first is a start signal that prevents any worker from proceeding
            until the driver is ready for them to proceed.
            </item>
            <item>
            The second is a completion signal that allows the driver to wait
            until all workers have completed.
            </item>
            </list>
            
            <code>
            public class Driver { // ...
            	void Main() {
            		CountDownLatch startSignal = new CountDownLatch(1);
            		CountDownLatch doneSignal = new CountDownLatch(N);
            
            		for (int i = 0; i &lt; N; ++i)
            			new Thread(new Worker(startSignal, doneSignal).Run).Start();
            
            		doSomethingElse();            // don't let run yet
            		startSignal.CountDown();      // let all threads proceed
            		doSomethingElse();
            		doneSignal.Await();           // wait for all to finish
            	}
            }
            
            public class Worker {
            	private CountDownLatch startSignal;
            	private CountDownLatch doneSignal;
            	Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
            		this.startSignal = startSignal;
            		this.doneSignal = doneSignal;
            	}
            	public void Run() {
            		try {
            			startSignal.Await();
            			DoWork();
            			doneSignal.CountDown();
            		} catch (ThreadInterruptedException ex) {} // return;
            	}
            
            	void DoWork() { ... }
            }
            
            </code>
            Another typical usage would be to divide a problem into N parts,
            describe each part with a worker that executes that portion and counts 
            down on the latch, and queue all the <see cref="T:Spring.Threading.IRunnable"/>s to an
            <see cref="T:Spring.Threading.IExecutor"/>.  When all sub-parts are complete, the 
            coordinating thread will be able to pass through await. (When threads 
            must repeatedly count down in this way, instead use a 
            <see cref="T:Spring.Threading.CyclicBarrier"/>.)
            
            <code>
            public class Driver2 { // ...
            	void Main() {
            		CountDownLatch doneSignal = new CountDownLatch(N);
            		Executor e = ...
            
            		for (int i = 0; i &lt; N; ++i) // create and start threads
            				e.execute(new WorkerRunnable(doneSignal, i));
            
            		doneSignal.await();           // wait for all to finish
            	}
            }
            
            public class WorkerRunnable : IRunnable {
            	private CountDownLatch doneSignal;
            	private int i;
            	WorkerRunnable(CountDownLatch doneSignal, int i) {
            		this.doneSignal = doneSignal;
            		this.i = i;
            	}
            	public void Run() {
            		try {
            			DoWork(i);
            			doneSignal.CountDown();
            		} catch (ThreadInterruptedException ex) {} // return;
            	}
             
            	void DoWork() { ... }
            }
            
            </code>
            </example>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.CountDownLatch.#ctor(System.Int32)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.CountDownLatch"/> initialized with the given
            <paramref name="count"/>.
            </summary>
            <param name="count">the number of times <see cref="M:Spring.Threading.CountDownLatch.CountDown"/> must 
            be invoked before threads can pass through <see cref="M:Spring.Threading.CountDownLatch.Await"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="count"/> is less than 0.
            </exception>
        </member>
        <member name="M:Spring.Threading.CountDownLatch.Await">
            <summary> 
            Causes the current thread to wait until the latch has counted down 
            to zero, unless <see cref="M:System.Threading.Thread.Interrupt"/> is called on the 
            thread.
            </summary>	
            <remarks>
            <para>
            If the current <see cref="P:Spring.Threading.CountDownLatch.Count"/> is zero then this method returns 
            immediately.
            </para>
            <para>
            If the current <see cref="P:Spring.Threading.CountDownLatch.Count"/> is greater than zero then the 
            current thread becomes disabled for thread scheduling purposes and 
            lies dormant until the count reaches zero due to invocations of the
            <see cref="M:Spring.Threading.CountDownLatch.CountDown"/> method or some other thread calls 
            <see cref="M:System.Threading.Thread.Interrupt"/> on the current thread.
            </para>
            </remarks>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread has its interrupted status set on entry to
            this method or is interrupted while waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.CountDownLatch.Await(System.TimeSpan)">
            <summary> 
            Causes the current thread to wait until the latch has counted down 
            to zero, unless <see cref="M:System.Threading.Thread.Interrupt"/> is called on the 
            thread or the specified <paramref name="duration"/> elapses.
            </summary>	
            <remarks> 
            <para>
            If the current <see cref="P:Spring.Threading.CountDownLatch.Count"/>  is zero then this method
            returns immediately.
            </para>
            <para>
            If the current <see cref="P:Spring.Threading.CountDownLatch.Count"/> is greater than zero then the 
            current thread becomes disabled for thread scheduling purposes and 
            lies dormant until the count reaches zero due to invocations of the
            <see cref="M:Spring.Threading.CountDownLatch.CountDown"/> method or some other thread calls 
            <see cref="M:System.Threading.Thread.Interrupt"/> on the current thread.
            </para>
            <para>
            A <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown if the thread 
            is interrupted.
            </para>
            <para>
            If the specified <paramref name="duration"/> elapses then the value
            <c>false</c> is returned. If the time is less than or equal
            to zero, the method will not wait at all.
            </para>
            </remarks>
            <param name="duration">The maximum time to wait.</param>
            <returns>
            <c>true</c> if the count reached zero and <c>false</c>
            if the waiting time elapsed before the count reached zero.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread is interrupted.
            </exception>
        </member>
        <member name="M:Spring.Threading.CountDownLatch.CountDown">
            <summary> 
            Decrements the count of the latch, releasing all waiting threads if
            the count reaches zero.
            </summary>
            <remarks>
            <para>
            If the current <see cref="P:Spring.Threading.CountDownLatch.Count"/> is greater than zero then it is 
            decremented. If the new count is zero then all waiting threads are 
            re-enabled for thread scheduling purposes. 
            </para>
            <para>
            If the current <see cref="P:Spring.Threading.CountDownLatch.Count"/> equals zero then nothing happens.
            </para>
            </remarks>
        </member>
        <member name="M:Spring.Threading.CountDownLatch.ToString">
            <summary> 
            Returns a string identifying this latch, as well as its state.
            </summary>
            <remarks>
            The state, in brackets, includes the string &quot;Count =&quot; 
            followed by the current count.
            </remarks>
            <returns>
            A string identifying this latch, as well as its state.
            </returns>
        </member>
        <member name="P:Spring.Threading.CountDownLatch.Count">
            <summary> 
            Returns the current count.
            </summary>
            <remarks>
            This method is typically used for debugging and testing purposes.
            </remarks>
            <returns>the current count.</returns>
        </member>
        <member name="T:Spring.Threading.Execution.ILoopResult">
            <summary>
            Provides completion status on the execution of a
            <see cref="T:Spring.Threading.Execution.IExecutorService"/> loop.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopResult.IsCompleted">
            <summary>
            Gets whether the loop ran to completion, such that all iterations 
            of the loop were executed.
            </summary>
            <value>
            True if the loop ran to completion, otherwise false.
            </value>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopResult.LowestBreakIteration">
            <summary>
            Gets the index of the lowest iteration from which 
            <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> was called.
            </summary>
            <remarks>
            If Break  was not employed, this property will return null.
            </remarks>
            <value>
            An <see cref="T:System.Int32"/> that represents the lowest iteration from which
            <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> was called.
            </value>
        </member>
        <member name="T:Spring.Threading.Execution.ILoopState">
            <summary>
            Enables iterations of <see cref="T:Spring.Threading.Execution.IExecutorService"/> loops to interact 
            with other iterations. A different <see cref="T:Spring.Threading.Execution.ILoopState"/> instance 
            is provided to each thread involved in a loop.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ILoopState.Stop">
            <summary>
            Communicates that the <see cref="T:Spring.Threading.Execution.IExecutorService"/> loop should 
            cease execution at the system's earliest convenience.
            </summary>
            <remarks>
            <para>
            <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/> may be used to communicate to the loop that no 
            other iterations need be run.
            </para>
            <para>
            For long-running iterations that may already be executing, 
            <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/> causes <see cref="P:Spring.Threading.Execution.ILoopState.IsStopped"/> to return true 
            for all other iterations of the loop, such that another iteration 
            may check <see cref="P:Spring.Threading.Execution.ILoopState.IsStopped"/> and exit early if it's observed 
            to be true.
            </para>
            <para>
            <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/> is typically employed in search-based algorithms, 
            where once a result is found, no other iterations need be executed.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> method was previously called. <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> 
            and <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/> may not be used in combination by iterations 
            of the same loop.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ILoopState.Break">
            <summary>
            Communicates that the <see cref="T:Spring.Threading.Execution.IExecutorService"/> loop should 
            cease execution at the system's earliest convenience of iterations 
            beyond the current iteration. 
            </summary>
            <remarks>
            <para>
            <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> may be used to communicate to the loop that no 
            other iterations after the current iteration need be run. For 
            example, if <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> is called from the 100th iteration 
            of a for loop iterating in parallel from 0 to 1000, all iterations 
            less than 100 should still be run, but the iterations from 101 
            through to 1000 are not necessary.
            </para>
            <para>
            For long-running iterations that may already be executing,
            <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> causes <see cref="P:Spring.Threading.Execution.ILoopState.LowestBreakIteration"/> to be 
            set to the current iteration's index if the current index is less 
            than the current value of <see cref="P:Spring.Threading.Execution.ILoopState.LowestBreakIteration"/>.
            </para>
            <para>
            <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> is typically employed in search-based algorithms
             where an ordering is present in the data source.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/> method was previously called. <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> 
            and <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/> may not be used in combination by iterations 
            of the same loop.
            </exception>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopState.ShouldExitCurrentIteration">
            <summary>
            Gets whether the current iteration of the loop should exit based 
            on requests made by this or other iterations.
            </summary>
            <remarks>
            <para>
            When an iteration of a loop calls <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> or 
            <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/>, or when one throws an exception, the 
            <see cref="T:Spring.Threading.Execution.IExecutorService"/> class will proactively attempt to 
            prohibit additional iterations of the loop from starting execution.
            </para>
            <para>
            However, there may be cases where it is unable to prevent additional 
            iterations from starting.
            </para>
            <para>
            It may also be the case that a long-running iteration has already 
            begun execution. In such cases, iterations may explicitly check the 
            <see cref="P:Spring.Threading.Execution.ILoopState.ShouldExitCurrentIteration"/> property and cease 
            execution if the property returns true.
            </para>
            </remarks>
            <value>
            True if the current iteration should exit, otherwise false.
            </value>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopState.LowestBreakIteration">
            <summary>
            Gets the lowest iteration of the loop from which <see cref="M:Spring.Threading.Execution.ILoopState.Break"/>
            was called.
            </summary>
            <remarks>
            <para>
            If no iteration of the loop called <see cref="M:Spring.Threading.Execution.ILoopState.Break"/>, this 
            property will return null.
            </para>
            </remarks>
            <value>
            A <see cref="T:System.Int32"/> that represents the lowest iteration of the 
            loop from which <see cref="M:Spring.Threading.Execution.ILoopState.Break"/> was called.
            </value>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopState.IsStopped">
            <summary>
            Gets whether any iteration of the loop has called <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/>.
            </summary>
            <value>
            True if any iteration has called <see cref="M:Spring.Threading.Execution.ILoopState.Stop"/>, otherwise false.
            </value>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopState.IsExceptional">
            <summary>
            Gets whether any iteration of the loop has thrown an exception that 
            went unhandled by that iteration.
            </summary>
            <value>
            True if any iteration has thrown an exception that went unhandled, 
            otherwise false.
            </value>
        </member>
        <member name="P:Spring.Threading.Execution.ILoopState.CurrentIndex">
            <summary>
            Gets the index of current iteration of the loop.
            </summary>
            <value>
            The zero indexed position of current iteration source in the source
            enumerable.
            </value>
        </member>
        <member name="T:Spring.Threading.Execution.ParallelCompletion`1">
            <summary>
            Support for parallel functions don't use local object.
            </summary>
            <typeparam name="TSource"></typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Execution.ParallelCompletionBase`1">
            <summary>
            Implementation of core logic for parallel functions.
            </summary>
            <typeparam name="T"></typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Execution.ParallelCompletion`2">
            <summary>
            Support for parallel functions use local object.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TLocal"></typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Execution.ParallelExtension">
            <summary>
            Extension methods to provide parallel functions.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.ForEach``1(Spring.Threading.IExecutor,System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            in which iterations may run in parallel using given <paramref name="executor"/>.
            </summary>
            <remarks>
            The <paramref name="body"/> delegate is invoked once for each 
            element in the <paramref name="source"/> enumerable. It is provided
            with the current element as a parameter.
            </remarks>
            <typeparam name="TSource">
            The type of the data in the source.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="source">
            An enumerable data source.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="source"/> argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.ForEach``1(Spring.Threading.IExecutor,System.Collections.Generic.IEnumerable{``0},System.Action{``0,Spring.Threading.Execution.ILoopState})">
            <summary>
            Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            in which iterations may run in parallel using given <paramref name="executor"/>.
            </summary>
            <remarks>
            The <paramref name="body"/> delegate is invoked once for each 
            element in the <paramref name="source"/> enumerable. It is provided
            with the current element as a parameter.
            </remarks>
            <typeparam name="TSource">
            The type of the data in the source.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="source">
            An enumerable data source.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="source"/> argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.ForEach``1(Spring.Threading.IExecutor,System.Collections.Generic.IEnumerable{``0},Spring.Threading.Execution.ParallelOptions,System.Action{``0})">
            <summary>
            Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            in which iterations may run in parallel using given <paramref name="executor"/>.
            </summary>
            <remarks>
            The <paramref name="body"/> delegate is invoked once for each 
            element in the <paramref name="source"/> enumerable. It is provided
            with the following parameters: the current element, and a
            <see cref="T:Spring.Threading.Execution.ILoopState"/> instance that may be used to break out of
            the loop prematurely.
            </remarks>
            <typeparam name="TSource">
            The type of the data in the source.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="source">
            An enumerable data source.
            </param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="source"/> argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="parallelOptions"/> argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.ForEach``1(Spring.Threading.IExecutor,System.Collections.Generic.IEnumerable{``0},Spring.Threading.Execution.ParallelOptions,System.Action{``0,Spring.Threading.Execution.ILoopState})">
            <summary>
            Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            in which iterations may run in parallel using given <paramref name="executor"/>.
            </summary>
            <remarks>
            The <paramref name="body"/> delegate is invoked once for each 
            element in the <paramref name="source"/> enumerable. It is provided
            with the current element as a parameter.
            </remarks>
            <typeparam name="TSource">
            The type of the data in the source.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="source">
            An enumerable data source.
            </param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="source"/> argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="parallelOptions"/> argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.ForEach``2(Spring.Threading.IExecutor,System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,Spring.Threading.Execution.ILoopState,``1,``1},System.Action{``1})">
            <summary>
            Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            in which iterations may run in parallel using given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each 
            element in the <paramref name="source"/> enumerable. It is provided
            with the following parameters: the current element, a 
            <see cref="T:Spring.Threading.Execution.ILoopState"/> instance that may be used to break out of 
            the loop prematurely, and some local state that may be shared 
            amongst iterations that execute on the same thread.
            </para>
            <para>
            The <paramref name="localInit"/> delegate is invoked once for each 
            thread that participates in the loop's execution and returns the 
            initial local state for each of those threads. These initial states 
            are passed to the first body invocations on each thread. Then, 
            every subsequent body invocation returns a possibly modified state 
            value that is passed to the next body invocation. Finally, the last 
            body invocation on each thread returns a state value that is passed 
            to the <paramref name="localFinally"/> delegate. 
            The <paramref name="localFinally"/> delegate is invoked once per 
            thread to perform a final action on each thread's local state.
            </para>
            </remarks>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <typeparam name="TLocal">The type of the thread-local data.</typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="source">
            An enumerable data source.
            </param>
            <param name="localInit">
            The function delegate that returns the initial state of the local 
            data for each thread.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <param name="localFinally">
            The delegate that performs a final action on the local state of 
            each thread.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="source"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="localInit"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="localFinally"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.ForEach``2(Spring.Threading.IExecutor,System.Collections.Generic.IEnumerable{``0},Spring.Threading.Execution.ParallelOptions,System.Func{``1},System.Func{``0,Spring.Threading.Execution.ILoopState,``1,``1},System.Action{``1})">
            <summary>
            Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            in which iterations may run in parallel using given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each 
            element in the <paramref name="source"/> enumerable. It is provided
            with the following parameters: the current element, a 
            <see cref="T:Spring.Threading.Execution.ILoopState"/> instance that may be used to break out of 
            the loop prematurely, and some local state that may be shared 
            amongst iterations that execute on the same thread.
            </para>
            <para>
            The <paramref name="localInit"/> delegate is invoked once for each 
            thread that participates in the loop's execution and returns the 
            initial local state for each of those threads. These initial states 
            are passed to the first body invocations on each thread. Then, 
            every subsequent body invocation returns a possibly modified state 
            value that is passed to the next body invocation. Finally, the last 
            body invocation on each thread returns a state value that is passed 
            to the <paramref name="localFinally"/> delegate. 
            The <paramref name="localFinally"/> delegate is invoked once per 
            thread to perform a final action on each thread's local state.
            </para>
            </remarks>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <typeparam name="TLocal">The type of the thread-local data.</typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="source">
            An enumerable data source.
            </param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="localInit">
            The function delegate that returns the initial state of the local 
            data for each thread.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <param name="localFinally">
            The delegate that performs a final action on the local state of 
            each thread.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="source"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="localInit"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="localFinally"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the iteration 
            count (an Int32).
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int32,System.Int32,System.Action{System.Int32,Spring.Threading.Execution.ILoopState})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int32), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely.
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int64,System.Int64,System.Action{System.Int64})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the iteration 
            count (an Int64).
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int64,System.Int64,System.Action{System.Int64,Spring.Threading.Execution.ILoopState})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int64), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely.
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int32,System.Int32,Spring.Threading.Execution.ParallelOptions,System.Action{System.Int32})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the iteration 
            count (an Int32).
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int32,System.Int32,Spring.Threading.Execution.ParallelOptions,System.Action{System.Int32,Spring.Threading.Execution.ILoopState})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int32), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely.
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int64,System.Int64,Spring.Threading.Execution.ParallelOptions,System.Action{System.Int64})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the iteration 
            count (an Int64).
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For(Spring.Threading.IExecutor,System.Int64,System.Int64,Spring.Threading.Execution.ParallelOptions,System.Action{System.Int64,Spring.Threading.Execution.ILoopState})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int64), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely.
            </para>
            </remarks>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For``1(Spring.Threading.IExecutor,System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,Spring.Threading.Execution.ILoopState,``0,``0},System.Action{``0})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int32), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely, and 
            some local state that may be shared amongst iterations that execute 
            on the same thread.
            </para>
            <para>
            The <paramref name="localInit"/> delegate is invoked once for each 
            thread that participates in the loop's execution and returns the 
            initial local state for each of those threads. These initial states 
            are passed to the first body invocations on each thread. Then, 
            every subsequent <paramref name="body"/> invocation returns a 
            possibly modified state value that is passed to the next body 
            invocation. Finally, the last body invocation on each thread 
            returns a state value that is passed to the <paramref name="localFinally"/>
            delegate. The <paramref name="localFinally"/> delegate is invoked 
            once per thread to perform a final action on each thread's local 
            state.
            </para>
            </remarks>
            <typeparam name="TLocal">
            The type of the thread-local data.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="localInit">
            The function delegate that returns the initial state of the local 
            data for each thread.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <param name="localFinally">
            The delegate that performs a final action on the local state of 
            each thread.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="localInit"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="localFinally"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For``1(Spring.Threading.IExecutor,System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,Spring.Threading.Execution.ILoopState,``0,``0},System.Action{``0})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int64), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely, and 
            some local state that may be shared amongst iterations that execute 
            on the same thread.
            </para>
            <para>
            The <paramref name="localInit"/> delegate is invoked once for each 
            thread that participates in the loop's execution and returns the 
            initial local state for each of those threads. These initial states 
            are passed to the first body invocations on each thread. Then, 
            every subsequent <paramref name="body"/> invocation returns a 
            possibly modified state value that is passed to the next body 
            invocation. Finally, the last body invocation on each thread 
            returns a state value that is passed to the <paramref name="localFinally"/>
            delegate. The <paramref name="localFinally"/> delegate is invoked 
            once per thread to perform a final action on each thread's local 
            state.
            </para>
            </remarks>
            <typeparam name="TLocal">
            The type of the thread-local data.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="localInit">
            The function delegate that returns the initial state of the local 
            data for each thread.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <param name="localFinally">
            The delegate that performs a final action on the local state of 
            each thread.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="localInit"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="localFinally"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For``1(Spring.Threading.IExecutor,System.Int32,System.Int32,Spring.Threading.Execution.ParallelOptions,System.Func{``0},System.Func{System.Int32,Spring.Threading.Execution.ILoopState,``0,``0},System.Action{``0})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int32), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely, and 
            some local state that may be shared amongst iterations that execute 
            on the same thread.
            </para>
            <para>
            The <paramref name="localInit"/> delegate is invoked once for each 
            thread that participates in the loop's execution and returns the 
            initial local state for each of those threads. These initial states 
            are passed to the first body invocations on each thread. Then, 
            every subsequent <paramref name="body"/> invocation returns a 
            possibly modified state value that is passed to the next body 
            invocation. Finally, the last body invocation on each thread 
            returns a state value that is passed to the <paramref name="localFinally"/>
            delegate. The <paramref name="localFinally"/> delegate is invoked 
            once per thread to perform a final action on each thread's local 
            state.
            </para>
            </remarks>
            <typeparam name="TLocal">
            The type of the thread-local data.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="localInit">
            The function delegate that returns the initial state of the local 
            data for each thread.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <param name="localFinally">
            The delegate that performs a final action on the local state of 
            each thread.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="localInit"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="localFinally"/> 
            argument is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ParallelExtension.For``1(Spring.Threading.IExecutor,System.Int64,System.Int64,Spring.Threading.Execution.ParallelOptions,System.Func{``0},System.Func{System.Int64,Spring.Threading.Execution.ILoopState,``0,``0},System.Action{``0})">
            <summary>
            Executes a for loop in which iterations may run in parallel using 
            given <paramref name="executor"/>.
            </summary>
            <remarks>
            <para>
            The <paramref name="body"/> delegate is invoked once for each value 
            in the iteration range: [<paramref name="fromInclusive"/>, 
            <paramref name="toExclusive"/>). It is provided with the following 
            parameters: the iteration count (an Int64), a <see cref="T:Spring.Threading.Execution.ILoopState"/>
            instance that may be used to break out of the loop prematurely, and 
            some local state that may be shared amongst iterations that execute 
            on the same thread.
            </para>
            <para>
            The <paramref name="localInit"/> delegate is invoked once for each 
            thread that participates in the loop's execution and returns the 
            initial local state for each of those threads. These initial states 
            are passed to the first body invocations on each thread. Then, 
            every subsequent <paramref name="body"/> invocation returns a 
            possibly modified state value that is passed to the next body 
            invocation. Finally, the last body invocation on each thread 
            returns a state value that is passed to the <paramref name="localFinally"/>
            delegate. The <paramref name="localFinally"/> delegate is invoked 
            once per thread to perform a final action on each thread's local 
            state.
            </para>
            </remarks>
            <typeparam name="TLocal">
            The type of the thread-local data.
            </typeparam>
            <param name="executor">
            An <see cref="T:Spring.Threading.IExecutor"/> to run the parallel tasks.
            </param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">
            A <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance that configures the 
            behavior of this operation.
            </param>
            <param name="localInit">
            The function delegate that returns the initial state of the local 
            data for each thread.
            </param>
            <param name="body">
            The delegate that is invoked once per iteration.
            </param>
            <param name="localFinally">
            The delegate that performs a final action on the local state of 
            each thread.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Execution.ILoopResult"/> instance that contains information 
            on what portion of the loop completed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The exception that is thrown when the <paramref name="parallelOptions"/> 
            argument is null.<br/>
            -or-<br/>
            The exception that is thrown when the <paramref name="localInit"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="body"/> 
            argument is null.
            -or-<br/>
            The exception that is thrown when the <paramref name="localFinally"/> 
            argument is null.
            </exception>
        </member>
        <member name="T:Spring.Threading.Execution.ParallelOptions">
            <summary>
            Stores options that configure the parallel operation of methods on the 
            <see cref="T:Spring.Threading.Execution.IExecutorService"/> class.
            </summary>
        </member>
        <member name="P:Spring.Threading.Execution.ParallelOptions.MaxDegreeOfParallelism">
            <summary>
            Gets or sets the maximum degree of parallelism enabled by this 
            <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance.
            </summary>
            <remarks>
            The <see cref="P:Spring.Threading.Execution.ParallelOptions.MaxDegreeOfParallelism"/> limits the number of 
            concurrent operations run by parallal method calls 
            that are passed this <see cref="T:Spring.Threading.Execution.ParallelOptions"/> instance to 
            the set value, if it is positive. If <see cref="P:Spring.Threading.Execution.ParallelOptions.MaxDegreeOfParallelism"/>
            is -1, then there is no limit placed on the number of concurrently 
            running operations.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when this <see cref="P:Spring.Threading.Execution.ParallelOptions.MaxDegreeOfParallelism"/> 
            is set to 0 or some value less than -1.
            </exception>
        </member>
        <member name="T:Spring.Threading.Callable`1">
            <summary>
            A class converts <see cref="T:System.Func`1"/> delegate to 
            <see cref="T:Spring.Threading.ICallable`1"/>.
            </summary>
            <typeparam name="T">Data type of the result to be returned.</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.ICallable`1">
            <summary> 
            A task that returns a result and may throw an exception.
            </summary>
            <remarks>
            <para>
            Implementors define a single method with no arguments called
            <see cref="M:Spring.Threading.ICallable`1.Call"/>.
            </para>
            <para>
            The <c>ICallable</c> interface is similar to <see cref="T:Spring.Threading.IRunnable"/>, 
            in that both are designed for classes whose
            instances are potentially executed by another thread.  A
            <c>IRunnable</c>, however, does not return a result.
            </para>
            <para>
            The <see cref="T:Spring.Threading.Execution.Executors"/> class contains utility methods to
            convert from other common forms to <c>ICallable</c> classes.
            </para>
            </remarks>
            <typeparam name="T">
            The result type of method <see cref="M:Spring.Threading.ICallable`1.Call"/>.
            </typeparam>
            <seealso cref="T:System.Func`1"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.ICallable`1.Call">
             <summary>
             Computes a result, or throws an exception if unable to do so.
             </summary>
            <returns>Computed result.</returns>
        </member>
        <member name="M:Spring.Threading.Callable`1.#ctor(System.Func{`0})">
            <summary>
            Construct a new instance of <see cref="T:Spring.Threading.Callable`1"/> which calls
            <paramref name="call"/> delegate with its <see cref="M:Spring.Threading.Callable`1.Call"/> method
            is invoked.
            </summary>
            <param name="call">
            The delegate to be called when <see cref="M:Spring.Threading.Callable`1.Call"/> is invoked.
            </param>
        </member>
        <member name="M:Spring.Threading.Callable`1.Call">
             <summary>
             Perform some action that returns a result or throws an exception.
             </summary>
            <returns>The result of the action.</returns>
        </member>
        <member name="M:Spring.Threading.Callable`1.op_Implicit(System.Func{`0})~Spring.Threading.Callable{`0}">
            <summary>
            Implicitly converts <see cref="T:System.Func`1"/> delegate to an instance
            of <see cref="T:Spring.Threading.Callable`1"/>.
            </summary>
            <param name="call">
            The delegate to be converted to <see cref="T:Spring.Threading.Callable`1"/>.
            </param>
            <returns>
            An instance of <see cref="T:Spring.Threading.Callable`1"/> based on <paramref name="call"/>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Callable`1.op_Implicit(Spring.Threading.Callable{`0})~System.Func{`0}">
            <summary>
            Implicitly converts <see cref="T:Spring.Threading.Callable`1"/> to <see cref="T:System.Func`1"/>
            delegate.
            </summary>
            <param name="callable">
            The callable to be converted to <see cref="T:System.Func`1"/>.
            </param>
            <returns>
            The original <see cref="T:System.Func`1"/> delegate used to construct the
            <paramref name="callable"/>.
            </returns>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1">
            <summary> 
            A bounded <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> backed by an array.  This queue 
            orders elements FIFO (first-in-first-out).  The <i>head</i> of the queue 
            is that element that has been on the queue the longest time.  The 
            <i>tail</i> of the queue is that element that has been on the queue the 
            shortest time. New elements are inserted at the tail of the queue, and 
            the queue retrieval operations obtain elements at the head of the queue.
            <p/>
            This is a classic "bounded buffer", in which a fixed-sized 
            array holds elements inserted by producers and extracted by consumers.  
            Once created, the capacity cannot be increased.  Attempts to 
            <see cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Put(`0)"/> an element into a full queue will 
            result in the operation blocking; attempts to <see cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.Take"/>
            an element from an empty queue will similarly block.
            
            <p/> 
            This class supports an optional fairness policy for ordering waiting 
            producer and consumer threads.  By default, this ordering is not 
            guaranteed. However, a queue constructed with fairness set to 
            <see langword="true"/> grants threads access in FIFO order. Fairness
            generally decreases throughput but reduces variability and avoids
            starvation.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1">
            <summary> 
            An implementation of <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> by wrapping a
            regular queue.
            </summary>
            <remarks>
            This class supports an optional fairness policy for ordering waiting 
            producer and consumer threads.  By default, this ordering is not 
            guaranteed. However, a queue constructed with fairness set to 
            <see langword="true"/> grants threads access in FIFO order. Fairness
            generally decreases throughput but reduces variability and avoids
            starvation.
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1._lock">
            <summary>Main lock guarding all access </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1._notEmptyCondition">
            <summary>Condition for waiting takes </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1._notFullCondition">
            <summary>Condition for waiting puts </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1._wrapped">
            <summary>
            The wrapped regular queue.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.#ctor(Spring.Collections.Generic.IQueue{`0},System.Int32,System.Boolean)">
            <summary>
            Construct a blocking queue that based on the given regular 
            <paramref name="queue"/>.
            </summary>
            <param name="queue">
            A regular queue to be wrapped as blocking queue.
            </param>
            <param name="capacity">
            The capacity of the queue. zero (<c>0</c>) to indicate an
            unbounded queue.
            </param>
            <param name="isFair">
            <c>true</c> to grant access to longest waiting threads, otherwise 
            it does not guarantee any particular access order.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="queue"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is negative.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.#ctor(Spring.Collections.Generic.IQueue{`0},System.Int32)">
            <summary>
            Construct a blocking queue that based on the given regular 
            <paramref name="queue"/>. There is no guarantee to the order of
            the blocked threads being given access.
            </summary>
            <param name="queue">
            A regular queue to be wrapped as blocking queue.
            </param>
            <param name="capacity">
            The capacity of the queue. zero (<c>0</c>) to indicate an
            unbounded queue.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="queue"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is negative.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.#ctor(Spring.Collections.Generic.IQueue{`0},System.Boolean)">
            <summary>
            Construct a blocking queue that based on the given regular 
            unbounded <paramref name="queue"/>.
            </summary>
            <param name="queue">
            A regular queue to be wrapped as blocking queue.
            </param>
            <param name="isFair">
            <c>true</c> to grant access to longest waiting threads, otherwise 
            it does not guarantee any particular access order.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="queue"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.#ctor(Spring.Collections.Generic.IQueue{`0})">
            <summary>
            Construct a blocking queue that based on the given regular 
            unbounded <paramref name="queue"/>. There is no guarantee to the 
            order of the blocked threads being given access.
            </summary>
            <param name="queue">
            A regular queue to be wrapped as blocking queue.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="queue"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Clear">
            <summary> 
            Atomically removes all of the elements from this queue.
            The queue will be empty after this call returns.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current 
            <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <remarks>
            This implmentation list out all the elements separated by comma.
            </remarks>
            <returns>
            A <see cref="T:System.String"/> that represents the current collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Contains(`0)">
            <summary> 
            Returns <see langword="true"/> if this queue contains the specified 
            element.
            </summary>
            <remarks>
            More formally, returns <see langword="true"/> if and only if this 
            queue contains at least one element <i>element</i> such that 
            <i>elementToSearchFor.equals(element)</i>.
            </remarks>
            <param name="elementToSearchFor">
            Object to be checked for containment in this queue.
            </param>
            <returns>
            <see langword="true"/>
            If this queue contains the specified element.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Remove(`0)">
            <summary> 
            Removes a single instance of the specified element from this queue,
            if it is present.  More formally, removes an <i>element</i> such
            that <i>elementToRemove.Equals(element)</i>, if this queue contains 
            one or more such elements.
            </summary>
            <param name="elementToRemove">
            element to be removed from this queue, if present.
            </param>
            <returns> <see langword="true"/> if this queue contained the 
            specified element or if this queue changed as a result of the call, 
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.CopyTo(System.Array,System.Int32)">
             <summary>
             Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an 
             <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> 
             index.
             </summary>
            
             <param name="array">
             The one-dimensional <see cref="T:System.Array"/> that is the destination 
             of the elements copied from <see cref="T:System.Collections.ICollection"/>. The 
             <see cref="T:System.Array"/> must have zero-based indexing. 
             </param>
             <param name="index">
             The zero-based index in array at which copying begins. 
             </param>
             <exception cref="T:System.ArgumentNullException">array is null. </exception>
             <exception cref="T:System.ArgumentOutOfRangeException">
             index is less than zero. 
             </exception>
             <exception cref="T:System.ArgumentException">
             array is multidimensional.-or- index is equal to or greater than 
             the length of array.
             -or- 
             The number of elements in the source <see cref="T:System.Collections.ICollection"/> 
             is greater than the available space from index to the end of the 
             destination array. 
             </exception>
             <exception cref="T:System.InvalidCastException">
             The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast 
             automatically to the type of the destination array. 
             </exception>
             <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does the actual work of copying to array. Calls the base method in
            synchronized context.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <param name="ensureCapacity">
            If is <c>true</c>, calls <see cref="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)"/>
            </param>
            <returns>
            A new array of same runtime type as <paramref name="array"/> if 
            <paramref name="array"/> is too small to hold all elements and 
            <paramref name="ensureCapacity"/> is <c>false</c>. Otherwise
            the <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Offer(`0)">
            <summary>
            Inserts the specified element into this queue if it is possible to 
            do so immediately without violating capacity restrictions. 
            </summary>
            <remarks>
            When using a capacity-restricted queue, this method is generally 
            preferable to <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Add(`0)"/>, which can fail to 
            insert an element only by throwing an exception. 
            </remarks>
            <param name="element">The element to add.</param>
            <returns>
            <c>true</c> if the element was added to this queue. Otherwise 
            <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="element"/> is <c>null</c> and the queue 
            implementation doesn't allow <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> 
            prevents it from being added to this queue. 
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Poll(`0@)">
            <summary>
            Retrieves and removes the head of this queue into out parameter
            <paramref name="element"/>. 
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> if the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Put(`0)">
            <summary> 
            Inserts the specified element into this queue, waiting if necessary
            for space to become available.
            </summary>
            <param name="element">the element to add</param>
            <exception cref="T:System.ArgumentNullException">
            If the specified element is <see langword="null"/> and this queue 
            does not permit <see langword="null"/> elements.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Offer(`0,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </summary>
            <param name="element">The element to add.</param>
            <param name="duration">How long to wait before giving up.</param>
            <returns>
            <see langword="true"/> if successful, or <see langword="false"/> if
            the specified waiting time elapses before space is available.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the specified element is <see langword="null"/> and this queue 
            does not permit <see langword="null"/> elements.
            </exception>
            <exception cref="T:System.ArgumentException">
            If some property of the supplied <paramref name="element"/> prevents
            it from being added to this queue.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element becomes available.
            </summary>
            <returns> the head of this queue</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Poll(System.TimeSpan,`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <param name="duration">How long to wait before giving up.</param>
            <returns> 
            <c>false</c> if the queue is still empty after waited for the time 
            specified by the <paramref name="duration"/>. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Peek(`0@)">
            <summary>
            Retrieves, but does not remove, the head of this queue into out
            parameter <paramref name="element"/>.
            </summary>
            <param name="element">
            The head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> is the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate 
            through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Capacity">
            <summary>
            Returns the current capacity of this queue.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.IsFair">
            <summary>
            Determine if the current instance is fair to blocking threads.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.RemainingCapacity">
            <summary> 
            Returns the number of additional elements that this queue can ideally
            (in the absence of memory or resource constraints) accept without
            blocking, or <see cref="F:System.Int32.MaxValue"/> if there is no intrinsic
            limit.
            </summary>
            <remarks>
            <b>Important</b>: You <b>cannot</b> always tell if an attempt to insert
            an element will succeed by inspecting <see cref="P:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.RemainingCapacity"/>
            because it may be the case that another thread is about to
            insert or remove an element.
            </remarks>
            <returns>The remaining capacity.</returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.Count">
            <summary> 
            Returns the number of elements in this queue.
            </summary>
            <returns>The number of elements in this queue.</returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.BlockingQueueWrapper`1.IsSynchronized">
            <summary>
            Always return true as blocking queue is always synchronized 
            (thread-safe).
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1.#ctor(System.Int32,System.Boolean)">
            <summary> 
            Creates an <see cref="T:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1"/> with the given (fixed)
            <paramref name="capacity"/> and the specified <paramref name="isFair"/> 
            fairness access policy.
            </summary>
            <param name="capacity">The capacity of this queue.</param>
            <param name="isFair">
            If <see langword="true"/> then queue accesses for threads blocked
            on insertion or removal, are processed in FIFO order; if 
            <see langword="false"/> the access order is unspecified.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1.#ctor(System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Creates an <see cref="T:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1"/> with the given (fixed)
            <paramref name="capacity"/> and the specified <paramref name="isFair"/> 
            fairness access policy and initially containing the  elements of the 
            given collection, added in traversal order of the collection's iterator.
            </summary>
            <param name="capacity">The capacity of this queue.</param>
            <param name="isFair">
            If <see langword="true"/> then queue accesses for threads blocked
            on insertion or removal, are processed in FIFO order; if 
            <see langword="false"/> the access order is unspecified.
            </param>
            <param name="collection">
            The collection of elements to initially contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is less than 1.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="collection"/> is <see langword="null"/>.
            </exception> 
        </member>
        <member name="M:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1.#ctor(System.Int32)">
            <summary> 
            Creates an <see cref="T:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1"/> with the given (fixed)
            <paramref name="capacity"/> and default fairness access policy.
            </summary>
            <param name="capacity">The capacity of this queue.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="capacity"/> is less than 1.
            </exception>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1">
            <summary> 
            A thread-safe variant of <see cref="T:System.Collections.ArrayList"/> in which all mutative
            operations are implemented by making a fresh copy of the underlying array.
            </summary>
            <remarks>
            <p/> 
            This is ordinarily too costly, but may be <b>more</b> efficient
            than alternatives when traversal operations vastly outnumber
            mutations, and is useful when you cannot or don't want to
            synchronize traversals, yet need to preclude interference among
            concurrent threads.  The "snapshot" style iterator method uses a
            reference to the state of the array at the point that the iterator
            was created. This array never changes during the lifetime of the
            iterator, so interference is impossible.
            <p/>
            The iterator will not reflect additions, removals, or changes to
            the list since the iterator was created. 
            <p/>
            All elements are permitted, including null.
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1._array">
            <summary>
            The array, accessed only via <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Array"/>. 
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.#ctor">
            <summary>
            Default Constructor.  Creates an empty list.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary> 
            Creates a list containing the elements of the specified
            <pararef name="collection"/>, in the order they are returned by the collection's
            iterator.
            </summary>
            <param name="collection">the collection of initially held elements
            </param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="collection"/> is <c>null</c></exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.#ctor(`0[])">
            <summary> 
            Creates a list holding a copy of the <pararef name="inputArray"/>.
            </summary>
            <param name="inputArray">
            the array (a copy of this array is used as the
            internal array)
            </param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="inputArray"/> is null.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.copyToInternalArray(`0[],System.Int32,System.Int32)">
            <summary> 
            Replaces the internal array with a copy the <pararef name="numberOfElementsToCopy"/> elements
            of the <pararef name="inputArray"/>. 
            </summary>
            <param name="inputArray">The array to copy from.</param>
            <param name="startIndex">The index to start copying from.</param>
            <param name="numberOfElementsToCopy">the number of elements to copy. This will be the new size of the list.</param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.eq(System.Object,System.Object)">
            <summary>
            Test for equality, coping with nulls.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.indexOf(`0,`0[],System.Int32,System.Int32)">
            <summary>
            static version of indexOf, to allow repeated calls without
            needing to re-acquire array each time.
            </summary>
            <param name="element">element to search for</param>
            <param name="arrayToSearch">the array</param>
            <param name="startingIndex">first startingIndex to search</param>
            <param name="fence">one past last startingIndex to search</param>
            <returns> startingIndex of element, or -1 if absent</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.lastIndexOf(`0,`0[],System.Int32)">
            <summary> static version of lastIndexOf.</summary>
            <param name="element">element to search for
            </param>
            <param name="elements">the array
            </param>
            <param name="startingIndex">index to start searching at
            </param>
            <returns> index of element, or -1 if absent
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Contains(`0)">
            <summary> 
            Returns <c>true</c> if this list contains the specified element.
            </summary>
            <param name="element">element to look for.
            </param>
            <returns> <c>true</c> if this list contains the specified element
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.IndexOf(`0)">
            <summary>
            Returns the index of the <paramref name="element"/> in the array.
            </summary>
            <param name="element">element to look for.</param>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.IndexOf(`0,System.Int32)">
            <summary> 
            Returns the index of the first occurrence of the specified element in
            this list, searching forwards from index, or returns -1 if
            the element is not found.
            </summary>
            <param name="e">element to search for.</param>
            <param name="index">index to start searching from.</param>
            <returns> the index of the first occurrence of the element in
            this list at position index or later in the list;
            -1 if the element is not found.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">if the specified index is negative or greater than the length of the array.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last occurrence of the specified element in this list.
            </summary>
            <param name="element">specified element</param>
            <returns>index of <pararef name="element"/></returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.LastIndexOf(`0,System.Int32)">
            <summary> 
            Returns the index of the last occurrence of the specified element in
            this list, searching backwards from index, or returns -1 if
            the element is not found.
            </summary>
            <param name="element">element to search for</param>
            <param name="startingIndex">index to start searching backwards from</param>
            <returns> the index of the last occurrence of the element at position
            less than or equal to index in this list;
            -1 if the element is not found.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">if the specified index is greater than or equal to the current size of the list.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Clone">
            <summary> 
            Returns a shallow copy of this list.  (The elements themselves
            are not copied.)
            </summary>
            <returns> a clone of this list
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.ToArray">
            <summary> 
            Returns an array containing all of the elements in this list
            in proper sequence (from first to last element).
            </summary>
            <remarks>
            The returned array will be "safe" in that no references to it are
            maintained by this list.  (In other words, this method must allocate
            a new array).  The caller is thus free to modify the returned array.
            </remarks>
            <returns> an array containing all the elements in this list
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.ToArray(`0[])">
            <summary> 
            Returns an array containing all of the elements in this list in
            proper sequence (from first to last element); the runtime type of
            the returned array is that of the specified array.  If the list fits
            in the specified array, it is returned therein.  Otherwise, a new
            array is allocated with the runtime type of the specified array and
            the size of this list.
            </summary>
            <remarks> 
            If this list fits in the specified array with room to spare
            (i.e., the array has more elements than this list), the element in
            the array immediately following the end of the list is set to
            null.  (This is useful in determining the length of this
            list <i>only</i> if the caller knows that this list does not contain
            any null elements.)
            
            <p/>Like the <see cref="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.ToArray"/> method, this method acts as bridge between
            array-based and collection-based APIs.  Further, this method allows
            precise control over the runtime type of the output array, and may,
            under certain circumstances, be used to save allocation costs.
            </remarks>
            <param name="destinationArray">the array into which the elements of the list are to
            be stored, if it is big enough; otherwise, a new array of the
            same runtime type is allocated for this purpose.
            </param>
            <returns> an array containing all the elements in this list</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Add(`0)">
            <summary> 
            Appends the specified element to the end of this list.
            </summary>
            <param name="item">element to be appended to this list</param>
            <returns>Index of the inserted element in the array.</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Insert(System.Int32,`0)">
            <summary> 
            Inserts the specified element at the specified position in this
            list. Shifts the element currently at that position (if any) and
            any subsequent elements to the right (adds one to their indices).
            </summary>
            <param name="element">element to insert</param>
            <param name="index">position to insert <pararef name="element"/> into.</param>
            <exception cref="T:System.IndexOutOfRangeException">if the <paramref name="index"/> is negative or bigger than the current size of the array.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.RemoveAt(System.Int32)">
            <summary> 
            Removes the element at the specified position in this list.
            Shifts any subsequent elements to the left (subtracts one from their
            indices).  Returns the element that was removed from the list.
            </summary>
            <param name="index">Index to remove the element at.</param>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is negative or outside the bounds of the list.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Remove(`0)">
            <summary> 
            Removes the first occurrence of the specified element from this list,
            if it is present.  If this list does not contain the element, it is
            unchanged.
            </summary>
            <param name="element">element to be removed from this list, if present
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.AddIfAbsent(`0)">
            <summary>
            Append the element if not present.
            </summary>
            <param name="element">element to be added to this list, if absent
            </param>
            <returns> true if the element was added
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary> 
            Returns true if this list contains all of the elements of the
            specified collection.
            </summary>
            <param name="collection">collection to be checked for containment in this list
            </param>
            <returns> true if this list contains all of the elements of the
            specified collection
            </returns>
            <exception cref="T:System.ArgumentNullException">If <pararef name="collection"/> is null.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary> 
            Removes from this list all of its elements that are contained in
            the specified collection. This is a particularly expensive operation
            in this class because of the need for an internal temporary array.
            </summary>
            <param name="collection">collection containing elements to be removed from this list
            </param>
            <returns> true if this list changed as a result of the call
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary> Retains only the elements in this list that are contained in the
            specified collection.  In other words, removes from this list all of
            its elements that are not contained in the specified collection.
            
            </summary>
            <param name="collection">collection containing elements to be retained in this list
            </param>
            <returns> true if this list changed as a result of the call
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.AddAllAbsent(System.Collections.Generic.ICollection{`0})">
            <summary> Appends all of the elements in the specified collection that
            are not already contained in this list, to the end of
            this list, in the order that they are returned by the
            specified collection's iterator.
            
            </summary>
            <param name="collection">collection containing elements to be added to this list
            </param>
            <returns> the number of elements added
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Clear">
            <summary> Removes all of the elements from this list.
            The list will be empty after this call returns.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary> 
            Appends all of the elements in the specified collection to the end
            of this list, in the order that they are returned by the specified
            collection's iterator.
            </summary>
            <param name="collection">collection containing elements to be added to this list
            </param>
            <returns> true if this list changed as a result of the call
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.AddAll(System.Int32,System.Collections.Generic.ICollection{`0})">
            <summary> 
            Inserts all of the elements in the specified collection into this
            list, starting at the specified position.  Shifts the element
            currently at that position (if any) and any subsequent elements to
            the right (increases their indices).  The new elements will appear
            in this list in the order that they are returned by the
            specified collection's iterator.
            
            </summary>
            <param name="index">index at which to insert the first element
            from the specified collection
            </param>
            <param name="collection">collection containing elements to be added to this list
            </param>
            <returns> true if this list changed as a result of the call
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> 
            Save the state of the list to a stream (i.e., serialize it).
            </summary>
            <serialData> The length of the array backing the list is emitted
            (int), followed by all of its elements (each an object)
            in the proper order.
            </serialData>
            <param name="s">the stream</param>
            <param name="context">the context</param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Reconstitute the list from a stream (i.e., deserialize it).</summary>
            <param name="s">the stream</param>
            <param name="context">the context</param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.ToString">
            <summary> Returns a string representation of this list, containing
            the String representation of each element.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Equals(System.Object)">
            <summary> 
            Compares the specified object with this list for equality.
            Returns true if and only if the specified object is also a {@link
            List}, both lists have the same size, and all corresponding pairs
            of elements in the two lists are <i>equal</i>.  (Two elements
            e1 and e2 are <i>equal</i> if (e1==null ?
            e2==null : e1.equals(e2)).)  In other words, two lists are
            defined to be equal if they contain the same elements in the same
            order.
            
            </summary>
            <param name="o">the object to be compared for equality with this list
            </param>
            <returns> true if the specified object is equal to this list
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.GetHashCode">
            <summary> 
            Returns the hash code value for this list.
            </summary>
            <returns> the hash code value for this list
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.GetEnumerator">
            <summary> 
            Returns an iterator over the elements in this list in proper sequence.
            </summary>
            <returns> an iterator over the elements in this list in proper sequence
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the 
            <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/> , 
            starting at a particular <paramref name="index"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Count">
            <summary> 
            Returns the number of elements in this list.
            </summary>
            <returns> 
            the number of elements in this list
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Item(System.Int32)">
            <summary>
            Indexer for the underlying <see cref="T:System.Array"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1"/> is read-only.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1"/> has a fixed size.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.IsEmpty">
            <summary> 
            Returns <c>true</c> if this list contains no elements.
            </summary>
            <returns> <c>true</c> if this list contains no elements
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.SyncRoot">
            <summary>
            Gets and object that can be used to synchronize access to the <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1"/> .
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the 
            <see cref="T:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1"/> is synchronized (thread-safe).
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.InternalEnumerator">
            <summary>
            internal wrapper for <see cref="P:Spring.Threading.Collections.Generic.CopyOnWriteArrayList`1.Array"/> to implement <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.DelayQueue`1">
            <summary>
            An unbounded <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> of <see cref="T:Spring.Threading.Future.IDelayed"/>
            elements, in which an element can only be taken when its delay has expired.
            </summary>
            <remarks>
            <para>
            The <b>head</b> of the queue is that <see cref="T:Spring.Threading.Future.IDelayed"/> element whose
            delay expired furthest in the past.  If no delay has expired there is no
            head and <see cref="M:Spring.Threading.Collections.Generic.DelayQueue`1.Poll(`0@)"/> will return <c>false</c>. Expiration
            occurs when an element's <see cref="M:Spring.Threading.Future.IDelayed.GetRemainingDelay"/> method
            returns a value less then or equals to zero.  Even though unexpired elements
            cannot be removed using <see cref="M:Spring.Threading.Collections.Generic.DelayQueue`1.Take"/> or <see cref="M:Spring.Threading.Collections.Generic.DelayQueue`1.Poll(`0@)"/>,
            they are otherwise treated as normal elements. For example, the 
            <see cref="P:Spring.Threading.Collections.Generic.DelayQueue`1.Count"/> property returns the count of both expired and unexpired
            elements. This queue does not permit <c>null</c> elements.
            </para>
            <para>
            This class implement all of the <i>optional</i> methods of the 
            <see cref="T:System.Collections.Generic.ICollection`1"/> interfaces.
            </para>
            </remarks>
            <typeparam name="T">
            The type of elements that implements <see cref="T:Spring.Threading.Future.IDelayed"/>.
            </typeparam>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.#ctor">
            <summary>
            Creates a new, empty <see cref="T:Spring.Threading.Collections.Generic.DelayQueue`1"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.DelayQueue`1"/> initially containing the
            elements of the given collection of <see cref="T:Spring.Threading.Future.IDelayed"/>
            instances specified by parameter <paramref name="source"/>.
            </summary>
            <param name="source">
            Collection of elements to populate queue with.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If the collection is <c>null</c>.
            </exception>
            <exception cref="T:System.NullReferenceException">
            If any of the elements of the collection are <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Offer(`0)">
            <summary>
            Inserts the specified element into this delay queue.
            </summary>
            <param name="element">The element to add.</param>
            <returns>Always <c>true</c></returns>
            <exception cref="T:System.NullReferenceException">
            If the specified element is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Put(`0)">
            <summary>
            Inserts the specified element into this delay queue. As the queue is
            unbounded this method will never block.
            </summary>
            <param name="element">Element to add.</param>
            <exception cref="T:System.NullReferenceException">
            If the element is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Offer(`0,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this delay queue. As the queue
            is unbounded this method will never block.
            </summary>
            <param name="element">The element to add.</param>
            <param name="duration">
            This parameter is ignored as this method never blocks.
            </param>
            <returns>Always <c>true</c>.</returns>
            <exception cref="T:System.ArgumentNullException">
            If the specified element is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Poll(`0@)">
            <summary> 
            Retrieves and removes the head of this queue, or returns 
            <c>false</c> if this has queue no elements with an expired delay.
            </summary>
            <param name="element">
            Set to the elemented retrieved from the queue if the return value
            is <c>true</c>. Otherwise, set to <c>default(T)</c>.
            </param>
            <returns> 
            <c>false</c> if this queue has no elements with an expired delay.
            Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element with an expired delay is available on this queue.
            </summary>
            <returns>The head of this queue.</returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If thread is interruped when waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Poll(System.TimeSpan,`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element with an expired delay is available on this queue,
            or the specified wait time expires.
            </summary>
            <param name="duration">How long to wait before giving up.</param>
            <param name="element">
            Set to the head of this queue, or <c>default(T)</c> if the specified
            waiting time elapses before an element with an expired delay becomes
            available
            </param>
            <returns> 
            <c>false</c> if the specified waiting time elapses before an element
            is available. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Peek(`0@)">
            <summary>
            Retrieves, but does not remove, the head of this queue into out
            parameter <paramref name="element"/>. Unlike <see cref="M:Spring.Threading.Collections.Generic.DelayQueue`1.Poll(`0@)"/>,
            if no expired elements are available in the queue, this method returns
            the element that will expire next, if one exists.
            </summary>
            <param name="element">
            The head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> is the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.GetEnumerator">
            <summary> 
            Returns an enumerator over all the elements (both expired and
            unexpired) in this queue. The enumerator does not return the
            elements in any particular order.
            </summary>
            <remarks>
            The returned <see cref="T:System.Collections.Generic.IEnumerator`1"/> is a "weakly consistent" 
            enumerator that will not throw <see cref="T:System.InvalidOperationException"/> 
            when the queue is concurrently modified, and guarantees to traverse
            elements as they existed upon construction of the enumerator, and
            may (but is not guaranteed to) reflect any modifications subsequent
            to construction.
            </remarks>
            <returns>
            An enumerator over the elements in this queue.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.CopyTo(System.Array,System.Int32)">
            <summary>
            When implemented by a class, copies the elements of the ICollection to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from ICollection. The Array must have zero-based indexing.</param>
            <param name="index">The zero-based index in array at which copying begins. </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does the actual work of copying to array.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <param name="ensureCapacity">
            If is <c>true</c>, calls <see cref="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)"/>
            </param>
            <returns>
            A new array of same runtime type as <paramref name="array"/> if 
            <paramref name="array"/> is too small to hold all elements and 
            <paramref name="ensureCapacity"/> is <c>false</c>. Otherwise
            the <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Clear">
            <summary> 
            Removes all of the elements from this queue.
            </summary>
            <remarks>
            <para>
            The queue will be empty after this call returns.
            </para>
            </remarks>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.DelayQueue`1.Remove(`0)">
            <summary>
            Removes a single instance of the specified element from this
            queue, if it is present, whether or not it has expired.
            </summary>
            <param name="element">element to remove</param>
            <returns><c>true</c> if element was remove, <c>false</c> if not.</returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.DelayQueue`1.Capacity">
            <summary>
            Returns the capacity of this queue. Since this is a unbounded queue, <see cref="F:System.Int32.MaxValue"/> is returned.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.DelayQueue`1.RemainingCapacity">
            <summary> 
            <see cref="T:Spring.Threading.Collections.Generic.DelayQueue`1"/> is unbounded so this always
            return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
            <returns><see cref="F:System.Int32.MaxValue"/></returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.DelayQueue`1.Count">
            <summary>
            Returns the current number of elements in this queue.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.IConcurrentDictionary`2">
             <summary>
             A <see cref="T:System.Collections.Generic.IDictionary`2"/> providing additional atomic
             <see cref="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.PutIfAbsent(`0,`1)"/>, <see cref="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.Remove(`0,`1)"/>, <see cref="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.Replace(`0,`1)"/> and <see cref="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.Replace(`0,`1,`1)"/> methods.
            
             <p>
             Memory consistency effects: As with other concurrent
             collections, actions in a thread prior to placing an object into a
             <see cref="T:Spring.Threading.Collections.Generic.IConcurrentDictionary`2"/> as a key or value
             <i>happen-before</i>
             actions subsequent to the access or removal of that object from
             the <see cref="T:Spring.Threading.Collections.Generic.IConcurrentDictionary`2"/> in another thread.
             </p>
            
             </summary>
             <author>Doug Lea</author>
             <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.PutIfAbsent(`0,`1)">
            <summary>
             If the specified <paramref name="key"/> is not already associated
             with a value, associate it with the given <paramref name="value"/>.
             This is equivalent to
             <pre>
               if (!dictionary.containsKey(key))
                   return dictionary.put(key, value);
               else
                   return dictionary.get(key);
             </pre>
             except that the action is performed atomically.
            </summary>
            <param name="key">key with which the specified value is to be associated</param>
            <param name="value">value to be associated with the specified key</param>
            <returns>the previous value associated with the specified key, or <c>null</c> if there was no mapping for the key. (A <c>null</c> return can also indicate that the dictionary previously associated <c>null</c> with the key, if the implementation supports null values.)</returns>
             <exception cref="T:System.InvalidOperationException">if the put operation is not supported by this dictionary</exception>
             <exception cref="T:System.NullReferenceException">if the specific key or value is null ( and this dictionary does not support null keys or values )</exception>
             <exception cref="T:System.ArgumentException">if some property of the specific key or value prevents if from being stored in this dictionary.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.Remove(`0,`1)">
            <summary>
             Removes the entry for <paramref name="key"/> only if currently mapped to <paramref name="value"/>.
             This is equivalent to
             <pre>
               if (dictionary.containsKey(key) &amp;&amp; dictionary.get(key).equals(value)) {
                   dictionary.remove(key);
                   return true;
               } else return false;
             </pre>
             except that the action is performed atomically.
            </summary>
            <param name="key">key with which the specified value is to be associated</param>
            <param name="value">value expected to be associated with the specified key</param>
            <returns><c>true</c> if the value was removed, <c>false</c> otherwise.</returns>
             <exception cref="T:System.InvalidOperationException">if the put operation is not supported by this dictionary</exception>
             <exception cref="T:System.NullReferenceException">if the specific key or value is null ( and this dictionary does not support null keys or values )</exception>
             <exception cref="T:System.ArgumentException">if some property of the specific key or value prevents if from being stored in this dictionary.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.Replace(`0,`1,`1)">
            <summary>
             Replaces the entry for <paramref name="key"/> only if currently mapped to <paramref name="oldValue"/>.
             This is equivalent to
             <pre>
               if (dictionary.containsKey(key) &amp;&amp; dictionary.get(key).equals(oldValue)) {
                   dictionary.put(key, newValue);
                   return true;
               } else return false;</pre>
             except that the action is performed atomically.
            </summary>
            <param name="key">key with which the specified value is associated</param>
            <param name="oldValue">value expected to be associated with the specified key</param>
            <param name="newValue">value to be associated with the specified key</param>
            <returns><c>true</c> if the value was replaced, <c>false</c> otherwise.</returns>
             <exception cref="T:System.InvalidOperationException">if the put operation is not supported by this dictionary</exception>
             <exception cref="T:System.NullReferenceException">if the specific key or value is null ( and this dictionary does not support null keys or values )</exception>
             <exception cref="T:System.ArgumentException">if some property of the specific key or value prevents if from being stored in this dictionary.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.IConcurrentDictionary`2.Replace(`0,`1)">
            <summary>
             Replaces the entry for  <paramref name="key"/> only if currently mapped to a value.
             This is equivalent to
             <pre>
               if (dictionary.containsKey(key)) {
                   return dictionary.put(key, value);
               } else return null;
             </pre>
             except that the action is performed atomically.
            </summary>
            <param name="key">key with which the specified value is associated</param>
            <param name="value">value to be associated with the specified key</param>
            <returns>the previous value associated with the specified key, or <c>null</c> if there was no mapping for the key. (A <c>null</c> return can also indicate that the dictionary previously associated <c>null</c> with the key, if the implementation supports null values.)</returns>
             <exception cref="T:System.InvalidOperationException">if the put operation is not supported by this dictionary</exception>
             <exception cref="T:System.NullReferenceException">if the specific key or value is null ( and this dictionary does not support null keys or values )</exception>
             <exception cref="T:System.ArgumentException">if some property of the specific key or value prevents if from being stored in this dictionary.</exception>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.IConcurrentNavigableDictionary`2">
            <summary> A <see cref="T:Spring.Threading.Collections.Generic.IConcurrentDictionary`2"/> supporting <see cref="T:Spring.Collections.Generic.INavigableDictionary`2"/>
            operations,and recursively so for its navigable sub-maps.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1">
            <summary> 
            An optionally-bounded <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> based on
            linked nodes.
            </summary>
            <remarks>
            <para>
            This queue orders elements FIFO (first-in-first-out).
            The <b>head</b> of the queue is that element that has been on the
            queue the longest time.
            The <b>tail</b> of the queue is that element that has been on the
            queue the shortest time. New elements
            are inserted at the tail of the queue, and the queue retrieval
            operations obtain elements at the head of the queue.
            Linked queues typically have higher throughput than array-based queues but
            less predictable performance in most concurrent applications.
            </para>
            <para>
            The optional capacity bound constructor argument serves as a
            way to prevent excessive queue expansion. The capacity, if unspecified,
            is equal to <see cref="F:System.Int32.MaxValue"/>.  Linked nodes are
            dynamically created upon each insertion unless this would bring the
            queue above capacity.
            </para>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1._capacity">
            <summary>The capacity bound, or <see cref="F:System.Int32.MaxValue"/> if none </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1._activeCount">
            <summary>Current number of elements </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1._head">
            <summary>Head of linked list </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1._last">
            <summary>Tail of linked list </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1._takeLock">
            <summary>Lock held by take, poll, etc </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1._putLock">
            <summary>Lock held by put, offer, etc </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.#ctor">
            <summary> Creates a <see cref="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1"/> with a capacity of
            <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.#ctor(System.Int32)">
            <summary> Creates a <see cref="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1"/> with the given (fixed) capacity.</summary>
            <param name="capacity">the capacity of this queue</param>
            <exception cref="T:System.ArgumentException">if the <paramref name="capacity"/> is not greater than zero.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary> Creates a <see cref="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1"/> with a capacity of
            <see cref="F:System.Int32.MaxValue"/>, initially containing the elements o)f the
            given collection, added in traversal order of the collection's iterator.
            </summary>
            <param name="collection">the collection of elements to initially contain</param>
            <exception cref="T:System.ArgumentNullException">if the collection or any of its elements are null.</exception>
            <exception cref="T:System.ArgumentException">if the collection size exceeds the capacity of this queue.</exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Reconstitute this queue instance from a stream (that is,
            deserialize it).
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data. </param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization. </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
             <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with the data needed to serialize the target object.
             </summary>
             <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data. </param>
             <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization. </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Put(`0)">
            <summary> 
            Inserts the specified element into this queue, waiting if necessary
            for space to become available.
            </summary>
            <param name="element">the element to add</param>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
            <exception cref="T:Spring.Threading.Collections.Generic.QueueBrokenException">
            If the queue is already <see cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken">closed</see>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.TryPut(`0)">
            <summary>
            Inserts the specified element into this queue, waiting if necessary
            for space to become available.
            </summary>
            <remarks>
            <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/> the queue will cause a waiting <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.TryPut(`0)"/>
            to returned <c>false</c>. This is very useful to indicate that the
            consumer is stopped or going to stop so that the producer should not 
            put more items into the queue.
            </remarks>
            <param name="element">the element to add</param>
            <returns>
            <c>true</c> if succesfully and <c>false</c> if queue <see cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken"/>.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Offer(`0,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for space to become available.
            </summary>
            <param name="element">the element to add</param>
            <param name="duration">how long to wait before giving up</param>
            <returns> <c>true</c> if successful, or <c>false</c> if
            the specified waiting time elapses before space is available
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If the element cannot be added at this time due to capacity restrictions.
            </exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Offer(`0)">
            <summary> 
            Inserts the specified element into this queue if it is possible to do
            so immediately without violating capacity restrictions.
            </summary>
            <remarks>
            When using a capacity-restricted queue, this method is generally
            preferable to <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Add(`0)"/>,
            which can fail to insert an element only by throwing an exception.
            </remarks>
            <param name="element">
            The element to add.
            </param>
            <returns>
            <c>true</c> if the element was added to this queue.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element becomes available.
            </summary>
            <returns> the head of this queue</returns>
            <exception cref="T:Spring.Threading.Collections.Generic.QueueBrokenException">
            If the queue is empty and already <see cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken">closed</see>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.TryTake(`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until an element becomes available.
            </summary>
            <remarks>
            <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/> the queue will cause a waiting <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.TryTake(`0@)"/>
            to returned <c>false</c>. This is very useful to indicate that the
            producer is stopped so that the producer should stop waiting for
            element from queu.
            </remarks>
            <param name="element">
            The head of this queue if successful.
            </param>
            <returns>
            <c>true</c> if succesfully and <c>false</c> if queue is empty and 
            <see cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken">closed</see>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Poll(System.TimeSpan,`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for an element to become available.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <param name="duration">How long to wait before giving up.</param>
            <returns> 
            <c>false</c> if the queue is still empty after waited for the time 
            specified by the <paramref name="duration"/>. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Poll(`0@)">
            <summary>
            Retrieves and removes the head of this queue into out parameter
            <paramref name="element"/>. 
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> if the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Peek(`0@)">
            <summary>
            Retrieves, but does not remove, the head of this queue into out
            parameter <paramref name="element"/>.
            </summary>
            <param name="element">
            The head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> is the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Remove(`0)">
            <summary> 
            Removes a single instance of the specified element from this queue,
            if it is present.  
            </summary>
            <remarks> 
            If this queue contains one or more such elements.
            Returns <c>true</c> if this queue contained the specified element
            (or equivalently, if this queue changed as a result of the call).
            </remarks>
            <param name="objectToRemove">element to be removed from this queue, if present</param>
            <returns><c>true</c> if this queue changed as a result of the call</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.DoDrain(System.Action{`0},System.Predicate{`0})">
            <summary>
            Does the real work for the <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0})"/>
            and <see cref="M:Spring.Collections.Generic.AbstractQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all drain methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Predicate{`0})"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does the actual work of copying to array.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
            <param name="ensureCapacity">
            If is <c>true</c>, calls <see cref="M:Spring.Collections.Generic.AbstractCollection`1.EnsureCapacity(`0[],System.Int32)"/>
            </param>
            <returns>
            A new array of same runtime type as <paramref name="array"/> if 
            <paramref name="array"/> is too small to hold all elements and 
            <paramref name="ensureCapacity"/> is <c>false</c>. Otherwise
            the <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Contains(`0)">
            <summary>
            test whether the queue contains <paramref name="item"/> 
            </summary>
            <param name="item">the item whose containement should be checked</param>
            <returns><c>true</c> if item is in the queue, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break">
            <summary>
            Breaks current queue. 
            </summary>
            <remarks>
            <para>
            When a queue is broken, all blocking actions and subsequent put
            actions will return immediately with unsuccesful status or 
            <see cref="T:Spring.Threading.Collections.Generic.QueueBrokenException"/> is thrown if method doesn't 
            return any status. Subsequent get actions will continue to sucess
            until the queue becomes empty.
            </para>
            <para>
            <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/> allows remaining elements in the queue to
            be consumed by subsequent get actions. Use <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Stop"/> 
            to break and clear the queue in the same time, which effectively
            ensures any subsequent get action to fail.
            </para>
            <para>
            Use <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear"/> to restore the queue back to normal state.
            </para>
            </remarks>
            <seealso cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Stop"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Stop">
            <summary>
            <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/>s and empties current queue. 
            </summary>
            <remarks>
            <para>
            As soon as a queue is stopped, all blocking queue modification 
            actions return immediately with unsuccesful status or 
            <see cref="T:Spring.Threading.Collections.Generic.QueueBrokenException"/> is thrown if method doesn't 
            return any status. So do any subsequent queue modification
            actions.
            </para>
            <para>
            Use <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/> to only affect put operations but allowing
            get operations to continue untile queue is empty.
            </para>
            <para>
            Use <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear"/> to restore the queue back to normal state.
            </para>
            </remarks>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/>
            <seealso cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear"/>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.ToString">
            <summary>
            Returns a string representation of this colleciton.
            </summary>
            <returns>String representation of the elements of this collection.</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear">
            <summary> 
            Removes all of the elements from this queue and reopen the queue if
            it was closed.
            </summary>
            <remarks>
            <p>
            The queue will be empty after this call returns.
            </p>
            </remarks>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.GetEnumerator">
            <summary> 
            Returns an <see cref="T:System.Collections.Generic.IEnumerator`1"/> over the elements in this 
            queue in proper sequence.
            </summary>
            <remarks>
            The returned <see cref="T:System.Collections.Generic.IEnumerator`1"/> is a "weakly consistent" 
            enumerator that will not throw <see cref="T:System.InvalidOperationException"/> 
            when the queue is concurrently modified, and guarantees to traverse
            elements as they existed upon construction of the enumerator, and
            may (but is not guaranteed to) reflect any modifications subsequent
            to construction.
            </remarks>
            <returns>
            An enumerator over the elements in this queue in proper sequence.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.SignalNotEmpty">
            <summary> 
            Signals a waiting take. Called only from put/offer (which do not
            otherwise ordinarily lock _takeLock.)
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.SignalNotFull">
            <summary> Signals a waiting put. Called only from take/poll.</summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Insert(`0)">
            <summary> 
            Creates a node and links it at end of queue.</summary>
            <param name="x">the item to insert</param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Extract">
            <summary>Removes a node from head of queue,</summary>
            <returns>the node</returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.RemainingCapacity">
            <summary> 
            Returns the number of additional elements that this queue can ideally
            (in the absence of memory or resource constraints) accept without
            blocking. This is always equal to the initial capacity of this queue
            minus the current <see cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Count"/> of this queue.
            </summary>
            <remarks> 
            Note that you <b>cannot</b> always tell if an attempt to insert
            an element will succeed by inspecting <see cref="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.RemainingCapacity"/>
            because it may be the case that another thread is about to
            insert or remove an element.
            </remarks>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Capacity">
            <summary>
            Gets the capacity of this queue.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Count">
            <summary>
            Gets the count of the queue. 
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.IsBroken">
            <summary>
            Indicate if current queue is broken. A broken queue never blocks.
            </summary>
            <para>
            When a queue is broken, all blocking actions and subsequent put
            actions will return immediately with unsuccesful status or 
            <see cref="T:Spring.Threading.Collections.Generic.QueueBrokenException"/> is thrown if method doesn't 
            return any status. Subsequent get actions will continue to sucess
            until the queue becomes empty, then further get actions will return
            unsuccesful status or throws <see cref="T:Spring.Threading.Collections.Generic.QueueBrokenException"/>.
            </para>
            <para>
            Use <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/> or <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Stop"/> to break a queue.
            </para>
            <para>
            Use <see cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear"/> to restore the queue back to normal state.
            </para>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Break"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Stop"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.Clear"/>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1.LinkedBlockingQueueEnumerator">
            <summary>
            Internal enumerator class
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1">
            <summary>
            An unbounded <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1">blocking queue</see> that
            uses the same ordering rules as class <see cref="T:Spring.Collections.Generic.PriorityQueue`1"/>
            and supplies blocking retrieval operations.  While this queue is
            logically unbounded, attempted additions may fail due to resource
            exhaustion (causing <see cref="T:System.OutOfMemoryException"/>). This class
            does not permit <c>null</c> elements.  A priority queue relying on
            <see cref="T:System.IComparable`1">natural ordering</see> also does not
            permit insertion of non-comparable objects (doing so results in
            <see cref="T:System.InvalidCastException"/>).
            </summary>
            <remarks>
            <para>
            This class implement all of the <i>optional</i> methods of the
            <see cref="T:System.Collections.Generic.ICollection`1"/> interfaces.  The enumerator provided in
            method <see cref="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.GetEnumerator"/> is <i>not</i> guaranteed to traverse
            the elements of the <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> in any
            particular order. If you need ordered traversal, consider using
            <c>Array.Sort(pq.ToArray())</c>.  Also, method
            <see cref="M:Spring.Threading.Collections.Generic.AbstractBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            can be used to <i>remove</i> some or all elements in priority
            order and place them in another collection.
            </para>
            <para>
            Operations on this class make no guarantees about the ordering
            of elements with equal priority. If you need to enforce an
            ordering, you can define custom classes or comparers that use a
            secondary key to break ties in primary priority values.
            </para>
            <example>
            For example, here is a class that applies first-in-first-out
            tie-breaking to comparable elements. To use it, you would insert a
            <c>new FIFOEntry&lt;Entry&gt;(anEntry)</c> instead of a plain entry object.
             
            <code language="c#">
            public class FIFOEntry&lt;T&gt; : IComparable&lt;FIFOEntry&lt;T&gt;&gt; 
                where T : class, IComparable&lt;T&gt;
            {
              readonly static AtomicLong seq = new AtomicLong();
              readonly long seqNum;
              readonly T entry;
              public FIFOEntry(T entry) {
                seqNum = seq.ReturnValueAndDecrement();
                this.entry = entry;
              }
              public object Entry { get { return entry; } }
              public int CompareTo(FIFOEntry&lt;T&gt; other) {
                int res = entry.CompareTo(other.entry);
                if (res == 0 &amp;&amp; !ReferenceEquals(other.entry, entry))
                  res = (seqNum &lt; other.seqNum ? -1 : 1);
                return res;
              }
            }
            </code>
            </example>
            </remarks>
            <author>Doug Lea</author>
            <author>Andreas Döhring (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.#ctor">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> with the default
            initial capacity (11) that orders its elements according to
            their <see cref="T:System.IComparable`1">natural ordering</see>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> with the specified
            initial capacity that orders its elements according to their
            <see cref="T:System.IComparable`1">natural ordering</see>.
            </summary>
            <param name="initialCapacity">
            The initial capacity for this priority queue.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="initialCapacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> with the specified
            initial capacity that orders its elements according to the specified
            comparer.
            </summary>
            <param name="initialCapacity">
            The initial capacity for this priority queue.
            </param>
            <param name="comparer">
            The comparer that will be used to order this priority queue.  
            If <c>null</c>, the <see cref="T:System.IComparable`1">natural ordering</see>
            of the elements will be used.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="initialCapacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.#ctor(System.Int32,System.Comparison{`0})">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> with the specified
            initial capacity that orders its elements according to the specified
            comparison.
            </summary>
            <param name="initialCapacity">
            The initial capacity for this priority queue.
            </param>
            <param name="comparison">
            The comparison that will be used to order this priority queue.  
            If <c>null</c>, the <see cref="T:System.IComparable`1">natural ordering</see>
            of the elements will be used.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="initialCapacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1"/> initially populated
            with <paramref name="collection"/>.
            </summary>
            <param name="collection">
            The collection whose elements are to be placed into this priority queue.
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.GetEnumerator">
            <summary> 
            Returns an enumerator over all the elements (both expired and
            unexpired) in this queue. The enumerator does not return the
            elements in any particular order.
            </summary>
            <remarks>
            The returned <see cref="T:System.Collections.Generic.IEnumerator`1"/> is a "weakly consistent" 
            enumerator that will not throw <see cref="T:System.InvalidOperationException"/> 
            when the queue is concurrently modified, and guarantees to traverse
            elements as they existed upon construction of the enumerator, and
            may (but is not guaranteed to) reflect any modifications subsequent
            to construction.
            </remarks>
            <returns>
            An enumerator over the elements in this queue.
            </returns>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.PriorityBlockingQueue`1.Comparer">
            <summary>
            Returns the comparer used to order the elements in this queue,
            or <c>null</c> if this queue uses the <see cref="T:System.IComparable`1">
            natural ordering</see> of its elements.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.SynchronousQueue`1">
            <summary>
            A <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1">blocking queue</see> in which each 
            insert operation must wait for a corresponding remove operation by 
            another thread, and vice versa.
            </summary>
            <remarks>
            <para>
            A synchronous queue does not have any internal capacity, not even 
            a capacity of one.  You cannot <see cref="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Peek(`0@)"/> at a synchronous 
            queue because an element is only present when you try to remove it; 
            you cannot insert an element (using any method) unless another thread 
            is trying to remove it; you cannot iterate as there is nothing to 
            iterate.  The <i>head</i> of the queue is the element that the first 
            queued inserting thread is trying to add to the queue; if there is no 
            such queued thread then no element is available for removal and
            <see cref="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Poll(`0@)"/> will return <c>false</c>.  For purposes of 
            other <see cref="T:System.Collections.Generic.ICollection`1"/> methods (for example <c>Contains</c>), 
            a <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> acts as an empty collection.
            </para>
            <para>
            Synchronous queues are similar to rendezvous channels used in
            CSP and Ada. They are well suited for handoff designs, in which an
            object running in one thread must sync up with an object running
            in another thread in order to hand it some information, event, or
            task.
            </para>
            <para>
            This class supports an optional fairness policy for ordering
            waiting producer and consumer threads.  By default, this ordering
            is not guaranteed. However, a queue constructed with fairness set
            to <c>true</c> grants threads access in FIFO order. Fairness
            generally decreases throughput but reduces variability and avoids
            starvation.
            </para>
            </remarks>
            <author>Doug Lea</author>
            <author>Andreas Döhring (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1._qlock">
            Lock protecting both wait queues 
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1._waitingProducers">
            Queue holding waiting puts 
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1._waitingConsumers">
            Queue holding waiting takes 
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.#ctor">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> with nonfair access policy.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.#ctor(System.Boolean)">
            <summary>
            Creates a <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> with specified fairness policy.
            </summary>
            <param name="fair">
            if true, threads contend in FIFO order for access otherwise the order is unspecified.
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.UnlinkCancelledConsumer(Spring.Threading.Collections.Generic.SynchronousQueue{`0}.Node)">
            <summary>
            Unlinks the given node from consumer queue.  Called by cancelled
            (timeout, interrupt) waiters to avoid garbage retention in the
            absence of producers.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.UnlinkCancelledProducer(Spring.Threading.Collections.Generic.SynchronousQueue{`0}.Node)">
            <summary>
            Unlinks the given node from producer queue.  Symmetric to 
            <see cref="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.UnlinkCancelledConsumer(Spring.Threading.Collections.Generic.SynchronousQueue{`0}.Node)"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Put(`0)">
            <summary> 
            Inserts the specified element into this queue, waiting if necessary
            another thread to receive it.
            </summary>
            <param name="element">the element to add</param>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Offer(`0,System.TimeSpan)">
            <summary> 
            Inserts the specified element into this queue, waiting up to the
            specified wait time if necessary for another thread to receive it.
            </summary>
            <param name="element">The element to add.</param>
            <param name="duration">How long to wait before giving up.</param>
            <returns>
            <see langword="true"/> if successful, or <see langword="false"/> if
            the specified waiting time elapses before space is available.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Take">
            <summary> 
            Retrieves and removes the head of this queue, waiting if necessary
            until another thread inserts it.
            </summary>
            <returns> the head of this queue</returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if interrupted while waiting.
            </exception>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Poll(System.TimeSpan,`0@)">
            <summary> 
            Retrieves and removes the head of this queue, waiting up to the
            specified wait time if necessary for another thread to insert it.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <param name="duration">How long to wait before giving up.</param>
            <returns> 
            <c>false</c> if the queue is still empty after waited for the time 
            specified by the <paramref name="duration"/>. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Offer(`0)">
            <summary>
            Inserts the specified element into this queue if another thread if
            waiting to receive it. Otherwise return <c>false</c> immediately.
            </summary>
            <param name="element">The element to add.</param>
            <returns>
            <c>true</c> if the element was added to this queue. Otherwise 
            <c>false</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Poll(`0@)">
            <summary>
            Retrieves and removes the head of this queue into out parameter
            <paramref name="element"/>, if another thead is currently making
            an element available. Otherwise return <c>false</c> immediately.
            </summary>
            <param name="element">
            Set to the head of this queue. <c>default(T)</c> if queue is empty.
            </param>
            <returns>
            <c>false</c> if the queue is empty. Otherwise <c>true</c>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Clear">
            <summary>
            Does nothing. A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/>
            has no internal capacity.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Contains(`0)">
            <summary>
            Always returns <c>false</c>. A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/>
            has no internal capacity.
            </summary>
            <returns>Always <c>false</c>.</returns>
            <param name="item">
            The object to locate in the <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/>.
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Remove(`0)">
            <summary>
            Always returns <c>false</c>. A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/>
            has no internal capacity.
            </summary>
            <returns>Always <c>false</c>.</returns>
            <param name="item">
            The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Peek(`0@)">
            <summary>
            Always returns <c>false</c>. A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/>
            does not return elements unless actively waited on.
            </summary>
            <param name="element">
            Always set to <c>default(T)</c>.
            </param>
            <returns>Always <c>false</c>.</returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.GetEnumerator">
            <summary>
            Returns an empty enumerator in which <see cref="M:System.Collections.IEnumerator.MoveNext"/>
            always returns <c>false</c>.
            </summary>
            <returns>
            An empty <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.DoCopyTo(`0[],System.Int32,System.Boolean)">
            <summary>
            Does nothing. A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/>
            has no internal capacity.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            Ignored.
            </param>
            <param name="ensureCapacity">
            Ignored.
            </param>
            <returns>
            The <paramref name="array"/> instance itself.
            </returns>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.DoDrain(System.Action{`0},System.Int32,System.Predicate{`0})">
            <summary> 
            Does the real work for all <c>Drain</c> methods. Caller must
            guarantee the <paramref name="action"/> is not <c>null</c> and
            <paramref name="maxElements"/> is greater then zero (0).
            </summary>
            <remarks>
            Since the queue has no capacity. This method does nothing and 
            returns zero(0) if <paramref name="criteria"/> is not <c>null</c>.
            Otherwise, one or zero element will be processed depends on the
            result of <see cref="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Poll(`0@)"/>.
            </remarks>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
            <seealso cref="M:Spring.Collections.Generic.IQueue`1.Drain(System.Action{`0})"/>
            <seealso cref="M:Spring.Threading.Collections.Generic.IBlockingQueue`1.DrainTo(System.Collections.Generic.ICollection{`0},System.Int32)"/>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.SynchronousQueue`1.IsEmpty">
            <summary>
            Always returns <c>true</c>.
            A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> has no internal capacity.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.SynchronousQueue`1.Count">
            <summary>
            Always returns zero(0).
            A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> has no internal capacity.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.SynchronousQueue`1.RemainingCapacity">
            <summary>
            Always returns zero.
            A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> has no internal capacity.
            </summary>
        </member>
        <member name="P:Spring.Threading.Collections.Generic.SynchronousQueue`1.Capacity">
            <summary>
            Always returns zero.
            A <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> has no internal capacity.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.SynchronousQueue`1.IWaitQueue">
            <summary>
            Queue to hold waiting puts/takes; specialized to Fifo/Lifo below.
            These queues have all transient fields, but are serializable
            in order to recover fairness settings when deserialized.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.IWaitQueue.Enqueue(`0)">
            <summary>
            Creates, adds, and returns node for x
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.IWaitQueue.Dequeue">
            <summary>
            Removes and returns node, or null if empty.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.IWaitQueue.Unlink(Spring.Threading.Collections.Generic.SynchronousQueue{`0}.Node)">
            <summary>
            Removes a cancelled node to avoid garbage retention.
            </summary>
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.IWaitQueue.ShouldUnlink(Spring.Threading.Collections.Generic.SynchronousQueue{`0}.Node)">
            <summary>
            Returns true if a cancelled node might be on queue.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.SynchronousQueue`1.FifoWaitQueue">
            <summary>
            FIFO queue to hold waiting puts/takes.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.SynchronousQueue`1.LifoWaitQueue">
            <summary>
            LIFO queue to hold waiting puts/takes.
            </summary>
        </member>
        <member name="T:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node">
            <summary>
            Nodes each maintain an item and handle waits and signals for
            getting and setting it. The class extends
            AbstractQueuedSynchronizer to manage blocking, using AQS state
             0 for waiting, 1 for ack, -1 for cancelled.
            </summary>
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.Ack">
            Synchronization state value representing that node acked 
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.Cancel">
            Synchronization state value representing that node cancelled 
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node._item">
            The item being transferred 
        </member>
        <member name="F:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.Next">
            Next node in wait queue 
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.#ctor(`0)">
            Creates a node with initial item 
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.#ctor(`0,Spring.Threading.Collections.Generic.SynchronousQueue{`0}.Node)">
            Creates a node with initial item and next 
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.Extract">
             Takes item and nulls out field (for sake of GC)
            
             PRE: lock owned
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.CheckCancellationOnInterrupt(System.Threading.ThreadInterruptedException)">
             Tries to cancel on interrupt; if so rethrowing,
             else setting interrupt state
            
             PRE: lock owned
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.SetItem(`0)">
            Fills in the slot created by the consumer and signal consumer to
            continue.
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.GetItem(`0@)">
            Removes item from slot created by producer and signal producer
            to continue.
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.WaitForTake">
            Waits for a consumer to take item placed by producer.
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.WaitForPut">
            Waits for a producer to put item placed by consumer.
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.WaitForTake(System.TimeSpan)">
            Waits for a consumer to take item placed by producer or time out.
        </member>
        <member name="M:Spring.Threading.Collections.Generic.SynchronousQueue`1.Node.WaitForPut(System.TimeSpan,`0@)">
            Waits for a producer to put item placed by consumer, or time out.
        </member>
        <member name="T:Spring.Threading.Helpers.FIFOWaitQueue">
            <summary> 
            Simple linked list queue used in FIFOSemaphore.
            Methods are not locked; they depend on synch of callers.
            NOTE: this class is NOT present in java.util.concurrent.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Helpers.IWaitQueue">
            <summary> 
            Interface for internal queue classes for semaphores, etc.
            Relies on implementations to actually implement queue mechanics.
            NOTE: this interface is NOT present in java.util.concurrent.
            </summary>	
            <author>Dawid Kurzyniec</author>
            <author>Griffin Caprio (.NET)</author>
            <changes>
            <list>
            <item>Renamed Insert to Enqueue</item>
            <item>Renamed Extract to Dequeue</item>
            </list>
            </changes>
        </member>
        <member name="T:Spring.Threading.IContextCarrier">
            <summary>
            Context carrier captures the context of one running thread and stores 
            the context in another thread.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.IContextCarrier.Restore">
            <summary>
            Restores the captured context. Once the carrier is restored, it cann
            </summary>
        </member>
        <member name="T:Spring.Threading.ContextCopyingRunnable">
            <summary>
            An implementation of <see cref="T:Spring.Threading.IRunnable"/> that restores the context
            before it is run.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Runnable">
            <summary>
            Class to convert <see cref="T:System.Action"/> to <see cref="T:Spring.Threading.IRunnable"/>.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.IRunnable">
            <summary>
            Interface for executables. It is the same of java Runnable.
            </summary>
        </member>
        <member name="M:Spring.Threading.IRunnable.Run">
            <summary>
            The entry point
            </summary>
        </member>
        <member name="F:Spring.Threading.Runnable._action">
            <summary>
            The action to execute;
            </summary>
        </member>
        <member name="M:Spring.Threading.Runnable.#ctor(System.Action)">
            <summary>
            Construct a new instance of <see cref="T:Spring.Threading.Runnable"/> which calls
            <paramref name="action"/> delegate with its <see cref="M:Spring.Threading.Runnable.Run"/> method
            is invoked.
            </summary>
            <param name="action">
            The delegate to be called when <see cref="M:Spring.Threading.Runnable.Run"/> is invoked.
            </param>
        </member>
        <member name="M:Spring.Threading.Runnable.Run">
            <summary>
            The entry point. Invokes the delegate passed to the constructor
            <see cref="M:Spring.Threading.Runnable.#ctor(System.Action)"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Runnable.op_Explicit(System.Action)~Spring.Threading.Runnable">
            <summary>
            Implicitly converts <see cref="T:System.Action"/> delegate to an instance
            of <see cref="T:Spring.Threading.Runnable"/>.
            </summary>
            <param name="action">
            The delegate to be converted to <see cref="T:Spring.Threading.Runnable"/>.
            </param>
            <returns>
            An instance of <see cref="T:Spring.Threading.Runnable"/> based on <paramref name="action"/>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Runnable.op_Explicit(Spring.Threading.Runnable)~System.Action">
            <summary>
            Implicitly converts <see cref="T:Spring.Threading.Runnable"/> to <see cref="T:System.Action"/>
            delegate.
            </summary>
            <param name="runnable">
            The callable to be converted to <see cref="T:System.Action"/>.
            </param>
            <returns>
            The original <see cref="T:System.Action"/> delegate used to construct the
            <paramref name="runnable"/>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Runnable.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to 
            the current <see cref="T:Spring.Threading.Runnable"/>.
            </summary>
            <returns>
            true if the <paramref name="obj"/> is of type <see cref="T:Spring.Threading.Runnable"/> 
            and it carrys the same inner action as current instance; otherwise, false.
            </returns>
            <param name="obj">
            The <see cref="T:System.Object"/> to compare with the current instance. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Runnable.Equals(Spring.Threading.Runnable)">
            <summary>
            Determines whether the specified <paramref name="other"/> instance 
            is equal to the current <see cref="T:Spring.Threading.Runnable"/>.
            </summary>
            <returns>
            true if the <paramref name="other"/> carrys the same inner action 
            as current instance; otherwise, false.
            </returns>
            <param name="other">
            The other <see cref="T:Spring.Threading.Runnable"/> to compare with the current instance. 
            </param>
        </member>
        <member name="M:Spring.Threading.Runnable.GetHashCode">
            <summary>
            Returns the has code of the inner action. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Spring.Threading.Runnable"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Spring.Threading.IContextCopyingTask">
            <summary>
            A marker interface to indicate the task copies the context.
            </summary>
        </member>
        <member name="P:Spring.Threading.IContextCopyingTask.ContextCarrier">
            <summary>
            Gets and sets the <see cref="T:Spring.Threading.IContextCarrier"/> that captures
            and restores the context.
            </summary>
        </member>
        <member name="P:Spring.Threading.ContextCopyingRunnable.ContextCarrier">
            <summary>
            Gets and sets the <see cref="T:Spring.Threading.IContextCarrier"/> that captures
            and restores the context.
            </summary>
        </member>
        <member name="T:Spring.Threading.CountDown">
            <summary> A CountDown can serve as a simple one-shot barrier. 
            A Countdown is initialized
            with a given count value. Each release decrements the count.
            All acquires block until the count reaches zero. Upon reaching
            zero all current acquires are unblocked and all 
            subsequent acquires pass without blocking. This is a one-shot
            phenomenon -- the count cannot be reset. 
            If you need a version that resets the count, consider
            using a Barrier.
            <p>
            <b>Sample usage.</b> Here are a set of classes in which
            a group of worker threads use a countdown to
            notify a driver when all threads are complete.
            <pre>
            class Worker implements Runnable { 
            private final CountDown done;
            Worker(CountDown d) { done = d; }
            public void run() {
            doWork();
            done.release();
            }
            }
            
            class Driver { // ...
            void main() {
            CountDown done = new CountDown(N);
            for (int i = 0; i &lt; N; ++i) 
            new Thread(new Worker(done)).start();
            doSomethingElse(); 
            done.acquire(); // wait for all to finish
            } 
            }
            </pre>
            </p>
            </summary>
        </member>
        <member name="F:Spring.Threading.CountDown.initialCount_">
            <summary>
            the initial count
            </summary>
        </member>
        <member name="F:Spring.Threading.CountDown.count_">
            <summary>
            the actual count 
            </summary>
        </member>
        <member name="M:Spring.Threading.CountDown.#ctor(System.Int32)">
            <summary>Create a new CountDown with given count value *</summary>
        </member>
        <member name="M:Spring.Threading.CountDown.Acquire">
            <summary>
            <see cref="M:Spring.Threading.ISync.Acquire"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.CountDown.Attempt(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ISync.Attempt(System.Int64)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.CountDown.Release">
            <summary> Decrement the count.
            After the initialCount'th release, all current and future
            acquires will pass
            </summary>
        </member>
        <member name="P:Spring.Threading.CountDown.InitialCount">
            <summary>
            Gets the initial count.
            </summary>
            <value></value>
        </member>
        <member name="P:Spring.Threading.CountDown.CurrentCount">
            <summary>
            Gets the current count.
            </summary>
            <value></value>
        </member>
        <member name="T:Spring.Threading.CyclicBarrier">
            <summary> 
            A synchronization aid that allows a set of threads to all wait for
            each other to reach a common barrier point.  
            </summary>
            <remarks>
            <para>
            <see cref="T:Spring.Threading.CyclicBarrier"/>s are useful in programs involving a fixed 
            sized party of threads that must occasionally wait for each other. 
            The barrier is called <i>cyclic</i> because it can be re-used after 
            the waiting threads are released.
            </para>
            <para>
            A <see cref="T:Spring.Threading.CyclicBarrier"/> supports an optional <see cref="T:System.Action"/>
            or <see cref="T:Spring.Threading.IRunnable"/> command that is run once per barrier point, 
            after the last thread in the party arrives, but before any threads are 
            released. This <i>barrier action</i> is useful for updating 
            shared-state before any of the parties continue.
            </para>
            <para>
            The <see cref="T:Spring.Threading.CyclicBarrier"/> uses an all-or-none breakage model
            for failed synchronization attempts: If a thread leaves a barrier
            point prematurely because of interruption, failure, or timeout, all
            other threads waiting at that barrier point will also leave
            abnormally via <see cref="T:Spring.Threading.BrokenBarrierException"/> (or
            <see cref="T:System.Threading.ThreadInterruptedException"/> if they too were interrupted 
            at about the same time).
            </para>
            </remarks>
            <example>
            <para>
            <b>Sample usage:</b> Here is an example of using a barrier in a 
            parallel decomposition design:
            </para>
            <code language="c#">
            public class Solver {
            	int N;
            	float[][] data;
            	CyclicBarrier barrier;
            
            	internal class Worker : IRunnable {
            		int myRow;
            		Worker(int row) { myRow = row; }
            		public void Run() {
            				while (!IsDone) {
            					processRow(myRow);
            
            					try {
            						barrier.Await();
            					} catch (ThreadInterruptedException ex) {
            						return;
            					} catch (BrokenBarrierException ex) {
            						return;
            					}
            				}
            		}
            		private void processRow(int myRow ) {
            			// Process row....
            		}
            		private bool IsDone { get { ..... } }
            	}
            	private void MergeRows() {
            		// Merge Rows.....
            	}
            	public Solver(float[][] matrix) {
            		data = matrix;
            		N = matrix.length;
            		barrier = new CyclicBarrier(N, MergeRows);
            		for (int i = 0; i &lt; N; ++i)
            			new Thread(new ThreadStart(new Worker(i).Run)).Start();
            
            		WaitUntilDone();
            	}
            }
            </code>
            <para>
            Here, each worker thread processes a row of the matrix then waits at 
            the barrier until all rows have been processed. When all rows are 
            processed the supplied barrier action is executed and merges the rows. 
            If the merger determines that a solution has been found then IsDone 
            will return <c>true</c> and each worker will terminate. 
            </para>
            <para>
            If the barrier action does not rely on the parties being suspended when
            it is executed, then any of the threads in the party could execute that
            action when it is released. To facilitate this, each invocation of
            <see cref="M:Spring.Threading.CyclicBarrier.Await"/> returns the arrival index of that thread at the 
            barrier. You can then choose which thread should execute the barrier 
            action, for example:
            </para>
            <code language="c#">
            if (barrier.Await() == 0) {
            	// log the completion of this iteration
            }
            </code>
            </example>
            <seealso cref="T:Spring.Threading.CountDownLatch"/>
            <author>Doug Lea</author>
            <author>Federico Spinazzi (.Net)</author>
            <author>Griffin Caprio (.Net)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.IBarrier">
            <summary> 
            Barriers serve
            as synchronization points for groups of threads that
            must occasionally wait for each other. 
            Barriers may support any of several methods that
            accomplish this synchronization. This interface
            merely expresses their minimal commonalities:    /// 
            <ul>
            <li> Every barrier is defined for a given number
            of <code>parties</code> -- the number of threads
            that must meet at the barrier point. (In all current
            implementations, this
            value is fixed upon construction of the Barrier.)
            </li>
            <li> A barrier can become <code>broken</code> if
            one or more threads leave a barrier point prematurely,
            generally due to interruption or timeout. Corresponding
            synchronization methods in barriers fail, throwing
            BrokenBarrierException for other threads
            when barriers are in broken states.
            </li>
            </ul>
            
            </summary>
        </member>
        <member name="P:Spring.Threading.IBarrier.Parties">
            <summary> 
            Return the number of parties that must meet per barrier
            point. The number of parties is always at least 1.
            </summary>
        </member>
        <member name="P:Spring.Threading.IBarrier.IsBroken">
            <summary> 
            Returns true if the barrier has been compromised
            by threads leaving the barrier before a synchronization
            point (normally due to interruption or timeout). 
            </summary>
            <remarks>
            Barrier methods in implementation classes
            throw <see cref="T:Spring.Threading.BrokenBarrierException"/> upon detection of breakage.
            Implementations may also support some means
            to clear this status.
            </remarks>
        </member>
        <member name="F:Spring.Threading.CyclicBarrier._lock">
            <summary>The lock for guarding barrier entry </summary>
        </member>
        <member name="F:Spring.Threading.CyclicBarrier._trip">
            <summary> Condition to wait on until tripped </summary>
        </member>
        <member name="F:Spring.Threading.CyclicBarrier._parties">
            <summary>The number of parties </summary>
        </member>
        <member name="F:Spring.Threading.CyclicBarrier._barrierCommand">
            <summary>  The <see cref="T:System.Action"/> to run when tripped </summary>
        </member>
        <member name="F:Spring.Threading.CyclicBarrier._generation">
            <summary>The current generation </summary>
        </member>
        <member name="F:Spring.Threading.CyclicBarrier._count">
            <summary> 
            Number of parties yet to arrive. Counts down from 
            <see cref="P:Spring.Threading.CyclicBarrier.Parties"/> to 0 on each generation.  It is reset to 
            <see cref="P:Spring.Threading.CyclicBarrier.Parties"/> on each new generation or when broken.
            </summary>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.#ctor(System.Int32,Spring.Threading.IRunnable)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.CyclicBarrier"/> that will trip when the
            given number of <paramref name="parties"/> (threads) are waiting 
            upon it, and which will execute the given barrier action when the 
            barrier is tripped, performed by the last thread entering the 
            barrier.
            </summary>
            <param name="parties">
            The number of threads that must invoke <see cref="M:Spring.Threading.CyclicBarrier.Await"/> or
            <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/> before the barrier is tripped.
            </param>
            <param name="barrierAction">
            The <see cref="T:Spring.Threading.IRunnable"/> to execute when the barrier is
            tripped, or <c>null</c>  if there is no action.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="parties"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.#ctor(System.Int32,System.Action)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.CyclicBarrier"/> that will trip when the
            given number of <paramref name="parties"/> (threads) are waiting 
            upon it, and which will execute the given barrier action when the 
            barrier is tripped, performed by the last thread entering the 
            barrier.
            </summary>
            <param name="parties">
            The number of threads that must invoke <see cref="M:Spring.Threading.CyclicBarrier.Await"/> or
            <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/> before the barrier is tripped.
            </param>
            <param name="barrierAction">
            The <see cref="T:System.Action"/> delegate to execute when the barrier is
            tripped, or <c>null</c>  if there is no action.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="parties"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.#ctor(System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.CyclicBarrier"/> that will trip when the
            given number of <paramref name="parties"/> (threads) are waiting 
            upon it, and does not perform a predefined action when the barrier 
            is tripped.
            </summary>
            <param name="parties">
            The number of threads that must invoke <see cref="M:Spring.Threading.CyclicBarrier.Await"/> or
            <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/> before the barrier is tripped.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="parties"/> is less than 1.
            </exception>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.Await">
            <summary> 
            Waits until all <see cref="P:Spring.Threading.CyclicBarrier.Parties"/> have invoked 
            <see cref="M:Spring.Threading.CyclicBarrier.Await"/> or <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/>
            on this barrier.
            </summary>
            <remarks> 
            <para>
            If the current thread is not the last to arrive then it is
            disabled for thread scheduling purposes and lies dormant until
            one of following things happens:
            </para>
            <list type="bullet">
            <item>The last thread arrives</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt">interrupts</see> 
            the current thread</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt">interrupts</see>
            one of the other waiting threads</item>
            <item>Some other thread times out while waiting for barrier</item>
            <item>Some other thread invokes <see cref="M:Spring.Threading.CyclicBarrier.Reset"/> on this barrier.</item>
            </list>
            <para>
            If current thread is <see cref="M:System.Threading.Thread.Interrupt">interrupted</see>
            while waiting, a <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown.
            </para>
            <para>
            If the barrier <see cref="M:Spring.Threading.CyclicBarrier.Reset"/> while any thread is waiting, 
            or if the barrier <see cref="P:Spring.Threading.CyclicBarrier.IsBroken"/> when <see cref="M:Spring.Threading.CyclicBarrier.Await"/> 
            or <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/> is invoked, or while any 
            thread is waiting, then a <see cref="T:Spring.Threading.BrokenBarrierException"/> is 
            thrown.
            </para>
            <para>
            If any thread is interrupted while waiting, then all other waiting 
            threads will throw <see cref="T:Spring.Threading.BrokenBarrierException"/> and the 
            barrier is placed in the broken state.
            </para>
            <para>
            If the current thread is the last thread to arrive, and a non-null 
            barrier action was supplied in the constructor, then the current 
            thread runs the action before allowing the other threads to
            continue. If an exception occurs during the barrier action then that 
            exception will be propagated in the current thread and the barrier 
            is placed in the broken state.
            </para>
            </remarks>
            <returns>
            The arrival index of the current thread, where an index of 
            <see cref="P:Spring.Threading.CyclicBarrier.Parties"/> - 1 indicates the first to arrive and zero 
            indicates the last to arrive.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread was interrupted.
            </exception>
            <exception cref="T:Spring.Threading.BrokenBarrierException">
            If <b>another</b> thread was interrupted or timed out while the 
            current thread was waiting, or the barrier was reset, or the 
            barrier was broken when <see cref="M:Spring.Threading.CyclicBarrier.Await"/> was called, or the 
            barrier action (if present) failed due to an exception.
            </exception>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)">
            <summary> 
            Waits until all <see cref="P:Spring.Threading.CyclicBarrier.Parties"/> have invoked 
            <see cref="M:Spring.Threading.CyclicBarrier.Await"/> or <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/>
            on this barrier.
            </summary>
            <remarks> 
            <para>
            If the current thread is not the last to arrive then it is
            disabled for thread scheduling purposes and lies dormant until
            one of following things happens:
            </para>
            <list type="bullet">
            <item>The last thread arrives</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt">interrupts</see> 
            the current thread</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt">interrupts</see>
            one of the other waiting threads</item>
            <item>Some other thread times out while waiting for barrier</item>
            <item>Some other thread invokes <see cref="M:Spring.Threading.CyclicBarrier.Reset"/> on this barrier.</item>
            </list>
            <para>
            If current thread is <see cref="M:System.Threading.Thread.Interrupt">interrupted</see>
            while waiting, a <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown.
            </para>
            <para>
            If the specified <paramref name="durationToWait"/> elapses then a 
            <see cref="T:Spring.Threading.TimeoutException"/> is thrown. If the time is less than 
            or equal to zero, the method will not wait at all.
            </para>
            <para>
            If the barrier <see cref="M:Spring.Threading.CyclicBarrier.Reset"/> while any thread is waiting, 
            or if the barrier <see cref="P:Spring.Threading.CyclicBarrier.IsBroken"/> when <see cref="M:Spring.Threading.CyclicBarrier.Await"/> 
            or <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/> is invoked, or while any 
            thread is waiting, then a <see cref="T:Spring.Threading.BrokenBarrierException"/> is 
            thrown.
            </para>
            <para>
            If any thread is interrupted while waiting, then all other waiting 
            threads will throw <see cref="T:Spring.Threading.BrokenBarrierException"/> and the 
            barrier is placed in the broken state.
            </para>
            <para>
            If the current thread is the last thread to arrive, and a non-null 
            barrier action was supplied in the constructor, then the current 
            thread runs the action before allowing the other threads to
            continue. If an exception occurs during the barrier action then that 
            exception will be propagated in the current thread and the barrier 
            is placed in the broken state.
            </para>
            </remarks>
            <param name="durationToWait">The time to wait for barrier.</param>
            <returns>
            The arrival index of the current thread, where an index of 
            <see cref="P:Spring.Threading.CyclicBarrier.Parties"/> - 1 indicates the first to arrive and zero 
            indicates the last to arrive.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread was interrupted.
            </exception>
            <exception cref="T:Spring.Threading.BrokenBarrierException">
            If <b>another</b> thread was interrupted or timed out while the 
            current thread was waiting, or the barrier was reset, or the 
            barrier was broken when <see cref="M:Spring.Threading.CyclicBarrier.Await(System.TimeSpan)"/> was 
            called, or the barrier action (if present) failed due to an 
            exception.
            </exception>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.Reset">
            <summary> 
            Resets the barrier to its initial state.  
            </summary>
            <remarks>
            If any parties are currently waiting at the barrier, they will
            return with a <see cref="T:Spring.Threading.BrokenBarrierException"/>. Note that 
            resets <b>after</b> a breakage has occurred for other reasons 
            can be complicated to carry out; threads need to re-synchronize 
            in some other way, and choose one to perform the reset.  It may 
            be preferable to instead create a new barrier for subsequent use.
            </remarks>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.NextGeneration">
            <summary> 
            Updates state on barrier trip and wakes up everyone.
            Called only while holding lock.
            </summary>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.BreakBarrier">
            <summary> 
            Sets current barrier generation as broken and wakes up everyone.
            Called only while holding lock.
            </summary>
        </member>
        <member name="M:Spring.Threading.CyclicBarrier.DoWait(System.Boolean,System.TimeSpan)">
            <summary> Main barrier code, covering the various policies.</summary>
        </member>
        <member name="P:Spring.Threading.CyclicBarrier.Parties">
            <summary> 
            Return the number of parties that must meet per barrier
            point. The number of parties is always at least 1.
            </summary>
        </member>
        <member name="P:Spring.Threading.CyclicBarrier.IsBroken">
            <summary> 
            Queries if this barrier is in a broken state. Return <c>true</c> 
            if one or more parties broke out of this barrier due to timeout
            or interruption since construction or the last reset, or a barrier 
            action failed due to an exception; <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Spring.Threading.CyclicBarrier.NumberOfWaitingParties">
            <summary> 
            Returns the number of parties currently waiting at the barrier.
            This method is primarily useful for debugging and assertions.
            </summary>
        </member>
        <member name="T:Spring.Threading.CyclicBarrier.Generation">
            <summary> 
            Each use of the barrier is represented as a generation instance.
            </summary>
            <remarks>
            The generation changes whenever the barrier is tripped, or
            is reset. There can be many generations associated with threads
            using the barrier - due to the non-deterministic way the lock
            may be allocated to waiting threads - but only one of these
            can be active at a time and all the rest are either broken or tripped.
            There need not be an active generation if there has been a break
            but no subsequent reset.
            </remarks>
        </member>
        <member name="T:Spring.Threading.DefaultChannelCapacity">
            <summary> A utility class to set the default capacity of
            <see cref="T:Spring.Threading.IBoundedChannel"></see>
            implementations that otherwise require a capacity argument
            </summary>
            <seealso cref="T:Spring.Threading.IBoundedChannel"/>
            <remarks>Not intended to be used outside <c>Spring.NET</c></remarks>
        </member>
        <member name="F:Spring.Threading.DefaultChannelCapacity.InitialDefaultCapacity">
            <summary>The initial value of the default capacity is 1024 *</summary>
        </member>
        <member name="F:Spring.Threading.DefaultChannelCapacity.defaultCapacity_">
            <summary>the current default capacity *</summary>
        </member>
        <member name="P:Spring.Threading.DefaultChannelCapacity.DefaultCapacity">
            <summary> The default capacity used in 
            default (no-argument) constructor for BoundedChannels
            that otherwise require a capacity argument.
            </summary>
            <exception cref="T:System.ArgumentException"> if capacity less or equal to zero
            </exception>
        </member>
        <member name="T:Spring.Threading.DirectExecutor">
            <summary> 
            An implementation of <see cref="T:Spring.Threading.IExecutor"/> that 
            invokes the run method of the supplied command and then returns.
            </summary>
        </member>
        <member name="T:Spring.Threading.IExecutor">
            <summary> 
            An object that executes submitted <see cref="T:Spring.Threading.IRunnable"/> tasks
            or an <see cref="T:System.Action"/>.
            </summary>
            <remarks> 
            This interface provides a way of decoupling task submission from the
            mechanics of how each task will be run, including details of thread
            use, scheduling, etc.  An <see cref="T:Spring.Threading.IExecutor"/> is normally used
            instead of explicitly creating threads.
            <p/>
            However, the <see cref="T:Spring.Threading.IExecutor"/> interface does not strictly
            require that execution be asynchronous. In the simplest case, an
            executor can run the submitted task immediately in the caller's
            thread:
            
            <code language="c#">
            class DirectExecutor : IExecutor {
            	public void Execute(IRunnable r) {
            		r.Run();
            	}
                public void Execute(Action task) {
                    task();
                }
            }
            </code>
            <p/> 
            More typically, tasks are executed in some thread other
            than the caller's thread.  The executor below spawns a new thread
            for each task.
            
            <code language="c#">
            class ThreadPerTaskExecutor : IExecutor {
            	public void Execute(IRunnable r) {
            		new Thread(new ThreadStart(r.Run)).Start();
            	}
                public void Execute(Action task) {
                    new Thread(new ThreadStart(task)).Start();
                }
            }
            </code>
            
            Many <see cref="T:Spring.Threading.IExecutor"/> implementations impose some sort of
            limitation on how and when tasks are scheduled. 
            <p/>
            The <see cref="T:Spring.Threading.IExecutor"/> implementations provided in this package
            implement <see cref="T:Spring.Threading.Execution.IExecutorService"/>, which is a more extensive
            interface.  The <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> class provides an
            extensible thread pool implementation. The <see cref="T:Spring.Threading.Execution.Executors"/> class
            provides convenient factory methods for these Executors.
            </remarks>
            <author>Doug Lea</author>
            <author>Federico Spinazzi (.Net)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.IExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> 
            Executes the given command at some time in the future.
            </summary>
            <remarks>
            The command may execute in a new thread, in a pooled thread, or in the calling
            thread, at the discretion of the <see cref="T:Spring.Threading.IExecutor"/> implementation.
            </remarks>
            <param name="command">the runnable task</param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.IExecutor.Execute(System.Action)">
            <summary> 
            Executes the given task at some time in the future.
            </summary>
            <remarks>
            The task may execute in a new thread, in a pooled thread, or in the calling
            thread, at the discretion of the <see cref="T:Spring.Threading.IExecutor"/> implementation.
            </remarks>
            <param name="action">The task to be executed.</param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>
            </exception>
        </member>
        <member name="M:Spring.Threading.DirectExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> Execute the given command directly in the current thread.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.DirectExecutor.Execute(System.Action)">
            <summary>
            Execute the given task directly in the current thread.
            </summary>
            <param name="action">
            The task to be executed.
            </param>
        </member>
        <member name="T:Spring.Threading.Execution.AbstractExecutorService">
            <summary> 
            Provides default implementations of <see cref="T:Spring.Threading.Execution.IExecutorService"/>
            execution methods. 
            </summary>
            <remarks> 
            This class implements the <see cref="T:Spring.Threading.Execution.IExecutorService"/> methods using a
            <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> returned by NewTaskFor
            , which defaults to the <see cref="T:Spring.Threading.Future.FutureTask`1"/> class provided in this package.  
            <p/>
            For example, the implementation of <see cref="M:Spring.Threading.Execution.IExecutorService.Submit(Spring.Threading.IRunnable)"/> creates an
            associated <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> that is executed and
            returned. Subclasses may override the NewTaskFor methods
            to return <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> implementations other than
            <see cref="T:Spring.Threading.Future.FutureTask`1"/>.
            
            <p/> 
            <b>Extension example</b>. 
            Here is a sketch of a class
            that customizes <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> to use
            a custom Task class instead of the default <see cref="T:Spring.Threading.Future.FutureTask`1"/>:
            <code>
            public class CustomThreadPoolExecutor : ThreadPoolExecutor {
            	class CustomTask : IRunnableFuture {...}
            
            	protected IRunnableFuture newTaskFor(ICallable c) {
            		return new CustomTask(c);
            	}
            	protected IRunnableFuture newTaskFor(IRunnable r) {
            		return new CustomTask(r);
            	}
            	// ... add constructors, etc.
            }
            </code>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio(.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Execution.IExecutorService">
            <summary> 
            An <see cref="T:Spring.Threading.IExecutor"/> that provides methods to manage termination and
            methods that can produce a <see cref="T:Spring.Threading.Future.IFuture`1"/> for tracking progress of
            one or more asynchronous tasks.
            </summary>
            <remarks>
            An <see cref="T:Spring.Threading.Execution.IExecutorService"/> can be shut down, which will cause it
            to stop accepting new tasks.  After being shut down, the executor
            will eventually terminate, at which point no tasks are actively
            executing, no tasks are awaiting execution, and no new tasks can be
            submitted.
            
            <p/> 
            Method <see cref="M:Spring.Threading.Execution.IExecutorService.Submit``1(Spring.Threading.ICallable{``0})"/> extends base method 
            <see cref="M:Spring.Threading.IExecutor.Execute(Spring.Threading.IRunnable)"/> by creating and returning a <see cref="T:Spring.Threading.Future.IFuture`1"/> that
            can be used to cancel execution and/or wait for completion.
            Methods <see cref="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})"/> and <see cref="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})"/>
            perform the most commonly useful forms of bulk execution, executing a collection of
            tasks and then waiting for at least one, or all, to
            complete. (Class <see cref="T:Spring.Threading.Execution.ExecutorCompletionService`1"/> can be used to
            write customized variants of these methods.)
            
            <p/>
            The <see cref="T:Spring.Threading.Execution.Executors"/> class provides factory methods for the
            executor services provided in this package.
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Shutdown">
            <summary> 
            Initiates an orderly shutdown in which previously submitted
            tasks are executed, but no new tasks will be
            accepted. Invocation has no additional effect if already shut
            down.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.ShutdownNow">
            <summary> 
            Attempts to stop all actively executing tasks, halts the
            processing of waiting tasks, and returns a list of the tasks that were
            awaiting execution.
            </summary>
            <remarks> 
            There are no guarantees beyond best-effort attempts to stop
            processing actively executing tasks.  For example, typical
            implementations will cancel via <see cref="M:System.Threading.Thread.Interrupt"/>, so if any
            tasks mask or fail to respond to interrupts, they may never terminate.
            </remarks>
            <returns> list of tasks that never commenced execution</returns>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.AwaitTermination(System.TimeSpan)">
            <summary> 
            Blocks until all tasks have completed execution after a shutdown
            request, or the timeout occurs, or the current thread is
            interrupted, whichever happens first. 
            </summary>
            <param name="timeSpan">the time span to wait.
            </param>
            <returns> <c>true</c> if this executor terminated and <c>false</c>
            if the timeout elapsed before termination
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Submit(Spring.Threading.IRunnable)">
            <summary> 
            Submits a Runnable task for execution and returns a Future
            representing that task. The Future's <see cref="M:Spring.Threading.Future.IFuture.GetResult"/> method will
            return <c>null</c> upon successful completion.
            </summary>
            <param name="runnable">the task to submit
            </param>
            <returns> a Future representing pending completion of the task
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Submit(System.Action)">
            <summary> 
            Submits a delegate <see cref="T:System.Action"/> for execution and returns an
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="action"/>. The 
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return <c>null</c>.
            </summary>
            <param name="action">The task to submit.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            <paramref name="action"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="action"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Submit``1(Spring.Threading.IRunnable,``0)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.IRunnable"/> task for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="runnable"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            given <paramref name="result"/> upon successful completion.
            </summary>
            <param name="runnable">The task to submit.</param>
            <param name="result">The result to return.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="runnable"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="runnable"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="runnable"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Submit``1(System.Action,``0)">
            <summary> 
            Submits a delegate <see cref="T:System.Action"/> for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="action"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            given <paramref name="result"/> upon successful completion.
            </summary>
            <param name="action">The task to submit.</param>
            <param name="result">The result to return.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="action"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="action"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Submit``1(Spring.Threading.ICallable{``0})">
            <summary> 
            Submits a <see cref="T:Spring.Threading.ICallable`1"/> for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="callable"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            result of <see cref="M:Spring.Threading.ICallable`1.Call"/> upon successful completion.
            </summary>
            <param name="callable">The task to submit.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="callable"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="callable"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="callable"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.Submit``1(System.Func{``0})">
            <summary> 
            Submits a delegate <see cref="T:System.Func`1"/> for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="call"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            result of <paramref name="call"/><c>()</c> upon successful completion.
            </summary>
            <param name="call">The task to submit.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="call"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="call"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="call"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.TimeSpan,Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAll``1(System.TimeSpan,System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the enumerator for the given 
            task list, each of which has completed successfully.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.TimeSpan,Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAllOrFail``1(System.TimeSpan,System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.TimeSpan,Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.IExecutorService.InvokeAny``1(System.TimeSpan,System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="P:Spring.Threading.Execution.IExecutorService.IsShutdown">
            <summary> 
            Returns <c>true</c> if this executor has been shut down.
            </summary>
            <returns> 
            Returns <c>true</c> if this executor has been shut down.
            </returns>
        </member>
        <member name="P:Spring.Threading.Execution.IExecutorService.IsTerminated">
            <summary> 
            Returns <c>true</c> if all tasks have completed following shut down.
            </summary>
            <remarks>
            Note that this will never return <c>true</c> unless
            either <see cref="M:Spring.Threading.Execution.IExecutorService.Shutdown"/> or 
            <see cref="M:Spring.Threading.Execution.IExecutorService.ShutdownNow"/> was called first.
            </remarks>
            <returns> <c>true</c> if all tasks have completed following shut down
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Dispose">
            <summary>
            Calls <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Shutdown"/> to complete all pending tasks and shutdown service.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Shutdown">
            <summary> 
            Initiates an orderly shutdown in which previously submitted
            tasks are executed, but no new tasks will be
            accepted. Invocation has no additional effect if already shut
            down.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.ShutdownNow">
            <summary> 
            Attempts to stop all actively executing tasks, halts the
            processing of waiting tasks, and returns a list of the tasks that were
            awaiting execution.
            </summary>
            <remarks> 
            There are no guarantees beyond best-effort attempts to stop
            processing actively executing tasks.  For example, typical
            implementations will cancel via <see cref="M:System.Threading.Thread.Interrupt"/>, so if any
            tasks mask or fail to respond to interrupts, they may never terminate.
            </remarks>
            <returns> list of tasks that never commenced execution</returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.DoExecute(Spring.Threading.IRunnable)">
            <summary> 
            Executes the given task sometime in the future.  The task may 
            execute in a new thread or in an existing pooled thread.
            </summary>
            <remarks>
            If the task cannot be submitted for execution, either because this
            executor has been shutdown or because its capacity has been reached,
            the task is handled by the current <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/>
            for this <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/>.
            </remarks>
            <param name="command">the task to execute</param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            if the task cannot be accepted. 
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="command"/> is <c>null</c>
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.AwaitTermination(System.TimeSpan)">
            <summary> 
            Blocks until all tasks have completed execution after a shutdown
            request, or the timeout occurs, or the current thread is
            interrupted, whichever happens first. 
            </summary>
            <param name="timeSpan">the time span to wait.
            </param>
            <returns> <c>true</c> if this executor terminated and <c>false</c>
            if the timeout elapsed before termination
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Execute(System.Action)">
            <summary> 
            Executes the given task at some time in the future.
            </summary>
            <remarks>
            The task may execute in a new thread, in a pooled thread, or in the calling
            thread, at the discretion of the <see cref="T:Spring.Threading.IExecutor"/> implementation.
            </remarks>
            <param name="action">The task to be executed.</param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)">
            <summary> 
            Executes the given command at some time in the future.
            </summary>
            <remarks>
            The command may execute in a new thread, in a pooled thread, or in the calling
            thread, at the discretion of the <see cref="T:Spring.Threading.IExecutor"/> implementation.
            </remarks>
            <param name="runnable">the runnable task</param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>	
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Submit(Spring.Threading.IRunnable)">
            <summary> 
            Submits a Runnable task for execution and returns a Future
            representing that task. The Future's <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will
            return <c>null</c> upon successful completion.
            </summary>
            <param name="runnable">the task to submit
            </param>
            <returns> a Future representing pending completion of the task
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Submit(System.Action)">
            <summary> 
            Submits a delegate <see cref="T:System.Action"/> for execution and returns an
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="action"/>. The 
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return <c>null</c>.
            </summary>
            <param name="action">The task to submit.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            <paramref name="action"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="action"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Submit``1(System.Func{``0})">
            <summary> 
            Submits a delegate <see cref="T:System.Func`1"/> for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="call"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            result of <paramref name="call"/><c>()</c> upon successful completion.
            </summary>
            <param name="call">The task to submit.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="call"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="call"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="call"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Submit``1(System.Action,``0)">
            <summary> 
            Submits a delegate <see cref="T:System.Action"/> for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="action"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            given <paramref name="result"/> upon successful completion.
            </summary>
            <param name="action">The task to submit.</param>
            <param name="result">The result to return.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="action"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="action"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Submit``1(Spring.Threading.ICallable{``0})">
            <summary> 
            Submits a <see cref="T:Spring.Threading.ICallable`1"/> for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="callable"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            result of <see cref="M:Spring.Threading.ICallable`1.Call"/> upon successful completion.
            </summary>
            <param name="callable">The task to submit.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="callable"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="callable"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="callable"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.Submit``1(Spring.Threading.IRunnable,``0)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.IRunnable"/> task for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that <paramref name="runnable"/>. 
            The <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return the 
            given <paramref name="result"/> upon successful completion.
            </summary>
            <param name="runnable">The task to submit.</param>
            <param name="result">The result to return.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the
            <paramref name="runnable"/>.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the <paramref name="runnable"/> cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="runnable"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.TimeSpan,Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAny``1(System.TimeSpan,System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given 
            <paramref name="durationToWait"/> elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, <paramref name="tasks"/> that 
            have not completed are cancelled.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </remarks>
            <typeparam name="T">
            The type of the result to be returned.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>The result returned by one of the tasks.</returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.TimeSpan,Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAll``1(System.TimeSpan,System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their status and results when all complete or the
            <paramref name="durationToWait"/> expires, whichever happens
            first.
            </summary>
            <remarks>
            <para>
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> is <c>true</c> for each element of 
            the returned list.
            </para>
            <para>
            Note: 
            A <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the enumerator for the given 
            task list, each of which has completed successfully.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully or throws
            exception when any one fails.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list, each of which has completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.TimeSpan,Spring.Threading.ICallable{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:Spring.Threading.ICallable`1"/> objects.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Func{``0}})">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.InvokeAllOrFail``1(System.TimeSpan,System.Func{``0}[])">
            <summary> 
            Executes the given <paramref name="tasks"/>, returning a 
            <see cref="T:System.Collections.Generic.IList`1">list</see> of <see cref="T:Spring.Threading.Future.IFuture`1"/>s 
            holding their results when all complete successfully, or throws
            exception when <paramref name="durationToWait"/> expires or any 
            one task fails, whichever happens first.
            </summary>
            <remarks>
            <para>
            Upon successful return, <see cref="P:Spring.Threading.ICancellable.IsDone"/> is 
            <c>true</c> and <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> is guaranteed
            to success for each element of the returned list.
            </para>
            <para>
            Note: 
            The method returns immediately when any one of the tasks throws 
            exception. When this happens, all uncompleted tasks are cancelled
            and the exception is thrown.
            The results of this method are undefined if the given
            enumerable is modified while this operation is in progress.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the result to be returned by <see cref="T:Spring.Threading.Future.IFuture`1"/>.
            </typeparam>
            <param name="tasks">
            The <see cref="T:System.Collections.Generic.IEnumerable`1">enumeration</see> of 
            <see cref="T:System.Func`1"/> delegates.
            </param>
            <param name="durationToWait">The time span to wait.</param> 
            <returns>
            A list of <see cref="T:Spring.Threading.Future.IFuture`1"/>s representing the tasks, in the 
            same sequential order as produced by the iterator for the given 
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the any of the <paramref name="tasks"/> cannot be accepted for 
            execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="tasks"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.NewTaskFor``1(Spring.Threading.IRunnable,``0)">
            <summary> 
            Returns a <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> for the given 
            <paramref name="runnable"/> and default value <paramref name="result"/>.
            </summary>
            <param name="runnable">the runnable task being wrapped
            </param>
            <param name="result">the default value for the returned future
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> which, when run, will run the
            underlying runnable and which, as a <see cref="T:Spring.Threading.Future.IFuture`1"/>, will yield
            the given value as its result and provide for cancellation of
            the underlying task.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.NewTaskFor``1(System.Action,``0)">
            <summary> 
            Returns a <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> for the given 
            <paramref name="action"/> and default value <paramref name="result"/>.
            </summary>
            <param name="action">the action being wrapped
            </param>
            <param name="result">the default value for the returned future
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> which, when run, will invoke the
            underlying action and which, as a <see cref="T:Spring.Threading.Future.IFuture`1"/>, will yield
            the given value as its result and provide for cancellation of
            the underlying task.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.NewTaskFor``1(System.Func{``0})">
            <summary> 
            Returns a <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> for the given 
            <paramref name="call"/> delegate.
            </summary>
            <param name="call">
            The <see cref="T:System.Func`1"/> delegate being wrapped.
            </param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> which when run will call the
            underlying <paramref name="call"/> delegate and which, as a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/>, will yield the result of <c>call</c>as 
            its result and provide for cancellation of the underlying task.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.NewTaskFor``1(Spring.Threading.ICallable{``0})">
            <summary> 
            Returns a <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> for the given 
            <paramref name="callable"/> task.
            </summary>
            <param name="callable">The callable task being wrapped.</param>
            <returns>
            An <see cref="T:Spring.Threading.Future.IRunnableFuture`1"/> which when run will call the
            underlying <paramref name="callable"/> and which, as a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/>, will yield the callable's result as its 
            result and provide for cancellation of the underlying task.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.NewContextCarrier">
            <summary>
            Create a new <see cref="T:Spring.Threading.IContextCarrier"/>.
            </summary>
            <returns>
            A new <see cref="T:Spring.Threading.IContextCarrier"/> instance or <c>null</c>
            if <see cref="P:Spring.Threading.Execution.AbstractExecutorService.ContextCarrierFactory"/> is not set.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.OnThreadException(Spring.Threading.IRunnable,System.Exception)">
            <summary>
            Raises the <see cref="E:Spring.Threading.Execution.AbstractExecutorService.ThreadException"/> event.
            </summary>
            <param name="sender">
            The task that raised the exception.
            </param>
            <param name="exception">
            The exception object.
            </param>
        </member>
        <member name="M:Spring.Threading.Execution.AbstractExecutorService.CaptureContext(Spring.Threading.IRunnable)">
            <summary>
            If <paramref name="command"/> is <see cref="T:Spring.Threading.IContextCopyingTask"/>
            and the context carrier is already set, do nothing. Otherwise set
            a new context carrier.
            </summary>
        </member>
        <member name="P:Spring.Threading.Execution.AbstractExecutorService.ContextCarrierFactory">
            <summary>
            Gets and sets the context carrier factory
            </summary>
        </member>
        <member name="E:Spring.Threading.Execution.AbstractExecutorService.ThreadException">
            <summary>
            Occurs when an untrapped thread exception is thrown.
            </summary>
        </member>
        <member name="P:Spring.Threading.Execution.AbstractExecutorService.IsTerminated">
            <summary> 
            Returns <c>true</c> if all tasks have completed following shut down.
            </summary>
            <remarks>
            Note that this will never return <c>true</c> unless
            either <see cref="M:Spring.Threading.Execution.IExecutorService.Shutdown"/> or 
            <see cref="M:Spring.Threading.Execution.IExecutorService.ShutdownNow"/> was called first.
            </remarks>
            <returns> <c>true</c> if all tasks have completed following shut down
            </returns>
        </member>
        <member name="P:Spring.Threading.Execution.AbstractExecutorService.IsShutdown">
            <summary> 
            Returns <c>true</c> if this executor has been shut down.
            </summary>
            <returns> 
            Returns <c>true</c> if this executor has been shut down.
            </returns>
        </member>
        <member name="T:Spring.Threading.Execution.CancellationException">
            <summary> 
            Exception indicating that the result of a value-producing task,
            such as a <see cref="T:Spring.Threading.Future.FutureTask`1"/>, cannot be retrieved because the task
            was cancelled.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Execution.CancellationException.#ctor">
            <summary>Creates a new instance of the <see cref="T:Spring.Threading.Execution.CancellationException"/> class.</summary>.
        </member>
        <member name="M:Spring.Threading.Execution.CancellationException.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Threading.Execution.CancellationException"/> class. with the specified message.
            </summary>
            <param name="message">A message about the exception.</param>
        </member>
        <member name="M:Spring.Threading.Execution.CancellationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Threading.Execution.CancellationException"/> class with the specified message
            and root cause.
            </summary>
            <param name="message">A message about the exception.</param>
            <param name="rootCause">The root exception that is being wrapped.</param>
        </member>
        <member name="M:Spring.Threading.Execution.CancellationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Threading.Execution.CancellationException"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
            that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/>
            that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:Spring.Threading.Execution.ExecutionException">
            <summary> 
            Exception thrown when attempting to retrieve the result of a task
            that aborted by throwing an exception. 
            </summary>
            <seealso cref="T:Spring.Threading.Future.IFuture`1"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutionException.#ctor">
            <summary> Constructs a <see cref="T:Spring.Threading.Execution.ExecutionException"/> with no detail message.</summary>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutionException.#ctor(System.String)">
            <summary> Constructs a <see cref="T:Spring.Threading.Execution.ExecutionException"/> with the specified detail message.</summary>
            <param name="message">the detail message</param>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutionException.#ctor(System.String,System.Exception)">
            <summary> Constructs a <see cref="T:Spring.Threading.Execution.ExecutionException"/> with the specified detail message and cause.</summary>
            <param name="message">the detail message</param>
            <param name="cause">the cause (which is saved for later retrieval by the</param>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutionException.#ctor(System.Exception)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.Execution.ExecutionException"/> with the specified cause.
            </summary>
            <param name="rootCause">The root exception that is being wrapped.</param>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Threading.Execution.ExecutionException"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
            that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/>
            that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:Spring.Threading.Execution.ExecutorCompletionService`1">
             <summary> 
             A <see cref="T:Spring.Threading.Execution.ICompletionService`1"/> that uses a supplied <see cref="T:Spring.Threading.IExecutor"/>
             to execute tasks.  
             </summary>
             <remarks>
             <para>
             This class arranges that submitted tasks are, upon completion, placed 
             on a queue accessible using <see cref="M:Spring.Threading.Execution.ExecutorCompletionService`1.Take"/>. The class is 
             lightweight enough to be suitable for transient use when processing 
             groups of tasks.
             </para>
             <example>
             Usage Examples.
             <para>
             Suppose you have a set of solvers for a certain problem, each 
             returning a value of some type <c>Result</c>, and would like to run 
             them concurrently, processing the results of each of them that
             return a non-null value, in some method <c>Use(Result r)</c>. You
             could write this as:
             </para>
             <code language="c#">
               void Solve(IExecutor e,
                          ICollection&lt;ICallable&lt;Result&gt;&gt; solvers)
               {
                   ICompletionService&lt;Result&gt; ecs
                       = new ExecutorCompletionService&lt;Result&gt;(e);
                   foreach (ICallable&lt;Result&gt; s in solvers)
                       ecs.Submit(s);
                   int n = solvers.size();
                   for (int i = 0; i &lt; n; ++i) {
                       Result r = ecs.Take().GetResult();
                       if (r != null) Use(r);
                   }
               }
             </code>
             <para>
             Suppose instead that you would like to use the first non-null result
             of the set of tasks, ignoring any that encounter exceptions,
             and cancelling all other tasks when the first one is ready:
             </para>
             <code language="c#">
               void Solve(IExecutor e,
                          ICollection&lt;ICallable&lt;Result&gt;&gt; solvers)
               {
                   ICompletionService&lt;Result&gt; ecs
                       = new ExecutorCompletionService&lt;Result&gt;(e);
                   int n = solvers.Count;
                   IList&lt;IFuture&lt;Result&gt;&gt; futures
                       = new List&lt;IFuture&lt;Result&gt;&gt;(n);
                   Result result = null;
                   try {
                       foreach (ICallable&lt;Result&gt; s in solvers)
                           futures.Add(ecs.Submit(s));
                       for (int i = 0; i &lt; n; ++i) {
                           try {
                               Result r = ecs.Take().GetResult();
                               if (r != null) {
                                   result = r;
                                   break;
                               }
                           } catch (ExecutionException ignore) {}
                       }
                   }
                   finally {
                       for (IFuture&lt;Result&gt; f : futures)
                           f.Cancel(true);
                   }
            
                   if (result != null)
                       Use(result);
               }
             </code>
             </example>
             </remarks>
             <author>Doug Lea</author>
             <author>Griffin Caprio (.NET)</author>
             <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="T:Spring.Threading.Execution.ICompletionService`1">
            <summary> 
            A service that decouples the production of new asynchronous tasks from 
            the consumption of the results of completed tasks.  
            </summary>
            <remarks> 
            <para>
            Producers submit tasks for execution. Consumers take completed tasks 
            and process their results in the order they complete.  A 
            <see cref="T:Spring.Threading.Execution.ICompletionService`1"/> can for example be used to manage 
            asynchronous IO, in which tasks that perform reads are submitted in one 
            part of a program or system, and then acted upon in a different part 
            of the program when the reads complete, possibly in a different order 
            than they were requested.
            </para>
            <para>
            Typically, a <see cref="T:Spring.Threading.Execution.ICompletionService`1"/> relies on a separate 
            <see cref="T:Spring.Threading.IExecutor"/> to actually execute the tasks, in which case the
            <see cref="T:Spring.Threading.Execution.ICompletionService`1"/> only manages an internal completion
            queue. The <see cref="T:Spring.Threading.Execution.ExecutorCompletionService`1"/> class provides an
            implementation of this approach.
            </para>
            <para>
            Memory consistency effects: Actions in a thread prior to submitting a 
            task to a <see cref="T:Spring.Threading.Execution.ICompletionService`1"/> <i>happen-before</i> 
            actions taken by that task, which in turn <i>happen-before</i> actions 
            following a successful return from the corresponding <see cref="M:Spring.Threading.Execution.ICompletionService`1.Take"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Submit(Spring.Threading.ICallable{`0})">
            <summary> 
            Submits a value-returning task for execution and returns an instance 
            of <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the pending results of the 
            task. The future's <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the callable's result upon successful completion.
            </summary>
            <remarks>
            <para>
            If you would like to immediately block waiting for a callable, you 
            can use constructions of the form
            <code language="c#">
              result = exec.Submit(aCallable).GetResult();
            </code>
            </para>
            </remarks>
            <param name="callable">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Submit(System.Func{`0})">
            <summary> 
            Submits a value-returning task for execution and returns an instance 
            of <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the pending results of the 
            task. The future's <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the callable's result upon successful completion.
            </summary>
            <remarks>
            <para>
            If you would like to immediately block waiting for a callable, you 
            can use constructions of the form
            <code language="c#">
              result = exec.Submit(aCallable).GetResult();
            </code>
            </para>
            </remarks>
            <param name="call">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Submit(Spring.Threading.IRunnable,`0)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.IRunnable"/> task for execution and returns a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  Upon completion, 
            this task may be taken or polled.
            </summary>
            <param name="runnable">The task to submit.</param>
            <param name="result">
            The result to return upon successful completion.
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Submit(System.Action,`0)">
            <summary> 
            Submits a <see cref="T:System.Action"/> task for execution and returns a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  Upon completion, 
            this task may be taken or polled.
            </summary>
            <param name="action">The task to submit.</param>
            <param name="result">
            The result to return upon successful completion.
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Submit(Spring.Threading.IRunnable)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.IRunnable"/> task for execution and returns 
            a <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  The future's
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> will return <c>default(T)</c>
            upon successful completion.
            </summary>
            <param name="runnable">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Submit(System.Action)">
            <summary> 
            Submits a <see cref="T:System.Action"/> task for execution and returns a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  The future's
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> will return <c>default(T)</c>
            upon successful completion.
            </summary>
            <param name="action">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Take">
            <summary> 
            Retrieves and removes the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing 
            the next completed task, waiting if none are yet present.
            </summary>
            <returns>
            The <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the next completed task.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Poll">
            <summary> 
            Retrieves and removes the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing 
            the next completed task or <c>null</c> if none are present.
            </summary>
            <returns>
            The <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the next completed task, 
            or <c>null</c> if none are present.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ICompletionService`1.Poll(System.TimeSpan)">
            <summary> 
            Retrieves and removes the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the 
            next completed task, waiting, if necessary, up to the specified 
            duration if none are yet present.
            </summary>
            <param name="durationToWait">
            Duration to wait if no completed task is present yet.
            </param>
            <returns> 
            the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the next completed task or
            <c>null</c> if the specified waiting time elapses before one
            is present.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.#ctor(Spring.Threading.IExecutor)">
            <summary> 
            Creates an <see cref="T:Spring.Threading.Execution.ExecutorCompletionService`1"/> using the supplied
            executor for base task execution and a
            <see cref="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1"/> as a completion queue.
            </summary>
            <param name="executor">the executor to use</param>
            <exception cref="T:System.ArgumentNullException">
            if the executor is null
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.#ctor(Spring.Threading.IExecutor,Spring.Threading.Collections.Generic.IBlockingQueue{Spring.Threading.Future.IFuture{`0}})">
            <summary> 
            Creates an <see cref="T:Spring.Threading.Execution.ExecutorCompletionService`1"/> using the supplied
            executor for base task execution and the supplied queue as its
            completion queue.
            </summary>
            <param name="executor">the executor to use</param>
            <param name="completionQueue">the queue to use as the completion queue
            normally one dedicated for use by this service
            </param>
            <exception cref="T:System.ArgumentNullException">
            if the executor is null
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Submit(Spring.Threading.ICallable{`0})">
            <summary> 
            Submits a value-returning task for execution and returns an instance 
            of <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the pending results of the 
            task. The future's <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the callable's result upon successful completion.
            </summary>
            <remarks>
            <para>
            If you would like to immediately block waiting for a callable, you 
            can use constructions of the form
            <code language="c#">
              result = exec.Submit(aCallable).GetResult();
            </code>
            </para>
            </remarks>
            <param name="callable">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Submit(System.Func{`0})">
            <summary> 
            Submits a value-returning task for execution and returns an instance 
            of <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the pending results of the 
            task. The future's <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the callable's result upon successful completion.
            </summary>
            <remarks>
            <para>
            If you would like to immediately block waiting for a callable, you 
            can use constructions of the form
            <code language="c#">
              result = exec.Submit(aCallable).GetResult();
            </code>
            </para>
            </remarks>
            <param name="call">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Submit(Spring.Threading.IRunnable,`0)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.IRunnable"/> task for execution and returns a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  Upon completion, 
            this task may be taken or polled.
            </summary>
            <param name="runnable">The task to submit.</param>
            <param name="result">
            The result to return upon successful completion.
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Submit(System.Action,`0)">
            <summary> 
            Submits a <see cref="T:System.Action"/> task for execution and returns a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  Upon completion, 
            this task may be taken or polled.
            </summary>
            <param name="action">The task to submit.</param>
            <param name="result">
            The result to return upon successful completion.
            </param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Submit(Spring.Threading.IRunnable)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.IRunnable"/> task for execution and returns 
            a <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  The future's
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> will return <c>default(T)</c>
            upon successful completion.
            </summary>
            <param name="runnable">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Submit(System.Action)">
            <summary> 
            Submits a <see cref="T:System.Action"/> task for execution and returns a 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> representing that task.  The future's
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> will return <c>default(T)</c>
            upon successful completion.
            </summary>
            <param name="action">The task to submit.</param>
            <returns>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the 
            task, and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will 
            return the given result value upon completion.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            If the task cannot be accepted for execution.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If the command is null.
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Take">
            <summary> 
            Retrieves and removes the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing 
            the next completed task, waiting if none are yet present.
            </summary>
            <returns>
            The <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the next completed task.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Poll">
            <summary> 
            Retrieves and removes the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing 
            the next completed task or <c>null</c> if none are present.
            </summary>
            <returns>
            The <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the next completed task, 
            or <c>null</c> if none are present.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ExecutorCompletionService`1.Poll(System.TimeSpan)">
            <summary> 
            Retrieves and removes the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the 
            next completed task, waiting, if necessary, up to the specified 
            duration if none are yet present.
            </summary>
            <param name="durationToWait">
            Duration to wait if no completed task is present yet.
            </param>
            <returns> 
            the <see cref="T:Spring.Threading.Future.IFuture`1"/> representing the next completed task or
            <c>null</c> if the specified waiting time elapses before one
            is present.
            </returns>
        </member>
        <member name="T:Spring.Threading.Execution.ExecutorCompletionService`1.QueueingFuture">
            <summary>
            <see cref="T:Spring.Threading.Future.FutureTask`1"/> extension to enqueue upon completion
            </summary>
        </member>
        <member name="T:Spring.Threading.Future.FutureTask`1">
            <summary> 
            A cancellable asynchronous computation.  
            </summary>	
            <remarks> 
            <para>
            This class provides a base implementation of 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> , with methods to start and cancel
            a computation, query to see if the computation is complete, and
            retrieve the result of the computation.  The result can only be
            retrieved when the computation has completed; the <see cref="M:Spring.Threading.Future.FutureTask`1.GetResult"/>
            method will block if the computation has not yet completed.  Once
            the computation has completed, the computation cannot be restarted
            or cancelled.
            </para>
            <para>
            A <see cref="T:Spring.Threading.Future.FutureTask`1"/> can be used to wrap a <see cref="T:System.Action"/>
            delegate, <see cref="T:System.Func`1"/> delegate, <see cref="T:Spring.Threading.IRunnable"/> object 
            or <see cref="T:Spring.Threading.ICallable`1"/> object.  Because <see cref="T:Spring.Threading.Future.FutureTask`1"/>
            implements <see cref="T:Spring.Threading.IRunnable"/>, a <see cref="T:Spring.Threading.Future.FutureTask`1"/> can be
            submitted to an <see cref="T:Spring.Threading.IExecutor"/> for execution.
            </para>
            <para>
            In addition to serving as a standalone class, this class provides
            protected functionality that may be useful when creating
            customized task classes.
            </para>
            </remarks>
            <typeparam name="T">
            The result type returned by <see cref="M:Spring.Threading.Future.FutureTask`1.GetResult"/> method.
            </typeparam>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Future.IRunnableFuture`1">
            <summary> 
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> that is a <see cref="T:Spring.Threading.IRunnable"/>. 
            </summary>
            <remarks>
            Successful execution of the <see cref="M:Spring.Threading.IRunnable.Run"/> method causes 
            completion of the <see cref="T:Spring.Threading.Future.IFuture`1"/> and allows access to its results.
            </remarks>
            <seealso cref="T:Spring.Threading.Future.FutureTask`1"/>
            <seealso cref="T:Spring.Threading.IExecutor"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Future.IFuture`1">
            <summary>
            A <see cref="T:Spring.Threading.Future.IFuture`1"/> represents the result of an asynchronous
            computation.  
            </summary>
            <remarks> 
            <para>
            Methods are provided to check if the computation is
            complete, to wait for its completion, and to retrieve the result of
            the computation.  The result can only be retrieved using method
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> when the computation has completed, blocking if
            necessary until it is ready.  Cancellation is performed by the
            <see cref="M:Spring.Threading.ICancellable.Cancel"/> method.  Additional methods are provided to
            determine if the task completed normally or was cancelled. Once a
            computation has completed, the computation cannot be cancelled.
            If you would like to use a <c>IFuture</c> for the sake
            of cancellability but not provide a usable result, you can
            declare types of the form <c>IFuture&lt;object&gt;</c> and
            return <c>null</c> as a result of the underlying task.
            </para>
            <example>
            Sample Usage (Note that the following classes are all
            made-up.) 
            <code language="c#">
            interface IArchiveSearcher { string Search(string target); }
            class App {
              IExecutorService executor = ...
              IArchiveSearcher searcher = ...
              void ShowSearch(string target) {
                IFuture&lt;string&gt; future
                  = executor.Submit(delegate {
                        return searcher.Search(target);
                    });
                DisplayOtherThings(); // do other things while searching
                try {
                  DisplayText(future.get()); // use future
                } catch (ExecutionException ex) { Cleanup(); return; }
              }
            }
            </code>
            </example>
            The <see cref="T:Spring.Threading.Future.FutureTask`1"/> class is an implementation of 
            <see cref="T:Spring.Threading.Future.IFuture`1"/> that implements <see cref="T:Spring.Threading.IRunnable"/>, 
            and so may be executed by an <see cref="T:Spring.Threading.IExecutor"/>.
            <example>
            For example, the above construction with <c>Submit</c> could be replaced by:
            <code language="c#">
                IFutureTask&lt;string&gt; future =
                  new FutureTask&lt;string&gt;(delegate {
                      return searcher.Search(target);
                  });
                executor.Execute(future);
            </code>
            </example>
            <para>
            Memory consistency effects: Actions taken by the asynchronous 
            computation <i>happen-before</i> actions following the corresponding 
            <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/>in another thread.
            </para>
            </remarks>
            <seealso cref="T:Spring.Threading.Future.FutureTask`1"/>
            <seealso cref="T:Spring.Threading.IExecutor"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.ICancellable">
            <summary>
            A task that can be canceled.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.ICancellable.Cancel">
            <summary> 
            Attempts to cancel execution of this task.  
            </summary>
            <remarks> 
            This attempt will fail if the task has already completed, already been cancelled,
            or could not be cancelled for some other reason. If successful,
            and this task has not started when <see cref="M:Spring.Threading.ICancellable.Cancel"/> is called,
            this task should never run.  If the task has already started, the in-progress 
            tasks are allowed to complete.
            </remarks>
            <returns> <c>false</c> if the task could not be cancelled,
            typically because it has already completed normally;
            <c>true</c> otherwise
            </returns>
            
        </member>
        <member name="M:Spring.Threading.ICancellable.Cancel(System.Boolean)">
            <summary> 
            Attempts to cancel execution of this task.  
            </summary>
            <remarks> 
            This attempt will fail if the task has already completed, already been cancelled,
            or could not be cancelled for some other reason. If successful,
            and this task has not started when <see cref="M:Spring.Threading.ICancellable.Cancel"/> is called,
            this task should never run.  If the task has already started,
            then the <paramref name="mayInterruptIfRunning"/> parameter determines
            whether the thread executing this task should be interrupted in
            an attempt to stop the task.
            </remarks>
            <param name="mayInterruptIfRunning">
            <c>true</c> if the thread executing this
            task should be interrupted; otherwise, in-progress tasks are allowed
            to complete
            </param>
            <returns>
            <c>false</c> if the task could not be cancelled,
            typically because it has already completed normally;
            <c>true</c> otherwise
            </returns>
        </member>
        <member name="P:Spring.Threading.ICancellable.IsCancelled">
            <summary>
            Determines if this task was cancelled.
            </summary>
            <remarks> 
            Returns <c>true</c> if this task was cancelled before it completed
            normally.
            </remarks>
            <returns> <c>true</c>if task was cancelled before it completed
            </returns>
        </member>
        <member name="P:Spring.Threading.ICancellable.IsDone">
            <summary> 
            Returns <c>true</c> if this task completed.
            </summary>
            <remarks> 
            Completion may be due to normal termination, an exception, or
            cancellation -- in all of these cases, this method will return
            <c>true</c> if this task completed.
            </remarks>
            <returns> <c>true</c>if this task completed.</returns>
        </member>
        <member name="M:Spring.Threading.Future.IFuture`1.GetResult">
            <summary>
            Waits for computation to complete, then returns its result. 
            </summary>
            <remarks> 
            Waits if necessary for the computation to complete, and then
            retrieves its result.
            </remarks>
            <returns>the computed result</returns>
            <exception cref="T:Spring.Threading.Execution.CancellationException">if the computation was cancelled.</exception>
            <exception cref="T:Spring.Threading.Execution.ExecutionException">if the computation threw an exception.</exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread was interrupted while waiting.</exception>
        </member>
        <member name="M:Spring.Threading.Future.IFuture`1.GetResult(System.TimeSpan)">
            <summary>
            Waits for the given time span, then returns its result.
            </summary>
            <remarks> 
            Waits, if necessary, for at most the <paramref name="durationToWait"/> for the computation
            to complete, and then retrieves its result, if available.
            </remarks>
            <param name="durationToWait">the <see cref="T:System.TimeSpan"/> to wait.</param>
            <returns>the computed result</returns>
            <exception cref="T:Spring.Threading.Execution.CancellationException">if the computation was cancelled.</exception>
            <exception cref="T:Spring.Threading.Execution.ExecutionException">if the computation threw an exception.</exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread was interrupted while waiting.</exception>
            <exception cref="T:Spring.Threading.TimeoutException">if the computation threw an exception.</exception>
        </member>
        <member name="F:Spring.Threading.Future.FutureTask`1._runningThread">
            <summary> 
            The thread running task. When nulled after set/cancel, this
            indicates that the results are accessible.  Must be
            volatile, to ensure visibility upon completion.
            </summary>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.#ctor(Spring.Threading.ICallable{`0})">
            <summary> 
            Creates a <see cref="T:Spring.Threading.Future.FutureTask`1"/> that will, upon running, execute the
            given <see cref="T:Spring.Threading.ICallable`1"/>.
            </summary>
            <param name="callable">The callable task.</param>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="callable"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.#ctor(System.Func{`0})">
            <summary> 
            Creates a <see cref="T:Spring.Threading.Future.FutureTask`1"/> that will, upon running, execute the
            given <see cref="T:System.Func`1"/> delegate.
            </summary>
            <param name="call">The <see cref="T:System.Func`1"/> delegate.</param>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="call"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.#ctor(Spring.Threading.IRunnable,`0)">
            <summary> 
            Creates a <see cref="T:Spring.Threading.Future.FutureTask`1"/> that will, upon running, execute the
            given <see cref="T:Spring.Threading.IRunnable"/>, and arrange that <see cref="M:Spring.Threading.Future.FutureTask`1.GetResult"/> 
            will return the given <paramref name="result"/> upon successful completion.
            </summary>
            <param name="task">The runnable task.</param>
            <param name="result">
            The result to return on successful completion. If
            you don't need a particular result, consider using
            constructions of the form:
            <code language="c#">
            	Future f = new FutureTask(runnable, default(T))
            </code>	
            </param>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="task"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.#ctor(System.Action,`0)">
            <summary> 
            Creates a <see cref="T:Spring.Threading.Future.FutureTask`1"/> that will, upon running, execute the
            given <see cref="T:System.Action"/>, and arrange that <see cref="M:Spring.Threading.Future.FutureTask`1.GetResult"/> 
            will return the given <paramref name="result"/> upon successful completion.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> delegate.</param>
            <param name="result">
            The result to return on successful completion. If
            you don't need a particular result, consider using
            constructions of the form:
            <code language="c#">
            	Future f = new FutureTask(action, default(T))
            </code>	
            </param>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="action"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.GetResult">
            <summary>
            Waits for computation to complete, then returns its result. 
            </summary>
            <remarks> 
            Waits if necessary for the computation to complete, and then
            retrieves its result.
            </remarks>
            <returns>The computed result</returns>
            <exception cref="T:Spring.Threading.Execution.CancellationException">if the computation was cancelled.</exception>
            <exception cref="T:Spring.Threading.Execution.ExecutionException">if the computation threw an exception.</exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread was interrupted while waiting.</exception>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.GetResult(System.TimeSpan)">
            <summary>
            Waits for the given time span, then returns its result.
            </summary>
            <remarks> 
            Waits, if necessary, for at most the <paramref name="durationToWait"/> for the computation
            to complete, and then retrieves its result, if available.
            </remarks>
            <param name="durationToWait">the <see cref="T:System.TimeSpan"/> to wait.</param>
            <returns>the computed result</returns>
            <exception cref="T:Spring.Threading.Execution.CancellationException">if the computation was cancelled.</exception>
            <exception cref="T:Spring.Threading.Execution.ExecutionException">if the computation threw an exception.</exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread was interrupted while waiting.</exception>
            <exception cref="T:Spring.Threading.TimeoutException">if the computation threw an exception.</exception>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.Cancel">
            <summary> 
            Attempts to cancel execution of this task.  
            </summary>
            <remarks> 
            This attempt will fail if the task has already completed, already been cancelled,
            or could not be cancelled for some other reason. If successful,
            and this task has not started when <see cref="M:Spring.Threading.ICancellable.Cancel"/> is called,
            this task should never run.  If the task has already started, the in-progress tasks are allowed
            to complete
            </remarks>
            <returns> <c>false</c> if the task could not be cancelled,
            typically because it has already completed normally;
            <c>true</c> otherwise
            </returns>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.Cancel(System.Boolean)">
            <summary> 
            Attempts to cancel execution of this task.  
            </summary>
            <remarks> 
            This attempt will fail if the task has already completed, already been cancelled,
            or could not be cancelled for some other reason. If successful,
            and this task has not started when <see cref="M:Spring.Threading.ICancellable.Cancel"/> is called,
            this task should never run.  If the task has already started,
            then the <paramref name="mayInterruptIfRunning"/> parameter determines
            whether the thread executing this task should be interrupted in
            an attempt to stop the task.
            </remarks>
            <param name="mayInterruptIfRunning"><c>true</c> if the thread executing this
            task should be interrupted; otherwise, in-progress tasks are allowed
            to complete
            </param>
            <returns> <c>false</c> if the task could not be cancelled,
            typically because it has already completed normally;
            <c>true</c> otherwise
            </returns>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.Run">
            <summary>
            The entry point
            </summary>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.SetResult(`0)">
            <summary> 
            Sets the result of this <see cref="T:Spring.Threading.Future.IFuture`1"/> to the given 
            <paramref name="result"/> value unless
            this future has already been set or has been cancelled.
            </summary>
            <remarks>
            This method is invoked upon successful completion of the 
            computation.
            </remarks>
            <param name="result">
            The value to be retured by <see cref="M:Spring.Threading.Future.FutureTask`1.GetResult"/>.
            </param>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.Done">
            <summary> 
            Protected method invoked when this task transitions to state
            <see cref="P:Spring.Threading.ICancellable.IsDone"/> (whether normally or via cancellation). 
            </summary>
            <remarks> 
            The default implementation does nothing.  Subclasses may override
            this method to invoke completion callbacks or perform
            bookkeeping. Note that you can query status inside the
            implementation of this method to determine whether this task
            has been cancelled.
            </remarks>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.SetException(System.Exception)">
            <summary> 
            Causes this future to report an <see cref="T:Spring.Threading.Execution.ExecutionException"/> 
            with the given <see cref="T:System.Exception"/> as its cause, unless this <see cref="T:Spring.Threading.Future.IFuture`1"/> has
            already been set or has been cancelled.
            </summary>
            <remarks>
            This method is invoked internally by the <see cref="T:Spring.Threading.IRunnable"/> method
            upon failure of the computation.
            </remarks>
            <param name="t">the cause of failure</param>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.RunAndReset">
            <summary> 
            Executes the computation without setting its result, and then
            resets this Future to initial state, failing to do so if the
            computation encounters an exception or is cancelled.  
            </summary>
            <remarks>
            This is designed for use with tasks that intrinsically execute more
            than once.
            </remarks>
            <returns> <c>true</c> if successfully run and reset</returns>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.SetCompleted(`0)">
            <summary>
            Sets the result of the task, and marks the task as completed
            </summary>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.SetFailed(System.Exception)">
            <summary>
            Sets the exception result of the task, and marks the tasks as completed.
            </summary>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.WaitFor">
            <summary> Waits for the task to complete.</summary>
        </member>
        <member name="M:Spring.Threading.Future.FutureTask`1.WaitFor(System.TimeSpan)">
            <summary> 
            Waits for the task to complete for <paramref name="durationToWait"/> or throws a
            <see cref="T:Spring.Threading.TimeoutException"/>
            if still not completed after that
            </summary>
        </member>
        <member name="P:Spring.Threading.Future.FutureTask`1.IsCancelled">
            <summary>
            Determines if this task was cancelled.
            </summary>
            <remarks> 
            Returns <c>true</c> if this task was cancelled before it completed
            normally.
            </remarks>
            <returns> <c>true</c>if task was cancelled before it completed
            </returns>
        </member>
        <member name="P:Spring.Threading.Future.FutureTask`1.IsDone">
            <summary> 
            Returns <c>true</c> if this task completed.
            </summary>
            <remarks> 
            Completion may be due to normal termination, an exception, or
            cancellation -- in all of these cases, this method will return
            <c>true</c> if this task completed.
            </remarks>
            <returns> <c>true</c>if this task completed.</returns>
        </member>
        <member name="P:Spring.Threading.Future.FutureTask`1.Result">
            <summary> 
            Gets the result of the task.
            </summary>
        </member>
        <member name="T:Spring.Threading.Execution.Executors">
            <summary> 
            Factory and utility methods for <see cref="T:Spring.Threading.IExecutor"/>, 
            <see cref="T:Spring.Threading.Execution.IExecutorService"/>,
            <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/>,
            <see cref="T:Spring.Threading.IThreadFactory"/>, and <see cref="T:Spring.Threading.ICallable`1"/> classes
            defined in this package.
            </summary>
            <remarks>
            This class supports the following kinds of
            methods:
            <list type="bullet">
            <item>Methods that create and return an <see cref="T:Spring.Threading.Execution.IExecutorService"/>
            set up with commonly useful configuration settings.</item>
            <item>Methods that create and return a <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/>
            set up with commonly useful configuration settings.</item>
            <item>Methods that create and return a "wrapped"
            <see cref="T:Spring.Threading.Execution.IExecutorService"/>, that disables reconfiguration by
            making implementation-specific methods inaccessible.</item>
            <item>Methods that create and return a <see cref="T:Spring.Threading.IThreadFactory"/>
            that sets newly created threads to a known state.</item>
            <item>Methods that create and return a <see cref="T:Spring.Threading.ICallable`1"/>
            out of other closure-like forms, so they can be used
            in execution methods requiring <see cref="T:Spring.Threading.ICallable`1"/>.</item>
            </list>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewFixedThreadPool(System.Int32)">
            <summary> 
            Creates a thread pool that reuses a fixed number of threads
            operating off a shared unbounded queue. 
            </summary>
            <remarks>
            At any point, at most
            <paramref name="threadPoolSize"/> threads will be active processing tasks. If
            additional tasks are submitted when all threads are active,
            they will wait in the queue until a thread is available.  If
            any thread terminates due to a failure during execution prior
            to shutdown, a new one will take its place if needed to execute
            subsequent tasks.
            </remarks>
            <param name="threadPoolSize">the number of threads in the pool</param>
            <returns> the newly created thread pool</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewFixedThreadPool(System.Int32,Spring.Threading.IThreadFactory)">
            <summary> 
            Creates a thread pool that reuses a fixed number of threads
            operating off a shared unbounded queue, using the provided
            <see cref="T:Spring.Threading.IThreadFactory"/> to create new threads when needed.  
            </summary>
            <remarks>
            At any point, at most <paramref name="threadPoolSize"/> threads will be active processing
            tasks. If additional tasks are submitted when all threads are
            active, they will wait in the queue until a thread is
            available. If any thread terminates due to a failure during
            execution prior to shutdown, a new one will take its place if
            needed to execute subsequent tasks.
            </remarks>
            <param name="threadPoolSize">the number of threads in the pool</param>
            <param name="threadFactory">the factory to use when creating new threads</param>
            <returns> the newly created thread pool
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewSingleThreadExecutor">
            <summary> 
            Creates an <see cref="T:Spring.Threading.IExecutor"/> that uses a single worker thread operating
            off an unbounded queue.
            </summary>
            <remarks>
            <b>Note:</b> however that if this single
            thread terminates due to a failure during execution prior to
            shutdown, a new one will take its place if needed to execute
            subsequent tasks.  Tasks are guaranteed to execute
            sequentially, and no more than one task will be active at any
            given time. Unlike the otherwise equivalent <see cref="M:Spring.Threading.Execution.Executors.NewFixedThreadPool(System.Int32)"/>,
            the returned executor is guaranteed not to be reconfigurable to use additional threads.
            </remarks>
            <returns> the newly created single-threaded <see cref="T:Spring.Threading.IExecutor"/> </returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewSingleThreadExecutor(Spring.Threading.IThreadFactory)">
            <summary> 
            Creates an <see cref="T:Spring.Threading.IExecutor"/> that uses a single worker thread operating
            off an unbounded queue, and uses the provided <see cref="T:Spring.Threading.IThreadFactory"/> to
            create a new thread when needed. 
            </summary>
            <remarks>
            Unlike the otherwise equivalent <see cref="M:Spring.Threading.Execution.Executors.NewFixedThreadPool(System.Int32,Spring.Threading.IThreadFactory)"/>, the
            returned executor is guaranteed not to be reconfigurable to use
            additional threads.
            </remarks>
            <param name="threadFactory">the factory to use when creating new threads</param>
            <returns> the newly created single-threaded <see cref="T:Spring.Threading.IExecutor"/></returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewCachedThreadPool">
            <summary> 
            Creates a thread pool that creates new threads as needed, but
            will reuse previously constructed threads when they are
            available.  
            </summary>
            <remarks>
            These pools will typically improve the performance
            of programs that execute many short-lived asynchronous tasks.
            Calls to <see cref="M:Spring.Threading.IExecutor.Execute(Spring.Threading.IRunnable)"/> will reuse previously constructed
            threads if available. If no existing thread is available, a new
            thread will be created and added to the pool. Threads that have
            not been used for sixty seconds are terminated and removed from`
            the cache. Thus, a pool that remains idle for long enough will
            not consume any resources. <b>Note:</b> pools with similar
            properties but different details (for example, timeout parameters)
            may be created using <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> constructors.
            </remarks>
            <returns>the newly created thread pool</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewCachedThreadPool(Spring.Threading.IThreadFactory)">
            <summary> 
            Creates a thread pool that creates new threads as needed, but
            will reuse previously constructed threads when they are
            available, and uses the provided <see cref="T:Spring.Threading.IThreadFactory"/>  to create new threads when needed.
            </summary>
            <param name="threadFactory">the factory to use when creating new threads</param>
            <returns> the newly created thread pool</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.UnconfigurableExecutorService(Spring.Threading.Execution.IExecutorService)">
            <summary> 
            Returns an object that delegates all defined 
            <see cref="T:Spring.Threading.Execution.IExecutorService"/> 
            methods to the given executor, but not any
            other methods that might otherwise be accessible using
            casts. 
            </summary>
            <remarks>
            This provides a way to safely "freeze" configuration and
            disallow tuning of a given concrete implementation.
            </remarks>
            <param name="executor">the underlying implementation</param>
            <returns> an <see cref="T:Spring.Threading.Execution.IExecutorService"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="executor"/> is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewSingleThreadScheduledExecutor``1">
            <summary> 
            Creates a single-threaded executor that can schedule commands
            to run after a given delay, or to execute periodically.
            </summary>
            <remarks>
            <b>Note:</b> if this single thread terminates due to a failure during execution prior to
            shutdown, a new one will take its place if needed to execute
            subsequent tasks.  Tasks are guaranteed to execute
            sequentially, and no more than one task will be active at any
            given time. Unlike the otherwise equivalent <see cref="M:Spring.Threading.Execution.Executors.NewScheduledThreadPool(System.Int32)"/>
            the returned executor is guaranteed not to be reconfigurable to use additional threads.
            </remarks>
            <returns> the newly created scheduled executor</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewSingleThreadScheduledExecutor``1(Spring.Threading.IThreadFactory)">
            <summary> 
            Creates a single-threaded executor that can schedule commands
            to run after a given delay, or to execute periodically.
            </summary>
            <remarks>
            Note however that if this single thread terminates due to a failure
            during execution prior to shutdown, a new one will take its
            place if needed to execute subsequent tasks.)  Tasks are
            guaranteed to execute sequentially, and no more than one task
            will be active at any given time. Unlike the otherwise
            equivalent <see cref="M:Spring.Threading.Execution.Executors.NewScheduledThreadPool(System.Int32,Spring.Threading.IThreadFactory)"/>
            the returned executor is guaranteed not to be reconfigurable to
            use additional threads.
            </remarks>
            <param name="threadFactory">the factory to use when creating new threads</param>
            <returns> a newly created scheduled executor</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewScheduledThreadPool(System.Int32)">
            <summary> 
            Creates a thread pool that can schedule commands to run after a
            given delay, or to execute periodically.
            </summary>
            <param name="corePoolSize">the number of threads to keep in the pool, even if they are idle.
            </param>
            <returns> a newly created scheduled thread pool</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewScheduledThreadPool(System.Int32,Spring.Threading.IThreadFactory)">
            <summary> 
            Creates a thread pool that can schedule commands to run after a
            given delay, or to execute periodically and uses the provided <see cref="T:Spring.Threading.IThreadFactory"/> to
            create a new thread when needed. 
            </summary>
            <param name="corePoolSize">the number of threads to keep in the pool, even if they are idle.</param>
            <param name="threadFactory">the factory to use when the executor creates a new thread.</param>
            <returns> a newly created scheduled thread pool</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.UnconfigurableScheduledExecutorService(Spring.Threading.Execution.IScheduledExecutorService)">
            <summary> 
            Returns an object that delegates all defined <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/> 
            methods to the given executor, but not any other methods that might otherwise be accessible using
            casts. This provides a way to safely "freeze" configuration and
            disallow tuning of a given concrete implementation.
            </summary>
            <param name="executor">the underlying implementation</param>
            <returns> a <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/> instance</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="executor"/> is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.NewDefaultThreadFactory">
            <summary> 
            Returns a default thread factory used to create new threads.
            </summary>
            <remarks>
            This factory creates all new threads used by an <see cref="T:Spring.Threading.IExecutor"/>.
            invoking this <see cref="M:Spring.Threading.Execution.Executors.NewDefaultThreadFactory"/> method.
            New threads have names accessible via <see cref="P:System.Threading.Thread.Name"/> of
            <i>pool-N-thread-M</i>, where <i>N</i> is the sequence
            number of this factory, and <i>M</i> is the sequence number
            of the thread created by this factory.
            </remarks>
            <returns>a thread factory</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCallable(Spring.Threading.IRunnable)">
            <summary> 
            Returns a <see cref="T:Spring.Threading.ICallable`1"/> object that, when
            called, runs the given task and returns <c>null</c>.
            </summary>
            <param name="runnable">the task to run</param>
            <returns> a callable object</returns>
            <exception cref="T:System.ArgumentNullException">if the task is <c>null</c></exception>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCallable(System.Action)">
            <summary>
            Returns a <see cref="T:Spring.Threading.ICallable`1"/> object that, when called, runs 
            the given <paramref name="action"/> and returns <c>null</c>.  
            </summary>
            <param name="action">The task to run.</param>
            <returns>An <see cref="T:Spring.Threading.ICallable`1"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">
            When the <paramref name="action"/> is <c>null</c>.
            </exception>
            <seealso cref="M:Spring.Threading.Execution.Executors.CreateCallable``1(System.Action,``0)"/>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCallable``1(Spring.Threading.IRunnable,``0)">
            <summary> 
            Returns a <see cref="T:Spring.Threading.ICallable`1"/>  object that, when called, 
            runs the given <paramref name="runnable"/> and returns the given 
            <paramref name="result"/>.  
            </summary>
            <remarks>
            This can be useful when applying methods requiring a
            <see cref="T:Spring.Threading.ICallable`1"/> to an otherwise resultless action.
            </remarks>
            <typeparam name="T">Type of the result.</typeparam>
            <param name="runnable">the task to run</param>
            <param name="result">the result to return</param>
            <returns>An <see cref="T:Spring.Threading.ICallable`1"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">
            When the <paramref name="runnable"/> is <c>null</c>.
            </exception>
            <seealso cref="M:Spring.Threading.Execution.Executors.CreateCallable``1(System.Action,``0)"/>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCallable``1(System.Action,``0)">
            <summary>
            Returns a <see cref="T:Spring.Threading.ICallable`1"/>  object that, when called, 
            runs the given <paramref name="action"/> and returns the given 
            <paramref name="result"/>.  
            </summary>
            <remarks>
            This can be useful when applying methods requiring a
            <see cref="T:Spring.Threading.ICallable`1"/> to an otherwise resultless action.
            </remarks>
            <typeparam name="T">Type of the result.</typeparam>
            <param name="action">The task to run.</param>
            <param name="result">The resul to return</param>
            <returns>An <see cref="T:Spring.Threading.ICallable`1"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">
            When the <paramref name="action"/> is <c>null</c>.
            </exception>
            <seealso cref="M:Spring.Threading.Execution.Executors.CreateCallable``1(Spring.Threading.IRunnable,``0)"/>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCallable``1(System.Func{``0})">
            <summary>
            Converts a <see cref="T:System.Func`1"/> delegate to an 
            <see cref="T:Spring.Threading.ICallable`1"/> object.
            </summary>
            <typeparam name="T">
            Type of the result to be returned by <paramref name="call"/>.
            </typeparam>
            <param name="call">The <see cref="T:System.Func`1"/></param> delegate.
            <returns>An instance of <see cref="T:Spring.Threading.ICallable`1"/>.</returns>
            <seealso cref="M:Spring.Threading.Execution.Executors.CreateCall``1(Spring.Threading.ICallable{``0})"/>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCall``1(Spring.Threading.IRunnable,``0)">
            <summary> 
            Returns a <see cref="T:System.Func`1"/> delegate that, when called, 
            runs the given <paramref name="runnable"/> and returns the given 
            <paramref name="result"/>.  
            </summary>
            <remarks>
            This can be useful when applying methods requiring a
            <see cref="T:System.Func`1"/> to an otherwise resultless action.
            </remarks>
            <typeparam name="T">Type of the result.</typeparam>
            <param name="runnable">the task to run</param>
            <param name="result">the result to return</param>
            <returns>An <see cref="T:System.Func`1"/> delegate.</returns>
            <exception cref="T:System.ArgumentNullException">
            When the <paramref name="runnable"/> is <c>null</c>.
            </exception>
            <seealso cref="M:Spring.Threading.Execution.Executors.CreateCall``1(System.Action,``0)"/>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCall``1(System.Action,``0)">
            <summary> 
            Returns a <see cref="T:System.Func`1"/> delegate that, when called, 
            runs the given <paramref name="action"/> and returns the given 
            <paramref name="result"/>.  
            </summary>
            <remarks>
            This can be useful when applying methods requiring a
            <see cref="T:System.Func`1"/> to an otherwise resultless action.
            </remarks>
            <typeparam name="T">Type of the result.</typeparam>
            <param name="action">the task to run</param>
            <param name="result">the result to return</param>
            <returns>An <see cref="T:System.Func`1"/> delegate.</returns>
            <exception cref="T:System.ArgumentNullException">
            When the <paramref name="action"/> is <c>null</c>.
            </exception>
            <seealso cref="M:Spring.Threading.Execution.Executors.CreateCall``1(Spring.Threading.IRunnable,``0)"/>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateCall``1(Spring.Threading.ICallable{``0})">
            <summary>
            Converts an <see cref="T:Spring.Threading.ICallable`1"/> object to a 
            <see cref="T:System.Func`1"/> delegate.
            </summary>
            <typeparam name="T">
            Type of the result to be returned by <paramref name="callable"/>.
            </typeparam>
            <param name="callable">The <see cref="T:Spring.Threading.ICallable`1"/></param> object.
            <returns>A <see cref="T:System.Func`1"/> delegate.</returns>
        </member>
        <member name="M:Spring.Threading.Execution.Executors.CreateRunnable(System.Action)">
            <summary>
            Converts a <see cref="T:System.Action"/> delegate to an
            <see cref="T:Spring.Threading.IRunnable"/> object.
            </summary>
            <param name="action">Task to be converted.</param>
            <returns>An <see cref="T:Spring.Threading.IRunnable"/> object.</returns>
        </member>
        <member name="T:Spring.Threading.IThreadFactory">
            <summary> 
            An object that creates new threads on demand.  
            </summary>
            <remarks> 
            Using thread factories removes hardwiring of calls to new Thread,
            enabling applications to use special thread subclasses, priorities, etc.
            <p/>
            The simplest implementation of this interface is just:
            <code>
            class SimpleThreadFactory : IThreadFactory {
            	public Thread NewThread(IRunnable r) {
            		return new Thread(new ThreadStart(r.Run));
            	}
            }
            </code>
            
            The <see cref="M:Spring.Threading.Execution.Executors.NewDefaultThreadFactory"/> method provides a more
            useful simple implementation, that sets the created thread context
            to known values before returning it.
            </remarks>
            <author>Doug Lea</author>
            <author>Federico Spinazzi (.Net)</author>
            <author>Griffin Caprio (.Net)</author>
        </member>
        <member name="M:Spring.Threading.IThreadFactory.NewThread(Spring.Threading.IRunnable)">
            <summary> 
            Constructs a new <see cref="T:System.Threading.Thread"/>.  
            </summary>
            <remarks> 
            Implementations may also initialize
            priority, name, daemon status, thread state, etc.
            </remarks>
            <param name="runnable">
            a runnable to be executed by new thread instance
            </param>
            <returns>constructed thread</returns>
        </member>
        <member name="T:Spring.Threading.Execution.Executors.DelegatedScheduledExecutorService">
            <summary> A wrapper class that exposes only the <see cref="T:Spring.Threading.Execution.IExecutorService"/> and
            <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/> methods of a <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/> implementation.
            </summary>
        </member>
        <member name="T:Spring.Threading.Execution.IScheduledExecutorService">
            <summary> 
            An <see cref="T:Spring.Threading.Execution.IExecutorService"/>  that can schedule commands to run after a given
            delay, or to execute periodically.
            
            <p/> 
            The <see cref="M:Spring.Threading.Execution.IScheduledExecutorService.Schedule``1(Spring.Threading.ICallable{``0},System.TimeSpan)"/> and
            <see cref="M:Spring.Threading.Execution.IScheduledExecutorService.Schedule(Spring.Threading.IRunnable,System.TimeSpan)"/> 
            methods create tasks with various delays
            and return a task object that can be used to cancel or check
            execution. The <see cref="M:Spring.Threading.Execution.IScheduledExecutorService.ScheduleAtFixedRate(Spring.Threading.IRunnable,System.TimeSpan,System.TimeSpan)"/> and
            <see cref="M:Spring.Threading.Execution.IScheduledExecutorService.ScheduleWithFixedDelay(Spring.Threading.IRunnable,System.TimeSpan,System.TimeSpan)"/>
            methods create and execute tasks
            that run periodically until cancelled.
            
            <p/> 
            Commands submitted using the <see cref="M:Spring.Threading.IExecutor.Execute(Spring.Threading.IRunnable)"/>  and
            <see cref="M:Spring.Threading.Execution.IExecutorService.Submit"/> methods are scheduled with
            a requested delay of zero. Zero and negative delays (but not
            periods) are also allowed in <see cref="M:Spring.Threading.Execution.IScheduledExecutorService.Schedule"/> methods, and are
            treated as requests for immediate execution.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Execution.IScheduledExecutorService.Schedule(Spring.Threading.IRunnable,System.TimeSpan)">
            <summary> 
            Creates and executes a one-shot action that becomes enabled
            after the given delay.
            </summary>
            <param name="command">the task to execute.</param>
            <param name="delay">the <see cref="T:System.TimeSpan"/> from now to delay execution.</param>
            <returns> 
            a <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> representing pending completion of the task,
            and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return <c>null</c>
            upon completion.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.IScheduledExecutorService.Schedule``1(Spring.Threading.ICallable{``0},System.TimeSpan)">
            <summary> 
            Creates and executes a <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> that becomes enabled after the
            given delay.
            </summary>
            <param name="callable">the function to execute.</param>
            <param name="delay">the <see cref="T:System.TimeSpan"/> from now to delay execution.</param>
            <returns> a <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> that can be used to extract result or cancel.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.IScheduledExecutorService.ScheduleAtFixedRate(Spring.Threading.IRunnable,System.TimeSpan,System.TimeSpan)">
            <summary> 
            Creates and executes a periodic action that becomes enabled first
            after the given initial <paramref name="initialDelay"/>, and subsequently with the given
            <paramref name="period"/>
            </summary>
            <remarks>
            That is executions will commence after
            <paramref name="initialDelay"/>, the <paramref name="initialDelay"/> + <paramref name="period"/>, then
            <paramref name="initialDelay"/> + 2 * <paramref name="period"/>, and so on.
            <p/>
            
            If any execution of the task
            encounters an exception, subsequent executions are suppressed.
            Otherwise, the task will only terminate via cancellation or
            termination of the executor. If any execution of this task 
            takes longer than its period, then subsequent executions
            may start late, but will <b>NOT</b> concurrently execute.
            </remarks>
            <param name="command">the task to execute.</param>
            <param name="initialDelay">the time to delay first execution.</param>
            <param name="period">the period between successive executions.</param>
            <returns> a <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the task,
            and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will throw an exception upon
            cancellation.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.IScheduledExecutorService.ScheduleWithFixedDelay(Spring.Threading.IRunnable,System.TimeSpan,System.TimeSpan)">
            <summary> 
            Creates and executes a periodic action that becomes enabled first
            after the given initial delay, and subsequently with the
            given delay between the termination of one execution and the
            commencement of the next. 
            </summary>
            <remarks> 
            If any execution of the task
            encounters an exception, subsequent executions are suppressed.
            Otherwise, the task will only terminate via cancellation or
            termination of the executor.
            </remarks>
            <param name="command">the task to execute.</param>
            <param name="initialDelay">the time to delay first execution.</param>
            <param name="delay">the delay between the termination of one execution and the commencement of the next.</param>
            <returns> a <see cref="T:Spring.Threading.Future.IFuture`1"/>  representing pending completion of the task,
            and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will throw an exception upon
            cancellation.
            </returns>
        </member>
        <member name="T:Spring.Threading.Execution.IRejectedExecutionHandler">
            <summary> 
            A handler for tasks that cannot be executed by a 
            <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/>.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Execution.IRejectedExecutionHandler.RejectedExecution(Spring.Threading.IRunnable,Spring.Threading.Execution.ThreadPoolExecutor)">
            <summary> 
            Method that may be invoked by a <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> when
            <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> cannot accept a task. 
            </summary>
            <remarks> 
            This may occur when no more threads or queue slots are available because their bounds
            would be exceeded, or upon shutdown of the Executor.
            <p/>
            In the absence other alternatives, the method may throw an
            <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>, which will be
            propagated to the caller of <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/>.
            </remarks>
            <param name="runnable">the runnable task requested to be executed
            </param>
            <param name="executor">the executor attempting to execute this task
            </param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if there is no remedy for the rejection.</exception>
        </member>
        <member name="T:Spring.Threading.Execution.RejectedExecutionException">
            <summary> 
            Exception thrown by an <see cref="T:Spring.Threading.IExecutor"/> when a task cannot be
            accepted for execution.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio(.NET)</author>
        </member>
        <member name="M:Spring.Threading.Execution.RejectedExecutionException.#ctor">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> with no detail message.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.RejectedExecutionException.#ctor(System.String)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> with the
            specified detail message.
            </summary>
            <param name="message">the detail message</param>
        </member>
        <member name="M:Spring.Threading.Execution.RejectedExecutionException.#ctor(System.String,System.Exception)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> with the
            specified detail message and cause.
            </summary>
            <param name="message">the detail message</param>
            <param name="innerException">the inner exception (which is saved for later retrieval by the)</param>
        </member>
        <member name="M:Spring.Threading.Execution.RejectedExecutionException.#ctor(System.Exception)">
            <summary> 
            Constructs a <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> with the
            specified cause.
            </summary>
            <param name="innerException">the cause (which is saved for later retrieval by the)</param>
        </member>
        <member name="M:Spring.Threading.Execution.RejectedExecutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of the <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
            that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/>
            that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:Spring.Threading.Execution.ScheduledThreadPoolExecutor">
            <summary>
            A <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> that can additionally schedule
            commands to run after a given delay, or to execute
            periodically. This class is preferable to <see cref="T:System.Timers.Timer"/>
            when multiple worker threads are needed, or when the additional
            flexibility or capabilities of <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> (which
            this class extends) are required.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="T:Spring.Threading.Execution.ThreadPoolExecutor">
            <summary>
            An <see cref="T:Spring.Threading.Execution.IExecutorService"/> that executes each submitted task 
            using one of possibly several pooled threads, normally configured
            using <see cref="T:Spring.Threading.Execution.Executors"/> factory methods.
            </summary> 
            <remarks>
            <para>
            Thread pools address two different problems: they usually provide
            improved performance when executing large numbers of asynchronous
            tasks, due to reduced per-task invocation overhead, and they provide
            a means of bounding and managing the resources, including threads,
            consumed when executing a collection of tasks. Each 
            <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> also maintains some basic statistics,
            such as the number of completed tasks.
            </para>
            <para>
            To be useful across a wide range of contexts, this class provides
            many adjustable parameters and extensibility hooks. However,
            programmers are urged to use the more convenient <see cref="T:Spring.Threading.Execution.Executors"/>
            factory methods <see cref="M:Spring.Threading.Execution.Executors.NewCachedThreadPool"/>
            (unbounded thread pool, with automatic thread reclamation),
            <see cref="M:Spring.Threading.Execution.Executors.NewFixedThreadPool(System.Int32)"/> or
            <see cref="M:Spring.Threading.Execution.Executors.NewFixedThreadPool(System.Int32,Spring.Threading.IThreadFactory)"/> (fixed
            size thread pool) and <see cref="M:Spring.Threading.Execution.Executors.NewSingleThreadExecutor"/>
            single background thread), that preconfigure settings for the most
            common usage scenarios. Otherwise, use the following guide when
            manually configuring and tuning this class:
            </para>
            <list type="bullet">
            <item>
            	<term>Core and maximum pool sizes</term>&gt;
            	<description>
                    A <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> will automatically adjustthe
                    pool size (<see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.PoolSize"/>) according to the bounds set
                    by Core Pool Size (<see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>) and Maximum Pool
                    Size (<see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>)
            		<p/>
            		When a new task is submitted in method
            		<see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(System.Action)"/> or
                    <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/>
            		and fewer than <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> threads are running,
                    a new thread is created to handle the request, even if other
                    worker threads are idle.  If there are more than
            		<see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> but less than <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>
            		threads running, a new thread will be created only if the queue
                    is full.  By setting core pool size and maximum pool size the
                    same, you create a fixed-size thread pool. By setting maximum
                    pool size to an essentially unbounded value such as
                    <see cref="F:System.Int32.MaxValue"/>, you allow the pool to accommodate
                    an arbitrary number of concurrent tasks. Most typically, core
                    and maximum pool sizes are set only upon construction, but they
            		may also be changed dynamically using <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>
                    and <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>.
            	</description>
            </item>
            <item>
            	<term>On-demand construction</term>
            	<description> 
            		By default, even core threads are initially created and started
                    only when new tasks arrive, but this can be overridden
                    dynamically using method <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.PreStartCoreThread"/> or
            		<see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.PreStartAllCoreThreads"/>.
            		You probably want to prestart threads if you construct the pool
                    with a non-empty queue. 
            	</description>
            </item>
            <item>
            	<term>Creating new threads</term>
            	<description>
            		New threads are created using a <see cref="T:Spring.Threading.IThreadFactory"/>.
            		If not otherwise specified, a  <see cref="T:Spring.Threading.Execution.Executors.DefaultThreadFactory"/>
                    is used, that creates threads to all with the same
                    <see cref="T:System.Threading.ThreadPriority"/> set to <see cref="F:System.Threading.ThreadPriority.Normal"/>
            		priority and non-daemon status. By supplying a different
                    <see cref="T:Spring.Threading.IThreadFactory"/>, you can alter the thread's name,
            		priority, daemon status, etc. If a <see cref="T:Spring.Threading.IThreadFactory"/>
                    fails to create a thread when asked by returning null from
                    <see cref="M:Spring.Threading.IThreadFactory.NewThread(Spring.Threading.IRunnable)"/>, the executor
                    will continue, but might not be able to execute any tasks. 
            	</description>
            </item>
            <item>
            	<term>Keep-alive times</term>
            	<description>
            		If the pool currently has more than <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>
                    threads, excess threads will be terminated if they have been
                    idle for more than the <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.KeepAliveTime"/>. This
                    provides a means of reducing resource consumption when the pool
                    is not being actively used. If the pool becomes more active
                    later, new threads will be constructed. This parameter can
                    also be changed dynamically using method
                    <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.KeepAliveTime"/>. Using a value of
                    <see cref="F:System.Int32.MaxValue"/> effectively disables idle
                    threads from ever terminating prior to shut down. By default,
                    the keep-alive policy applies only when there are more than
                    <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> Threads. But method
            		<see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.AllowsCoreThreadsToTimeOut"/> can be used to apply
            		this time-out policy to core threads as well, so long as the
                    <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.KeepAliveTime"/> value is non-zero. 
            	</description>
            </item>
            <item>
            	<term>Queuing</term>
            	<description>
            		Any <see cref="T:Spring.Threading.Collections.Generic.IBlockingQueue`1"/> may be used to transfer and
                    hold submitted tasks.  The use of this queue interacts with
                    pool sizing:
            
            		<list type="bullet">
            			<item> 
            				If fewer than <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> threads are
                            running, the Executor always prefers adding a new thread
                            rather than queuing.
            			</item>
            			<item> 
            				If <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> or more threads are
                            running, the Executor always prefers queuing a request
                            rather than adding a new thread.
            			</item>
            			<item> 
            				If a request cannot be queued, a new thread is created
                            unless this would exceed <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>, 
            				in which case, the task will be rejected.
            			</item>
            		</list>
            
            		There are three general strategies for queuing:
            
            		<list type="number">
            			<item> 
            				<term><i>Direct handoffs.</i></term>
                            <description>A good default choice for a
                            work queue is a <see cref="T:Spring.Threading.Collections.Generic.SynchronousQueue`1"/> that
                            hands off tasks to threads without otherwise holding
                            them. Here, an attempt to queue a task will fail if no 
                            threads are immediately available to run it, so a new 
                            thread will be constructed. This policy avoids lockups 
                            when handling sets of requests that might have internal 
                            dependencies. Direct handoffs generally require 
                            unbounded <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/> to avoid 
                            rejection of new submitted tasks. This in turn admits 
                            the possibility of unbounded thread growth when commands 
                            continue to arrive on average faster than they can be 
                            processed.</description>
            			</item>
            			<item>
            				<term><i>Unbounded queues.</i></term>
                            <description>Using an unbounded queue (for
            				example a <see cref="T:Spring.Threading.Collections.Generic.LinkedBlockingQueue`1"/> without 
                            a predefined capacity) will cause new tasks to wait in 
                            the queue when all <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> threads 
                            are busy. Thus, no more than <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>
            				threads will ever be created. (And the value of the 
            				<see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>
            				therefore doesn't have any effect.)  This may be appropriate when
            				each task is completely independent of others, so tasks cannot
            				affect each others execution; for example, in a web page server.
            				While this style of queuing can be useful in smoothing out
            				transient bursts of requests, it admits the possibility of
            				unbounded work queue growth when commands continue to arrive on
            				average faster than they can be processed.</description>
            			</item>
            			<item>
            				<term><i>Bounded queues.</i></term>
                            <description>A bounded queue (for example, an
            				<see cref="T:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1"/>) helps prevent 
                            resource exhaustion when used with finite 
                            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>, but can be more difficult to 
                            tune and control.  Queue sizes and maximum pool sizes may be traded
            				off for each other: Using large queues and small pools minimizes
            				CPU usage, OS resources, and context-switching overhead, but can
            				lead to artificially low throughput.  If tasks frequently block (for
            				example if they are I/O bound), a system may be able to schedule
            				time for more threads than you otherwise allow. Use of small queues
            				generally requires larger pool sizes, which keeps CPUs busier but
            				may encounter unacceptable scheduling overhead, which also
            				decreases throughput.</description>
            			</item>
            		</list>
            	</description>
            </item>
            <item>
            	<term>Rejected tasks</term>
            	<description> 
            		New tasks submitted in method <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(System.Action)"/>
                    or <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/>
            		will be <i>rejected</i> when the Executor has been shut down, 
                    and also when the Executor uses finite bounds for both maximum 
                    threads and work queue capacity, and is saturated.  In either 
                    case, the <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(System.Action)"/>
                    or <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> method invokes the
            		<see cref="M:Spring.Threading.Execution.IRejectedExecutionHandler.RejectedExecution(Spring.Threading.IRunnable,Spring.Threading.Execution.ThreadPoolExecutor)"/> method of its
            		<see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/>.  Four predefined handler policies
            		are provided:
            		
            		<list type="number">
            			<item> 
            				In the default <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor.AbortPolicy"/>, the handler throws a
            				runtime <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> upon rejection. 
            			</item>
            			<item> 
            				In <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor.CallerRunsPolicy"/>, the thread that invokes
            				<see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(System.Action)"/>
                            or <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> 
                            itself runs the task. This provides a simple feedback 
                            control mechanism that will slow down the rate that new 
                            tasks are submitted. 
            			</item>
            			<item> 
            				In <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor.DiscardPolicy"/>, a task that cannot be 
                            executed is simply dropped.
            			</item>
            			<item>
            				In <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor.DiscardOldestPolicy"/>, if the executor is not
            				shut down, the task at the head of the work queue is dropped, and
            				then execution is retried (which can fail again, causing this to be
            				repeated.) 
            			</item>
            		</list>
            		It is possible to define and use other kinds of
            		<see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/> classes. Doing so 
                    requires some care especially when policies are designed to 
                    work only under particular capacity or queuing policies. 
            	</description>
            </item>
            <item>
            	<term>Hook methods</term>
            	<description>
            		This class provides <i>protected</i> overridable <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.BeforeExecute(System.Threading.Thread,Spring.Threading.IRunnable)"/>
            		and <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.AfterExecute(Spring.Threading.IRunnable,System.Exception)"/> methods that are called before and
            		after execution of each task.  These can be used to manipulate the
            		execution environment; for example, reinitializing ThreadLocals,
            		gathering statistics, or adding log entries. Additionally, method
            		<see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Terminated"/> can be overridden to perform
            		any special processing that needs to be done once the Executor has
            		fully terminated.
            		<p/>
            		If hook or callback methods throw exceptions, internal worker 
                    threads may in turn fail and abruptly terminate.
            	</description>
            </item>
            <item>
            	<term>Queue maintenance</term>
            	<description> 
            		Method <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.Queue"/> allows access to the work queue for 
                    purposes of monitoring and debugging.  Use of this method for 
                    any other purpose is <i>strongly</i> discouraged. 
            	</description>
            </item>
            <item>
                <term>Finalization</term>
                <description> A pool that is no longer referenced in a program <i>AND</i>
                    has no remaining threads will be <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Shutdown"/> automatically. If
                    you would like to ensure that unreferenced pools are reclaimed even
                    if users forget to call <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Shutdown"/>, then you must arrange
                    that unused threads eventually die, by setting appropriate
                    keep-alive times, using a lower bound of zero core threads and/or
                    setting <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.AllowsCoreThreadsToTimeOut"/>.
                </description>
            </item>
            </list>
            <example>
            <b>Extension example</b>. Most extensions of this class
            override one or more of the protected hook methods. For example,
            here is a subclass that adds a simple pause/resume feature:
            
            <code language="C#">
            	public class PausableThreadPoolExecutor : ThreadPoolExecutor {
            		private boolean _isPaused;
            		private ReentrantLock _pauseLock = new ReentrantLock();
            		private ICondition _unpaused = pauseLock.NewCondition();
            
            		public PausableThreadPoolExecutor(...) : base( ... ) { }
            
            		protected override void BeforeExecute(Thread t, IRunnable r) {
            				base.BeforeExecute(t, r);
            				_pauseLock.Lock();
            				try {
            					while (_isPaused) _unpaused.Await();
            				} catch (ThreadInterruptedException ie) {
            					t.Interrupt();
            				} finally {
            					_pauseLock.Unlock();
            				}
            		}
            
            		public void Pause() {
            			using(_pauseLock.Lock())
            			{
            				_isPaused = true;
            			}
            		}
            
            		public void Resume() {
            			using(_pauseLock.Lock())
            			{
            				_isPaused = false;
            				_unpaused.SignalAll();
            			}
            		}
            	}
            </code>
            </example>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor.RUNNING">
            <summary>
            runState is stored in the high-order bits 
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._controlState">
             <summary>
             The main pool control state, controlState, is an <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/> packing
             two conceptual fields
               workerCount, indicating the effective number of threads
               runState,    indicating whether running, shutting down etc
            
             In order to pack them into one int, we limit workerCount to
             (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2
             billion) otherwise representable. If this is ever an issue in
             the future, the variable can be changed to be an <see cref="T:Spring.Threading.AtomicTypes.AtomicLong"/>,
             and the shift/mask constants below adjusted. But until the need
             arises, this code is a bit faster and simpler using an <see cref="T:System.Int32"/>.
            
             The workerCount is the number of workers that have been
             permitted to start and not permitted to stop.  The value may be
             transiently different from the actual number of live threads,
             for example when a <see cref="T:Spring.Threading.IThreadFactory"/> fails to create a thread when
             asked, and when exiting threads are still performing
             bookkeeping before terminating. The user-visible pool size is
             reported as the current size of the workers set.
            
             The runState provides the main lifecyle control, taking on values:
            
               RUNNING:  Accept new tasks and process queued tasks
               SHUTDOWN: Don't accept new tasks, but process queued tasks
               STOP:     Don't accept new tasks, don't process queued tasks,
                         and interrupt in-progress tasks
               TIDYING:  All tasks have terminated, workerCount is zero,
                         the thread transitioning to state TIDYING
                         will run the <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Terminated"/> hook method
               TERMINATED: <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Terminated"/> has completed
            
             The numerical order among these values matters, to allow
             ordered comparisons. The runState monotonically increases over
             time, but need not hit each state. The transitions are:
            
             RUNNING -&gt; SHUTDOWN
                On invocation of <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Shutdown"/>, perhaps implicitly in ~ThreadPoolExecutor
             (RUNNING or SHUTDOWN) -&gt; STOP
                On invocation of <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.ShutdownNow"/>
             SHUTDOWN -&gt; TIDYING
                When both queue and pool are empty
             STOP -&gt; TIDYING
                When pool is empty
             TIDYING -&gt; TERMINATED
                When the <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Terminated"/> hook method has completed
            
             Threads waiting in <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.AwaitTermination(System.TimeSpan)"/> will return when the
             state reaches TERMINATED.
            
             Detecting the transition from SHUTDOWN to TIDYING is less
             straightforward than you'd like because the queue may become
             empty after non-empty and vice versa during SHUTDOWN state, but
             we can only terminate if, after seeing that it is empty, we see
             that workerCount is 0 (which sometimes entails a recheck -- see
             below).
             </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._currentWorkerThreads">
            <summary> 
            Set containing all worker threads in pool. Accessed only when holding mainLock.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._mainLock">
            <summary> 
            Lock held on access to workers set and related bookkeeping.
            While we could use a concurrent set of some sort, it turns out
            to be generally preferable to use a lock. Among the reasons is
            that this serializes InterruptIdleWorkers, which avoids
            unnecessary interrupt storms, especially during shutdown.
            Otherwise exiting threads would concurrently interrupt those
            that have not yet interrupted. It also simplifies some of the
            associated statistics bookkeeping of largestPoolSize etc. We
            also hold mainLock on shutdown and shutdownNow, for the sake of
            ensuring workers set is stable while separately checking
            permission to interrupt and actually interrupting.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._workQueue">
            <summary> 
            The queue used for holding tasks and handing off to worker
            threads.  We do not require that workQueue.poll() returning
            null necessarily means that workQueue.isEmpty(), so rely
            solely on isEmpty to see if the queue is empty (which we must
            do for example when deciding whether to transition from
            SHUTDOWN to TIDYING).  This accommodates special-purpose
            queues such as DelayQueues for which poll() is allowed to
            return null even if it may later return non-null when delays
            expire.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._termination">
            <summary>
            Wait condition to support AwaitTermination
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._completedTaskCount">
            <summary> 
            Counter for completed tasks. Updated only on termination of
            worker threads.  Accessed only under mainlock
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._largestPoolSize">
            <summary> 
            Tracks largest attained pool size. Accessed only under mainLock.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._defaultRejectedExecutionHandler">
            <summary> 
            The default <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/>
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._corePoolSize">
            All user control parameters are declared as volatiles so that
            ongoing actions are based on freshest values, but without need
            for locking, since no internal invariants depend on them
            changing synchronously with respect to other actions.
            <summary> 
            Core pool size is the minimum number of workers to keep alive
            (and not allow to time out etc) unless _allowCoreThreadTimeOut
            is set, in which case the minimum is zero.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._keepAliveTicks">
            <summary> 
            Timeout for idle threads waiting for work. Threads use this 
            timeout when there are more than _corePoolSize present or 
            if _allowCoreThreadTimeOut. Otherwise they wait forever for 
            new work. We must use long instead of TimeSpan so that we
            can update it atomically. Add access must through property
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.KeepAliveTime"/>.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._allowCoreThreadToTimeOut">
            <summary> 
            If <c>false</c> (the default), core threads stay alive even when idle.
            If <c>true</c>, core threads use <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.KeepAliveTime"/> 
            to time out waiting for work.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._maximumPoolSize">
            <summary> 
            Maximum pool size. Note that the actual maximum is internally
            bounded by CAPACITY.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._rejectedExecutionHandler">
            <summary> 
            <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/> called when
            <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> is saturated or  
            <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Shutdown"/> in executed.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor._threadFactory">
            <summary> 
            Factory for new threads. All threads are created using this
            factory (via method AddWorker).  All callers must be prepared
            for AddWorker to fail, which may reflect a system or user's
            policy limiting the number of threads.  Even though it is not
            treated as an error, failure to create threads may result in
            new tasks being rejected or existing ones remaining stuck in
            the queue. On the other hand, no special precautions exist to
            handle OutOfMemoryErrors that might be thrown while trying to
            create threads, since there is generally no recourse from
            within this class.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.RunStateLessThan(System.Int32,System.Int32)">
            <summary>
            Bit field accessors that don't require unpacking _controlState.
            These depend on the bit layout and on workerCount being never negative.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.#ctor(System.Int32,System.Int32,System.TimeSpan,Spring.Threading.Collections.Generic.IBlockingQueue{Spring.Threading.IRunnable})">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> with the given initial
            parameters and default thread factory and rejected execution handler.
            </summary>
            <remarks>&gt;
            It may be more convenient to use one of the <see cref="T:Spring.Threading.Execution.Executors"/> factory
            methods instead of this general purpose constructor.
            </remarks>
            <param name="corePoolSize">the number of threads to keep in the pool, even if they are idle.</param>
            <param name="maximumPoolSize">the maximum number of threads to allow in the pool.</param>
            <param name="keepAliveTime">
            When the number of threads is greater than
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>, this is the maximum time that excess idle threads
            will wait for new tasks before terminating.
            </param>
            <param name="workQueue">
            The queue to use for holding tasks before they
            are executed. This queue will hold only the <see cref="T:Spring.Threading.IRunnable"/>
            tasks submitted by the <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> method.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="corePoolSize"/> or <paramref name="keepAliveTime"/> is less than zero, or if <paramref name="maximumPoolSize"/>
            is less than or equal to zero, or if <paramref name="corePoolSize"/> is greater than <paramref name="maximumPoolSize"/>
            </exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="workQueue"/> is null</exception>
            <throws>  NullPointerException if <tt>workQueue</tt> is null </throws>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.#ctor(System.Int32,System.Int32,System.TimeSpan,Spring.Threading.Collections.Generic.IBlockingQueue{Spring.Threading.IRunnable},Spring.Threading.IThreadFactory)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> with the given initial
            parameters and default <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>.
            </summary>
            <param name="corePoolSize">the number of threads to keep in the pool, even if they are idle.</param>
            <param name="maximumPoolSize">the maximum number of threads to allow in the pool.</param>
            <param name="keepAliveTime">
            When the number of threads is greater than
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>, this is the maximum time that excess idle threads
            will wait for new tasks before terminating.
            </param>
            <param name="workQueue">
            The queue to use for holding tasks before they
            are executed. This queue will hold only the <see cref="T:Spring.Threading.IRunnable"/>
            tasks submitted by the <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> method.
            </param>
            <param name="threadFactory">
            <see cref="T:Spring.Threading.IThreadFactory"/> to use for new thread creation.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="corePoolSize"/> or <paramref name="keepAliveTime"/> is less than zero, or if <paramref name="maximumPoolSize"/>
            is less than or equal to zero, or if <paramref name="corePoolSize"/> is greater than <paramref name="maximumPoolSize"/>
            </exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="workQueue"/> or <paramref name="threadFactory"/> is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.#ctor(System.Int32,System.Int32,System.TimeSpan,Spring.Threading.Collections.Generic.IBlockingQueue{Spring.Threading.IRunnable},Spring.Threading.Execution.IRejectedExecutionHandler)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> with the given initial
            parameters and <see cref="T:Spring.Threading.IThreadFactory"/>.
            </summary>
            <summary> 
            Creates a new <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> with the given initial
            parameters and default <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>.
            </summary>
            <param name="corePoolSize">the number of threads to keep in the pool, even if they are idle.</param>
            <param name="maximumPoolSize">the maximum number of threads to allow in the pool.</param>
            <param name="keepAliveTime">
            When the number of threads is greater than
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>, this is the maximum time that excess idle threads
            will wait for new tasks before terminating.
            </param>
            <param name="workQueue">
            The queue to use for holding tasks before they
            are executed. This queue will hold only the <see cref="T:Spring.Threading.IRunnable"/>
            tasks submitted by the <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> method.
            </param>
            <param name="handler">
            The <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/> to use when execution is blocked
            because the thread bounds and queue capacities are reached.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="corePoolSize"/> or <paramref name="keepAliveTime"/> is less than zero, or if <paramref name="maximumPoolSize"/>
            is less than or equal to zero, or if <paramref name="corePoolSize"/> is greater than <paramref name="maximumPoolSize"/>
            </exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="workQueue"/> or <paramref name="handler"/> is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.#ctor(System.Int32,System.Int32,System.TimeSpan,Spring.Threading.Collections.Generic.IBlockingQueue{Spring.Threading.IRunnable},Spring.Threading.IThreadFactory,Spring.Threading.Execution.IRejectedExecutionHandler)">
            <summary> Creates a new <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> with the given initial
            parameters.
            
            </summary>
            <param name="corePoolSize">the number of threads to keep in the pool, even if they are idle.</param>
            <param name="maximumPoolSize">the maximum number of threads to allow in the pool.</param>
            <param name="keepAliveTime">
            When the number of threads is greater than
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>, this is the maximum time that excess idle threads
            will wait for new tasks before terminating.
            </param>
            <param name="workQueue">
            The queue to use for holding tasks before they
            are executed. This queue will hold only the <see cref="T:Spring.Threading.IRunnable"/>
            tasks submitted by the <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/> method.
            </param>
            <param name="threadFactory">
            <see cref="T:Spring.Threading.IThreadFactory"/> to use for new thread creation.
            </param>
            <param name="handler">
            The <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/> to use when execution is blocked
            because the thread bounds and queue capacities are reached.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="corePoolSize"/> or <paramref name="keepAliveTime"/> is less than zero, or if <paramref name="maximumPoolSize"/>
            is less than or equal to zero, or if <paramref name="corePoolSize"/> is greater than <paramref name="maximumPoolSize"/>
            </exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="workQueue"/>, <paramref name="handler"/>, or <paramref name="threadFactory"/> is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.DoExecute(Spring.Threading.IRunnable)">
            <summary> 
            Executes the given task sometime in the future.  The task may 
            execute in a new thread or in an existing pooled thread.
            </summary>
            <remarks>
            If the task cannot be submitted for execution, either because this
            executor has been shutdown or because its capacity has been reached,
            the task is handled by the current <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/>
            for this <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/>.
            </remarks>
            <param name="command">the task to execute</param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            if the task cannot be accepted. 
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="command"/> is <c>null</c>
            </exception>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Remove(Spring.Threading.IRunnable)">
            <summary>
            Removes this task from the executor's internal queue if it is
            present, thus causing it not to be run if it has not already
            started.
            </summary>
            <remarks>
            This method may be useful as one part of a cancellation scheme.  
            It may fail to remove tasks that have been converted into other 
            forms before being placed on the internal queue. For example, a 
            task entered using <see cref="M:Spring.Threading.Execution.IExecutorService.Submit(System.Action)"/> 
            might be converted into a form that maintains <see cref="T:Spring.Threading.Future.IFuture`1"/> 
            status. However, in such cases, method <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Purge"/> may be 
            used to remove those Futures that have been cancelled.
            </remarks>
            <param name="task">The task to remove.</param>
            <returns><c>true</c> if the task was removed.</returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Remove(System.Action)">
            <summary>
            Removes this task from the executor's internal queue if it is
            present, thus causing it not to be run if it has not already
            started.
            </summary>
            <remarks>
            This method may be useful as one part of a cancellation scheme.  
            It may fail to remove tasks that have been converted into other 
            forms before being placed on the internal queue. For example, a 
            task entered using <see cref="M:Spring.Threading.Execution.IExecutorService.Submit(System.Action)"/> 
            might be converted into a form that maintains <see cref="T:Spring.Threading.Future.IFuture`1"/> 
            status. However, in such cases, method <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Purge"/> may be 
            used to remove those Futures that have been cancelled.
            </remarks>
            <param name="task">The task to remove.</param>
            <returns><c>true</c> if the task was removed.</returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Shutdown">
            <summary> 
            Initiates an orderly shutdown in which previously submitted
            tasks are executed, but no new tasks will be
            accepted. Invocation has no additional effect if already shut
            down.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.ShutdownNow">
             <summary> 
             Attempts to stop all actively executing tasks, halts the
             processing of waiting tasks, and returns a list of the tasks
             that were awaiting execution. These tasks are drained (removed)
             from the task queue upon return from this method.
            
             <p/>There are no guarantees beyond best-effort attempts to stop
             processing actively executing tasks.  This implementation
             cancels tasks via <see cref="M:System.Threading.Thread.Interrupt"/>, so any task that
             fails to respond to interrupts may never terminate.
            
             </summary> 
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.AwaitTermination(System.TimeSpan)">
            <summary> 
            Blocks until all tasks have completed execution after a shutdown
            request, or the timeout occurs, or the current thread is
            interrupted, whichever happens first. 
            </summary>
            <param name="duration">the time span to wait.
            </param>
            <returns> <c>true</c> if this executor terminated and <c>false</c>
            if the timeout elapsed before termination
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Purge">
            <summary> 
            Tries to remove from the work queue all <see cref="T:Spring.Threading.Future.IFuture`1"/>
            tasks that have been cancelled. This method can be useful as a
            storage reclamation operation, that has no other impact on
            functionality. Cancelled tasks are never executed, but may
            accumulate in work queues until worker threads can actively
            remove them. Invoking this method instead tries to remove them now.
            However, this method may fail to remove tasks in
            the presence of interference by other threads.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.PreStartCoreThread">
            <summary> 
            Starts a core thread, causing it to idly wait for work. This
            overrides the default policy of starting core threads only when
            new tasks are executed. This method will return <c>false</c>
            if all core threads have already been started.
            </summary>
            <returns><c>true</c> if a thread was started.</returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.PreStartAllCoreThreads">
            <summary> 
            Starts all core threads, causing them to idly wait for work. 
            </summary>
            <remarks>
            This overrides the default policy of starting core threads only when
            new tasks are executed.
            </remarks>
            <returns>the number of threads started.</returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.AdvanceRunState(System.Int32)">
            <summary>
            Transitions control state to given target or leaves if alone if
            already at least the given target.
            </summary>
            <param name="targetState">the desired state, either SHUTDOWN or STOP ( but 
            not TIDYING or TERMINATED -- use TryTerminate for that )</param>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.TryTerminate">
            <summary> 
            Transitions to TERMINATED state if either (SHUTDOWN and pool
            and queue empty) or (STOP and pool empty).  If otherwise
            eligible to terminate but workerCount is nonzero, interrupts an
            idle worker to ensure that shutdown signals propagate. This
            method must be called following any action that might make
            termination possible -- reducing worker count or removing tasks
            from the queue during shutdown. The method is non-private to
            allow access from ScheduledThreadPoolExecutor.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.InterruptWorkers">
            <summary> 
            Interrupts all threads, even if active. Ignores SecurityExceptions
            (in which case some threads may remain uninterrupted).
            </summary> 
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.DrainQueue">
            <summary> 
            Drains the task queue into a new list, normally using
            drainTo. But if the queue is a DelayQueue or any other kind of
            queue for which poll or drainTo may fail to remove some
            elements, it deletes them one by one.
            </summary> 
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.RunWorker(Spring.Threading.Execution.ThreadPoolExecutor.Worker)">
             <summary>
             Main worker run loop.  Repeatedly gets tasks from queue and
             executes them, while coping with a number of issues:
            
             1. We may start out with an initial task, in which case we
             don't need to get the first one. Otherwise, as long as pool is
             running, we get tasks from GetTask. If it returns null then the
             worker exits due to changed pool state or configuration
             parameters.  Other exits result from exception throws in
             external code, in which case completedAbruptly holds, which
             usually leads ProcessWorkerExit to replace this thread.
            
             2. Before running any task, the lock is acquired to prevent
             other pool interrupts while the task is executing, and
             ClearInterruptsForTaskRun called to ensure that unless pool is
             stopping, this thread does not have its interrupt set.
            
             3. Each task run is preceded by a call to BeforeExecute, which
             might throw an exception, in which case we cause thread to die
             (breaking loop with completedAbruptly true) without processing
             the task.
            
             4. Assuming BeforeExecute completes normally, we run the task,
             gathering any of its thrown exceptions to send to
             AfterExecute. We separately handle RuntimeException, Error
             (both of which the specs guarantee that we trap) and arbitrary
             Throwables.  Because we cannot rethrow Throwables within
             Runnable.run, we wrap them within Errors on the way out (to the
             thread's UncaughtExceptionHandler).  Any thrown exception also
             conservatively causes thread to die.
            
             5. After task.run completes, we call AfterExecute, which may
             also throw an exception, which will also cause thread to
             die. According to JLS Sec 14.20, this exception is the one that
             will be in effect even if task.run throws.
            
             The net effect of the exception mechanics is that AfterExecute
             and the thread's UncaughtExceptionHandler have as accurate
             information as we can provide about any problems encountered by
             user code.
            
             <param name="worker">the worker to run</param>
             </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.ProcessWorkerExit(Spring.Threading.Execution.ThreadPoolExecutor.Worker,System.Boolean)">
             <summary>
             Performs cleanup and bookkeeping for a dying worker. Called
             only from worker threads. Unless completedAbruptly is set,
             assumes that workerCount has already been adjusted to account
             for exit.  This method removes thread from worker set, and
             possibly terminates the pool or replaces the worker if either
             it exited due to user task exception or if fewer than
             corePoolSize workers are running or queue is non-empty but
             there are no workers.
            
             <param name="w">the worker</param>
             <param name="completedAbruptly">if the worker died to the user exception</param>
             </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.AddWorker(Spring.Threading.IRunnable,System.Boolean)">
             <summary>
             Checks if a new worker can be added with respect to current
             pool state and the given bound (either core or maximum). If so,
             the worker count is adjusted accordingly, and, if possible, a
             new worker is created and started running firstTask as its
             first task. This method returns false if the pool is stopped or
             eligible to shut down. It also returns false if the thread
             factory fails to create a thread when asked, which requires a
             backout of workerCount, and a recheck for termination, in case
             the existence of this worker was holding up termination.
             </summary>
            
             <param name="firstTask"> the task the new thread should run first (or
             null if none). Workers are created with an initial first task
             (in method <see cref="M:Spring.Threading.Execution.AbstractExecutorService.Execute(Spring.Threading.IRunnable)"/>) to bypass queuing when there are fewer
             than <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> threads (in which case we always start one),
             or when the queue is full (in which case we must bypass queue).
             Initially idle threads are usually created via
             <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.PreStartCoreThread"/> or to replace other dying workers.
             </param>
             <param name="core">
             if true use <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/> as bound, else
             <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize"/>. (A bool indicator is used here rather than a
             value to ensure reads of fresh values after checking other pool
             state).</param>
             <returns><c>true</c> if successful</returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.CompareAndIncrementWorkerCount(System.Int32)">
            <summary>
            Attempt to CAS-increment the workerCount field of control state.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.CompareAndDecrementWorkerCount(System.Int32)">
             <summary>
            Attempt to CAS-decrement the workerCount field of control state.
             </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.DecrementWorkerCount">
            <summary>
            Decrements the workerCount field of ctl. This is called only on
            abrupt termination of a thread (see ProcessWorkerExit). Other
            decrements are performed within GetTask.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.ClearInterruptsForTaskRun">
            <summary> 
            Ensures that unless the pool is stopping, the current thread
            does not have its interrupt set. This requires a double-check
            of state in case the interrupt was cleared concurrently with a
            shutdownNow -- if so, the interrupt is re-enabled.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.IsRunningOrShutdown(System.Boolean)">
             <summary> 
             State check needed by ScheduledThreadPoolExecutor to
             enable running tasks during shutdown.
             </summary>
            
             <param name="shutdownOK"><c>true</c> if should return true if SHUTDOWN.</param>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.GetTask">
             <summary> 
             Performs blocking or timed wait for a task, depending on
             current configuration settings, or returns null if this worker
             must exit because of any of:
             1. There are more than maximumPoolSize workers (due to
                a call to setMaximumPoolSize).
             2. The pool is stopped.
             3. The pool is shutdown and the queue is empty.
             4. This worker timed out waiting for a task, and timed-out
                workers are subject to termination (that is,
                <c>allowCoreThreadTimeOut || workerCount &gt; corePoolSize</c>)
                both before and after the timed wait.
             </summary> 
            <returns><see cref="T:Spring.Threading.IRunnable"/> task or <c>null</c>
             if the worker must exit, in which case workerCount is decremented
             </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Reject(Spring.Threading.IRunnable)">
            <summary> 
            Invokes the rejected execution handler for the given command.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.InterruptIdleWorkers">
            <summary> 
            Interrupts all threads that might be waiting for tasks.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.InterruptIdleWorkers(System.Boolean)">
             <summary> 
             Interrupts threads that might be waiting for tasks (as
             indicated by not being locked) so they can check for
             termination or configuration changes. Ignores
             SecurityExceptions (in which case some threads may remain
             uninterrupted).
            
             @param onlyOne If true, interrupt at most one worker. This is
             called only from TryTerminate when termination is otherwise
             enabled but there are still other workers.  In this case, at
             most one waiting worker is interrupted to propagate shutdown
             signals in case all threads are currently waiting.
             Interrupting any arbitrary thread ensures that newly arriving
             workers since shutdown began will also eventually exit.
             To guarantee eventual termination, it suffices to always
             interrupt only one idle worker, but shutdown() interrupts all
             idle workers so that redundant workers exit promptly, not
             waiting for a straggler task to finish.
             </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.BeforeExecute(System.Threading.Thread,Spring.Threading.IRunnable)">
            <summary> 
            Method invoked prior to executing the given <see cref="T:Spring.Threading.IRunnable"/> in the
            given thread.  
            </summary>
            <remarks>
            This method is invoked by <paramref name="thread"/> that
            will execute <paramref name="runnable"/>, and may be used to re-initialize
            ThreadLocals, or to perform logging. This implementation does
            nothing, but may be customized in subclasses. <b>Note:</b> To properly
            nest multiple overridings, subclasses should generally invoke
            <i>base.BeforeExecute</i> at the end of this method.
            </remarks>
            <param name="thread">the thread that will run <paramref name="runnable"/>.</param>
            <param name="runnable">the task that will be executed.</param>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.AfterExecute(Spring.Threading.IRunnable,System.Exception)">
            <summary>
            Method invoked upon completion of execution of the given Runnable.
            This method is invoked by the thread that executed the task. If
            non-null, the <paramref name="exception"/> is the unhandle
            exception that caused execution to terminate abruptly.
            </summary>
            <remarks>
            <para>
            This implementation does nothing, but may be customized in
            subclasses. Note: To properly nest multiple overridings, subclasses
            should generally invoke <c>base.AfterExecute</c> at the
            beginning of this method.
            </para>
            <para>
            <b>Note:</b> When actions are enclosed in tasks (such as
            <see cref="T:Spring.Threading.Future.FutureTask`1"/>) either explicitly or via methods such
            as <see cref="M:Spring.Threading.Execution.IExecutorService.Submit(System.Action)"/>, these task
            objects catch and maintain computational exceptions, and so they do
            not cause abrupt termination, and the internal exceptions are
            <i>not</i> passed to this method. If you would like to trap both 
            kinds of failures in this method, you can further probe for such 
            cases, as in this sample subclass that prints either the direct 
            cause or the underlying exception if a task has been aborted:
            </para>
            <code language="c#">
            class ExtendedExecutor : ThreadPoolExecutor {
              // ...
              protected void AfterExecute(IRunnable r, Exception t) {
                base.AfterExecute(r, t);
                if (t == null &amp;&amp; r is IFuture) {
                  try {
                    Object result = ((IFuture) r).GetResult();
                  } catch (CancellationException ce) {
                      t = ce;
                  } catch (ExecutionException ee) {
                      t = ee.InnerException;
                  } catch (InterruptedException ie) {
                      Thread.CurrentThread.Interrupt(); // ignore/reset
                  }
                }
                if (t != null)
                  Console.WriteLine(t);
              }
            }
            </code>
            </remarks>
            <param name="runnable">The runnable that has completed.</param>
            <param name="exception">
            The exception that caused termination, or <c>null</c> if
            execution completed normally.
            </param>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.OnShutdown">
             <summary> 
            Performs any further cleanup following run state transition on
             invocation of shutdown.  A no-op here, but used by
             ScheduledThreadPoolExecutor to cancel delayed tasks.
             </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Terminated">
            <summary> 
            Method invoked when the <see cref="T:Spring.Threading.IExecutor"/> has terminated.  
            Default implementation does nothing. 
            <p/>
            <b>Note:</b> To properly nest multiple
            overridings, subclasses should generally invoke
            <i>base.terminated</i> within this method.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Dispose">
            <summary>
            Shutsdown and disposes of this <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Dispose(System.Boolean)">
            <summary>
            Helper method to dispose of this <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/>
            </summary>
            <param name="disposing"><c>true</c> if being called from <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Dispose"/>,
            <c>false</c> if being called from finalizer.</param>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.KeepAliveTime">
            <summary> 
            Gets and sets the time limit for which threads may remain idle before
            being terminated.  
            </summary>
            <remarks>
            If there are more than the core number of
            threads currently in the pool, after waiting this amount of
            time without processing a task, excess threads will be
            terminated.
            </remarks>
            <exception cref="T:System.ArgumentException">
            if <i>value</i> is less than 0 or if <i>value</i> equals 0 and 
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.AllowsCoreThreadsToTimeOut"/> is 
            <c>true</c>
            </exception>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.AllowsCoreThreadsToTimeOut">
            <summary>
            Returns <c>true</c> if this pool allows core threads to time out and
            terminate if no tasks arrive within the keepAlive time, being
            replaced if needed when new tasks arrive. 
            </summary>
            <remarks>
            When true, the same keep-alive policy applying to non-core threads applies also to
            core threads. When false (the default), core threads are never
            terminated due to lack of incoming tasks.
            </remarks>
            <returns> 
            Sets the policy governing whether core threads may time out and
            terminate if no tasks arrive within the keep-alive time, being
            replaced if needed when new tasks arrive. When false, core
            threads are never terminated due to lack of incoming
            tasks. When true, the same keep-alive policy applying to
            non-core threads applies also to core threads. To avoid
            continual thread replacement, the keep-alive time must be
            greater than zero when setting <c>true</c>. This method
            should in general be called before the pool is actively used.
            </returns>
            <exception cref="T:System.ArgumentException">
            If <c>true</c> and keep alive time is less than or equal to 0
            </exception>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.IsTerminating">
            <summary> 
            Returns <c>true</c> if this executor is in the process of terminating
            after <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.Shutdown"/> or
            <see cref="M:Spring.Threading.Execution.ThreadPoolExecutor.ShutdownNow"/> but has not
            completely terminated.  
            </summary>
            <remarks>
            This method may be useful for debugging. A return of <c>true</c> reported a sufficient
            period after shutdown may indicate that submitted tasks have
            ignored or suppressed interruption, causing this executor not
            to properly terminate.
            </remarks>
            <returns><c>true</c>if terminating but not yet terminated.</returns>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.ThreadFactory">
            <summary>
            Gets / Sets the thread factory used to create new threads.
            </summary>
            <returns>the current thread factory</returns>
            <exception cref="T:System.ArgumentNullException">if the threadfactory is null</exception>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.RejectedExecutionHandler">
            <summary> 
            Gets / Sets the current handler for unexecutable tasks.
            </summary>
            <returns>the current handler</returns>
            <exception cref="T:System.ArgumentNullException">if the execution handler is null.</exception>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.Queue">
            <summary> 
            Returns the task queue used by this executor. Access to the
            task queue is intended primarily for debugging and monitoring.
            This queue may be in active use.  Retrieving the task queue
            does not prevent queued tasks from executing.
            </summary>
            <returns>the task queue</returns>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize">
            <summary> 
            Sets the core number of threads.  This overrides any value set
            in the constructor.  If the new value is smaller than the
            current value, excess existing threads will be terminated when
            they next become idle.  If larger, new threads will, if needed,
            be started to execute any queued tasks.
            </summary>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.PoolSize">
            <summary>
             Returns the current number of threads in the pool.
             </summary>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.ActiveCount">
            <summary>
            Returns the approximate number of threads that are actively
            executing tasks.
            </summary>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.MaximumPoolSize">
            <summary> 
            Gets / Sets the maximum allowed number of threads. 
            </summary>
            <remarks>
            This overrides any
            value set in the constructor. If the new value is smaller than
            the current value, excess existing threads will be
            terminated when they next become idle.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">If value is less than zero or less than 
            <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.CorePoolSize"/>. 
            </exception>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.LargestPoolSize">
            <summary> 
            Returns the largest number of threads that have ever
            simultaneously been in the pool.
            </summary>
            <returns> the number of threads</returns>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.TaskCount">
            <summary> 
            Returns the approximate total number of tasks that have been
            scheduled for execution. 
            </summary>
            <remarks>
            Because the states of tasks and
            threads may change dynamically during computation, the returned
            value is only an approximation
            </remarks>
            <returns>the number of tasks</returns>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.CompletedTaskCount">
            <summary> 
            Returns the approximate total number of tasks that have
            completed execution. 
            </summary>
            <remarks>
            Because the states of tasks and threads
            may change dynamically during computation, the returned value
            is only an approximation, but one that does not ever decrease
            across successive calls.
            </remarks>
            <returns>the number of tasks</returns>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.IsShutdown">
            <summary> 
            Returns <c>true</c> if this executor has been shut down.
            </summary>
            <returns> 
            Returns <c>true</c> if this executor has been shut down.
            </returns>
        </member>
        <member name="P:Spring.Threading.Execution.ThreadPoolExecutor.IsTerminated">
            <summary> 
            Returns <c>true</c> if all tasks have completed following shut down.
            </summary>
            <remarks>
            Note that this will never return <c>true</c> unless
            either <see cref="M:Spring.Threading.Execution.IExecutorService.Shutdown"/> or 
            <see cref="M:Spring.Threading.Execution.IExecutorService.ShutdownNow"/> was called first.
            </remarks>
            <returns> <c>true</c> if all tasks have completed following shut down</returns>
        </member>
        <member name="T:Spring.Threading.Execution.ThreadPoolExecutor.Worker">
            <summary>
            Class Worker mainly maintains interrupt control state for
            threads running tasks, along with other minor bookkeeping. This
            class opportunistically extends ReentrantLock to simplify
            acquiring and releasing a lock surrounding each task execution.
            This protects against interrupts that are intended to wake up a
            worker thread waiting for a task from instead interrupting a
            task being run.
            </summary>
        </member>
        <member name="T:Spring.Threading.Locks.ReentrantLock">
            <summary> 
            A reentrant mutual exclusion <see cref="T:Spring.Threading.Locks.ILock"/> with the same basic
            behavior and semantics as the implicit monitor lock accessed using
            <c>lock</c> statements, but with extended capabilities.
            </summary>
            <remarks>
            <para>
            A <see cref="T:Spring.Threading.Locks.ReentrantLock"/> is <b>owned</b> by the thread last
            successfully locking, but not yet unlocking it. A thread invoking
            <see cref="M:Spring.Threading.Locks.ReentrantLock.Lock"/> will return, successfully acquiring the lock, when
            the lock is not owned by another thread. The method will return
            immediately if the current thread already owns the lock. This can
            be checked using methods <see cref="P:Spring.Threading.Locks.ReentrantLock.IsHeldByCurrentThread"/>, and 
            <see cref="P:Spring.Threading.Locks.ReentrantLock.HoldCount"/>.
            </para>
            <para>
            The constructor for this class accepts an optional
            <b>fairness</b> parameter.  When set <c>true</c>, under
            contention, locks favor granting access to the longest-waiting
            thread.  Otherwise this lock does not guarantee any particular
            access order.  Programs using fair locks accessed by many threads
            may display lower overall throughput (i.e., are slower; often much
            slower) than those using the default setting, but have smaller
            variances in times to obtain locks and guarantee lack of
            starvation. Note however, that fairness of locks does not guarantee
            fairness of thread scheduling. Thus, one of many threads using a
            fair lock may obtain it multiple times in succession while other
            active threads are not progressing and not currently holding the
            lock.
            Also note that the untimed <see cref="M:Spring.Threading.Locks.ReentrantLock.TryLock"/> method does not
            honor the fairness setting. It will succeed if the lock
            is available even if other threads are waiting.
            </para>
            <para>
            It is recommended practice to <b>always</b> immediately follow a call 
            to <see cref="M:Spring.Threading.Locks.ReentrantLock.Lock"/> with a <c>try</c> block or make user of
            the <c>using</c> keyward in C#, most typically in a before/after 
            construction such as:
            
            <code>
            class X {
            	private ReentrantLock lock = new ReentrantLock();
            	// ...
            
            	public void m() {
            		lock.Lock();  // block until condition holds
            		try {
            			// ... method body
            		} finally {
            			lock.Unlock()
            		}
            	}
            }
            </code>
            </para>
            <para>
            In addition to implementing the <see cref="T:Spring.Threading.Locks.ILock"/> interface, this
            class defines methods <see cref="P:Spring.Threading.Locks.ReentrantLock.IsLocked"/> and
            <see cref="M:Spring.Threading.Locks.ReentrantLock.GetWaitQueueLength(Spring.Threading.Locks.ICondition)"/> , as well as some associated
            <c>protected</c> access methods that may be useful for
            instrumentation and monitoring.
            </para>
            <para>
            Serialization of this class behaves in the same way as built-in
            locks: a deserialized lock is in the unlocked state, regardless of
            its state when serialized.
            </para>
            <para>
            This lock supports a maximum of 2147483648 recursive locks by
            the same thread.
            </para>
            </remarks>
            <author>Doug Lea</author>
            <author>Dawid Kurzyniec</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="T:Spring.Threading.Locks.ILock">
            <summary> 
            <see cref="T:Spring.Threading.Locks.ILock"/> implementations provide more extensive locking
            operations than can be obtained using <see cref="T:System.Threading.Monitor"/> class and 
            <c>lock</c> statements.  They allow more flexible structuring, may have
            quite different properties, and may support multiple associated
            <see cref="T:Spring.Threading.Locks.ICondition"/> objects.
            </summary>
            <remarks>
            <para>
            A lock is a tool for controlling access to a shared resource by
            multiple threads. Commonly, a lock provides exclusive access to a
            shared resource: only one thread at a time can acquire the lock and
            all access to the shared resource requires that the lock be
            acquired first. However, some locks may allow concurrent access to
            a shared resource, such as the read lock of a <see cref="T:Spring.Threading.Locks.IReadWriteLock"/> 
            </para>
            <para>
            The use of <see cref="T:System.Threading.Monitor"/> class or <c>lock</c> statement provides
            access to the implicit monitor lock associated with every object, but
            forces all lock acquisition and release to occur in a block-structured way:
            when multiple locks are acquired they must be released in the opposite
            order, and all locks must be released in the same lexical scope in which
            they were acquired.
            </para>
            <para>
            While the scoping mechanism for <see cref="T:System.Threading.Monitor"/> or <c>lock</c>
            statements makes it much easier to program with monitor locks,
            and helps avoid many common programming errors involving locks,
            there are occasions where you need to work with locks in a more
            flexible way. For example, some algorithms for traversing
            concurrently accessed data structures require the use of
            'hand-over-hand' or 'chain locking': you
            acquire the lock of node A, then node B, then release A and acquire
            C, then release B and acquire D and so on.  Implementations of the
            <see cref="T:Spring.Threading.Locks.ILock"/> interface enable the use of such techniques by
            allowing a lock to be acquired and released in different scopes,
            and allowing multiple locks to be acquired and released in any
            order.
            </para>
            <para>
            With this increased flexibility comes additional responsibility. The
            absence of block-structured locking removes the automatic release of
            locks that occurs with <c>lock</c> statements. In most cases, the
            following idiom should be used:
            
            <code>
            ILock l = ...;
            l.Lock();
            try {
                // access the resource protected by this lock
            } finally {
            	l.Unlock();
            }
            </code> 
            -or-
            <code>
            ILock l = ...;
            using(l.Lock())
            {
            // access the resource protected by this lock
            }
            </code> 
            </para>
            <para>
            When locking and unlocking occur in different scopes, care must be
            taken to ensure that all code that is executed while the lock is
            held is protected by try-finally or try-catch to ensure that the
            lock is released when necessary.
            </para>
            <para>
            <see cref="T:Spring.Threading.Locks.ILock"/> implementations provide additional functionality
            over the use of <see cref="T:System.Threading.Monitor"/> class and <c>lock</c> statement
            by providing a non-blocking attempt to acquire a lock 
            (<see cref="M:Spring.Threading.Locks.ILock.TryLock"/>), an attempt to acquire the lock that can be
            interrupted <see cref="M:Spring.Threading.Locks.ILock.LockInterruptibly"/>}, and an attempt to acquire
            the lock that can timeout (<see cref="M:Spring.Threading.Locks.ILock.TryLock(System.TimeSpan)"/>).
            </para>
            <para>
            An <see cref="T:Spring.Threading.Locks.ILock"/> class can also provide behavior and semantics
            that is quite different from that of the implicit monitor lock,
            such as guaranteed ordering, non-reentrant usage, or deadlock
            detection. If an implementation provides such specialized semantics
            then the implementation must document those semantics.
            </para>
            <para>
            Note that <see cref="T:Spring.Threading.Locks.ILock"/> instances are just normal objects and can
            themselves be used as the target in a <c>lock</c> statement. Acquiring
            the monitor lock of a <see cref="T:Spring.Threading.Locks.ILock"/> instance has no specified
            relationship with invoking any of the <see cref="M:Spring.Threading.Locks.ILock.Lock"/> methods of
            that instance. It is recommended that to avoid confusion you never use
            <see cref="T:Spring.Threading.Locks.ILock"/> instances in this way, except within their own
            implementation.
            </para>
            <para>
            Except where noted, passing a <c>null</c> value for any parameter will
            result in a <see cref="T:System.NullReferenceException"/> being thrown.
            </para>
            <para>
            <b>Memory Synchronization</b>
            <br/>
            All <see cref="T:Spring.Threading.Locks.ILock"/> implementations <b>must</b> enforce the same
            memory synchronization semantics as provided by the built-in monitor
            lock. 
            <list type="bullet">
            <item>A successful <see cref="M:Spring.Threading.Locks.ILock.Lock"/> operation has the same memory
            synchronization effects as a successful <see cref="M:System.Threading.Monitor.Enter(System.Object)"/>
            action.</item>
            <item>A successful <see cref="M:Spring.Threading.Locks.ILock.Unlock"/> operation has the same memory
            synchronization effects as a successful <see cref="M:System.Threading.Monitor.Exit(System.Object)"/>
            action.</item>
            </list>
            Unsuccessful locking and unlocking operations, and reentrant
            locking/unlocking operations, do not require any memory synchronization
            effects.
            </para>
            <para>
            <b>Implementation Considerations</b>
            <list type="bullet">
            <item>
            The three forms of lock acquisition (interruptible, non-interruptible, 
            and timed) may differ in their performance characteristics, ordering
            guarantees, or other implementation qualities.  Further, the ability
            to interrupt the <b>ongoing</b> acquisition of a lock may not be
            available in a given <see cref="T:Spring.Threading.Locks.ILock"/> class.  Consequently, an
            implementation is not required to define exactly the same guarantees
            or semantics for all three forms of lock acquisition, nor is it
            required to support interruption of an ongoing lock acquisition.  An
            implementation is required to clearly document the semantics and
            guarantees provided by each of the locking methods. It must also obey
            the interruption semantics as defined in this interface, to the extent
            that interruption of lock acquisition is supported: which is either
            totally, or only on method entry.
            </item>
            <item>
            As interruption generally implies cancellation, and checks for
            interruption are often infrequent, an implementation can favor responding
            to an interrupt over normal method return. This is true even if it can be
            shown that the interrupt occurred after another action may have unblocked
            the thread. An implementation should document this behavior.
            </item>
            </list>
            </para>
            </remarks>
            <seealso cref="T:Spring.Threading.Locks.ReentrantLock"/>
            <seealso cref="T:Spring.Threading.Locks.ICondition"/>
            <seealso cref="T:Spring.Threading.Locks.IReadWriteLock"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Locks.ILock.Lock">
            <summary> 
            Acquires the lock. If the lock is not available then the current
            thread becomes disabled for thread scheduling purposes and lies
            dormant until the lock has been acquired.
            </summary>
            <remarks>
            <para>
            <b>Implementation Considerations</b>
            <br/>
            An <see cref="T:Spring.Threading.Locks.ILock"/> implementation may be able to detect
            erroneous use of the lock, such as an invocation that would cause
            deadlock, and may throw an exception in such circumstances. The
            circumstances and the exception type must be documented by that
            <see cref="T:Spring.Threading.Locks.ILock"/> implementation.
            </para>
            </remarks>
            <returns>
            An <see cref="T:System.IDisposable"/> that <see cref="M:Spring.Threading.Locks.ILock.Unlock"/>s the lock
            upon <see cref="M:System.IDisposable.Dispose"/>.
            </returns>
        </member>
        <member name="M:Spring.Threading.Locks.ILock.LockInterruptibly">
            <summary> 
            Acquires the lock if it is available and returns immediately, or
            wait for the lock to become available unless the current thread is
            interrupted by a call to <see cref="M:System.Threading.Thread.Interrupt"/>.
            </summary>
            <remarks>
            <para>
            If the lock is not available then the current thread becomes
            disabled for thread scheduling purposes and lies dormant until one
            of two things happens:
            <list type="bullet">
            <item>The lock is acquired by the current thread.</item>
            <item>Some other thread interrupts the current thread by calling
            <see cref="M:System.Threading.Thread.Interrupt"/>, and interruption of lock
            acquisition is supported.</item>
            </list>
            </para>
            <para>
            If the current thread:
            <list type="bullet">
            <item>has its interrupted status set on entry to this method</item>
            <item>is interrupted while acquiring the lock, and interruption of
            lock acquisition is supported</item>
            </list>
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the
            current thread's interrupted status is cleared.
            </para>
            <para>
            <b>Implementation Considerations</b>
            <br/>
            The ability to interrupt a lock acquisition in some implementations
            may not be possible, and if possible may be an expensive operation.
            The programmer should be aware that this may be the case. An
            implementation should document when this is the case.
            </para>
            <para>
            An implementation can favor responding to an interrupt over
            normal method return.
            </para>
            <para>
            A <see cref="T:Spring.Threading.Locks.ILock"/> implementation may be able to detect
            erroneous use of the lock, such as an invocation that would cause
            deadlock, and may throw an exception in such circumstances.  The
            circumstances and the exception type must be documented by that
            <see cref="T:Spring.Threading.Locks.ILock"/> implementation.
            </para>
            </remarks>
            <returns>
            An <see cref="T:System.IDisposable"/> that <see cref="M:Spring.Threading.Locks.ILock.Unlock"/>s the lock
            open <see cref="M:System.IDisposable.Dispose"/>.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread is interrupted while acquiring the lock (and
            interruption of lock acquisition is supported).
            </exception>
            <seealso cref="M:System.Threading.Thread.Interrupt"/>
        </member>
        <member name="M:Spring.Threading.Locks.ILock.TryLock">
            <summary> 
            Acquires the lock only if it is free at the time of invocation.
            </summary>
            <remarks>
            <para>
            Acquires the lock if it is available and returns immediately with
            the value <c>true</c>.  If the lock is not available then this
            method will return immediately with the value <c>false</c>.
            </para>
            <para>
            A typical usage idiom for this method would be:
            <code> 
            ILock lock = ...;
            if (lock.TryLock()) {
            	try {
            	// manipulate protected state
            	} finally {
            		lock.Unlock();
            	}
            } else {
            	// perform alternative actions
            }
            </code>
            </para>
            <para>
            This usage ensures that the lock is unlocked if it was acquired,
            and doesn't try to unlock if the lock was not acquired.
            </para>
            </remarks>
            <returns>
            <c>true</c> if the lock was acquired and <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.Locks.ILock.TryLock(System.TimeSpan)">
            <summary> 
            Acquires the lock if it is free within the specified
            <paramref name="timeSpan"/> time and the current thread has not
            been interrupted by calling <see cref="M:System.Threading.Thread.Interrupt"/>.
            </summary>
            <remark>
            <para>
            If the lock is available this method returns immediately with the
            value <c>true</c>. If the lock is not available then the current
            thread becomes disabled for thread scheduling purposes and lies
            dormant until one of three things happens:
            <list type="bullet">
            <item>The lock is acquired by the current thread.</item>
            <item>Some other thread interrupts the current thread, and
            interruption of lock acquisition is supported.</item>
            <item>The specified <paramref name="timeSpan"/> elapses.</item>
            </list>
            </para>
            <para>
            If the lock is acquired then the value <c>true</c> is returned.
            </para>
            <para>
            If the current thread:
            <list type="bullet">
            <item>has its interrupted status set on entry to this method;</item>
            <item>is interrupted while acquiring the lock, and interruption of
            lock acquisition is supported.</item>
            </list>
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the
            current thread's interrupted status is cleared.
            </para>
            <para>
            If the specified <paramref name="timeSpan"/> elapses then the value
            <c>false</c> is returned.  If the <paramref name="timeSpan"/> is
            less than or equal to zero, the method will not wait at all.
            </para>
            <para>
            <b>Implementation Considerations</b>
            <br/>
            The ability to interrupt a lock acquisition in some implementations
            may not be possible, and if possible may be an expensive operation.
            The programmer should be aware that this may be the case. An
            implementation should document when this is the case.
            </para>
            <para>
            An implementation can favor responding to an interrupt over normal
            method return, or reporting a timeout.
            </para>
            <para>
            An <see cref="T:Spring.Threading.Locks.ILock"/> implementation may be able to detect
            erroneous use of the lock, such as an invocation that would cause
            deadlock, and may throw an exception in suchcircumstances. The
            circumstances and the exception type must be documented by that
            <see cref="T:Spring.Threading.Locks.ILock"/> implementation.
            </para>
            </remark>
            <param name="timeSpan">
            The specificed <see cref="T:System.TimeSpan"/> to wait to aquire lock.
            </param>
            <returns>
            <c>true</c> if the lock was acquired and <c>false</c> if the
            waiting time elapsed before the lock was acquired.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread is interrupted while aquirign the lock (and
            interruption of lock acquisition is supported).
            </exception>
            <seealso cref="M:System.Threading.Thread.Interrupt"/>
        </member>
        <member name="M:Spring.Threading.Locks.ILock.Unlock">
            <summary> 
            Releases the lock.
            </summary>
            <remarks>
            <b>Implementation Considerations</b>
            <br/>
            An <see cref="T:Spring.Threading.Locks.ILock"/> implementation will usually impose
            restrictions on which thread can release a lock (typically only the
            holder of the lock can release it) and may throw an exception if
            the restriction is violated. Any restrictions and the exception
            type must be documented by that <see cref="T:Spring.Threading.Locks.ILock"/> implementation.
            </remarks>
        </member>
        <member name="M:Spring.Threading.Locks.ILock.NewCondition">
            <summary> 
            Returns a new <see cref="T:Spring.Threading.Locks.ICondition"/> instance that is bound to
            this <see cref="T:Spring.Threading.Locks.ILock"/> instance.
            </summary>
            <remarks>
            <para>
            Before waiting on the condition the lock must be held by the
            current thread.  A call to <see cref="M:Spring.Threading.Locks.ICondition.Await"/> will
            atomically release the lock before waiting and re-acquire the lock
            before the wait returns.
            </para>
            <para>
            <b>Implementation Considerations</b>
            <br/>
            The exact operation of the <see cref="T:Spring.Threading.Locks.ICondition"/> instance
            depends on the <see cref="T:Spring.Threading.Locks.ILock"/> implementation and must be
            documented by that implementation.
            </para>
            </remarks>
            <returns>
            A new <see cref="T:Spring.Threading.Locks.ICondition"/> instance for this 
            <see cref="T:Spring.Threading.Locks.ILock"/> instance.
            </returns>
            <exception cref="T:System.NotSupportedException">
            If this <see cref="T:Spring.Threading.Locks.ILock"/> implementation does not support
            conditions.
            </exception>
        </member>
        <member name="T:Spring.Threading.Locks.ConditionVariable">
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.Locks.ICondition">
            <summary>
            <see cref="T:Spring.Threading.Locks.ICondition"/> factors out the <see cref="T:System.Threading.Monitor"/>
            methods <see cref="M:System.Threading.Monitor.Wait(System.Object)"/>, <see cref="M:System.Threading.Monitor.Pulse(System.Object)"/>
            and <see cref="M:System.Threading.Monitor.PulseAll(System.Object)"/> into distinct objects to
            give the effect of having multiple wait-sets per object, by combining
            them with the use of arbitrary <see cref="T:Spring.Threading.Locks.ILock"/> implementations.
            Where a <see cref="T:Spring.Threading.Locks.ILock"/> replaces the use of <c>lock</c> statements
            or <see cref="M:System.Threading.Monitor.Exit(System.Object)"/> methods,
            a <see cref="T:Spring.Threading.Locks.ICondition"/> replaces the use of the wait and pause
            methods of <see cref="T:System.Threading.Monitor"/>.
            </summary>
            <remarks>
            <para>
            Conditions (also known as <b>condition queues</b> or <b>condition
            variables</b>) provide a means for one thread to suspend execution (to
            'wait') until notified by another thread that some state condition may
            now be true.  Because access to this shared state information occurs
            in different threads, it must be protected, so a lock of some form is
            associated with the condition. The key property that waiting for a
            condition provides is that it <b>atomically</b> releases the associated
            lock and suspends the current thread, just like
            <see cref="M:System.Threading.Monitor.Wait(System.Object)"/>.
            </para>
            <para>
            An <see cref="T:Spring.Threading.Locks.ICondition"/> instance is intrinsically bound to a lock.
            To obtain a <see cref="T:Spring.Threading.Locks.ICondition"/> instance for a particular
            <see cref="T:Spring.Threading.Locks.ILock"/> instance use its <see cref="M:Spring.Threading.Locks.ILock.NewCondition"/>
            method.
            </para>
            <example>
            As an example, suppose we have a bounded buffer which supports put and
            take methods.  If a take is attempted on an empty buffer, then the
            thread will block until an item becomes available; if a put is attempted
            on a full buffer, then the thread will block until a space becomes
            available.  We would like to keep waiting put threads and take threads
            in separate wait-sets so that we can use the optimization of only
            notifying a single thread at a time when items or spaces become available
            in the buffer. This can be achieved using two <see cref="T:Spring.Threading.Locks.ICondition"/>
            instances.
            <code language="c#">
            class BoundedBuffer {
            	readonly ILock lock = new ReentrantLock();
            	readonly ICondition notFull  = lock.NewCondition();
            	readonly ICondition notEmpty = lock.NewCondition();
            
            	readonly object[] items = new object[100];
            	int putptr, takeptr, count;
            
            	public void Put(object x) {
            		using(lock.Lock()) {
            			while (count == items.Length) {
            				notFull.Await();
            				items[putptr] = x;
             				if (++putptr == items.Length) putptr = 0;
             				++count;
             				notEmpty.Signal();
             			}
            		}
                }
             
                public object Take() {
            		using(lock.Lock()) {
             			while (count == 0) {
             				notEmpty.Await();
             				object x = items[takeptr];
             				if (++takeptr == items.Length) takeptr = 0;
             				--count;
             				notFull.Signal();
             			return x;
             		}
             	}
            }
            </code>
            
            (The <see cref="T:Spring.Threading.Collections.Generic.ArrayBlockingQueue`1"/> class provides this
            functionality, so there is no reason to implement this sample usage
            class.)
            </example>
            <para>
            An <see cref="T:Spring.Threading.Locks.ICondition"/> implementation can provide behavior and
            semantics that is different from that of the <see cref="T:System.Threading.Monitor"/>
            methods, such as guaranteed ordering for notifications, or not
            requiring a lock to be held when performing notifications. If an
            implementation provides such specialized semantics then the
            implementation must document those semantics.
            </para>
            <para>
            Note that <see cref="T:Spring.Threading.Locks.ICondition"/> instances are just normal objects
            and can themselves be used as the target in a synchronized statement,
            and can have <see cref="M:System.Threading.Monitor.Wait(System.Object)"/> and
            <see cref="M:System.Threading.Monitor.Pulse(System.Object)"/> methods invoked on them. Acquiring
            the monitor lock of a <see cref="T:Spring.Threading.Locks.ICondition"/> instance, or using it as
            a parameter to <see cref="T:System.Threading.Monitor"/> methods, has no specified
            relationship with acquiring the <see cref="T:Spring.Threading.Locks.ILock"/> associated with
            that <see cref="T:Spring.Threading.Locks.ICondition"/> or the use of its <see cref="M:Spring.Threading.Locks.ICondition.Await"/>
            and <see cref="M:Spring.Threading.Locks.ICondition.Signal"/> methods. It is recommended that to avoid
            confusion you never use <see cref="T:Spring.Threading.Locks.ICondition"/> instances in this way,
            except perhaps within their own implementation.
            </para>
            <para>
            Except where noted, passing a <c>null</c> value for any parameter
            will result in a <see cref="T:System.NullReferenceException"/> being thrown.
            </para>
            <para>
            <b>Implementation Considerations</b>
            </para>
            <para>
            When waiting upon a <see cref="T:Spring.Threading.Locks.ICondition"/>, a '<b>spurious wakeup</b>'
            is permitted to occur, in general, as a concession to the underlying
            platform semantics. This has little practical impact on most application
            programs as a <see cref="T:Spring.Threading.Locks.ICondition"/> should always be waited upon in
            a loop, testing the state predicate that is being waited for.  An
            implementation is free to remove the possibility of spurious wakeups
            but it is recommended that applications programmers always assume that
            they can occur and so always wait in a loop.
            </para>
            <para>
            The three forms of condition waiting (interruptible, non-interruptible,
            and timed) may differ in their ease of implementation on some platforms
            and in their performance characteristics. In particular, it may be
            difficult to provide these features and maintain specific semantics
            such as ordering guarantees.  Further, the ability to interrupt the
            actual suspension of the thread may not always be feasible to implement
            on all platforms.
            </para>
            <para>
            Consequently, an implementation is not required to define exactly the
            same guarantees or semantics for all three forms of waiting, nor is it
            required to support interruption of the actual suspension of the thread.
            </para>
            <para>
            An implementation is required to clearly document the semantics and
            guarantees provided by each of the waiting methods, and when an
            implementation does support interruption of thread suspension then it
            must obey the interruption semantics as defined in this interface.
            </para>
            <para>
            As interruption generally implies cancellation, and checks for
            interruption are often infrequent, an implementation can favor responding
            to an interrupt over normal method return. This is true even if it can be
            shown that the interrupt occurred after another action may have unblocked
            the thread. An implementation should document this behavior.
            </para>
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Locks.ICondition.Await">
            <summary> 
            Causes the current thread to wait until it is signalled or
            <see cref="M:System.Threading.Thread.Interrupt"/> is called.
            </summary>
            <remarks>
            <para>
            The lock associated with this <see cref="T:Spring.Threading.Locks.ICondition"/> is atomically
            released and the current thread becomes disabled for thread scheduling
            purposes and lies dormant until <b>one</b> of four things happens:
            <list type="bullet">
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.Signal"/> method
            for this <see cref="T:Spring.Threading.Locks.ICondition"/> and the current thread happens to
            be chosen as the thread to be awakened.</item>
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.SignalAll"/>}
            method for this <see cref="T:Spring.Threading.Locks.ICondition"/>.</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt"/> is called
            the current thread, and interruption of thread suspension is
            supported.</item>
            <item>A '<b>spurious wakeup</b>' occurs.</item>
            </list>
            </para>
            <para>
            In all cases, before this method can return the current thread must
            re-acquire the lock associated with this condition. When the thread
            returns it is <b>guaranteed</b> to hold this lock.
            </para>
            <para>
            If the current thread:
            <list type="bullet">
            <item>has its interrupted status set on entry to this method</item>
            <item><see cref="M:System.Threading.Thread.Interrupt"/> is called while waiting
            and interruption of thread suspension is supported</item>
            </list>
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the current thread's
            interrupted status is cleared. It is not specified, in the first
            case, whether or not the test for interruption occurs before the lock
            is released.
            </para>
            <para>
            <b>Implementation Considerations</b>
            </para>
            <para>
            The current thread is assumed to hold the lock associated with this
            <see cref="T:Spring.Threading.Locks.ICondition"/> when this method is called.
            It is up to the implementation to determine if this is
            the case and if not, how to respond. Typically, an exception will be
            thrown (such as <see cref="T:System.Threading.SynchronizationLockException"/>) and the
            implementation must document that fact.
            </para>
            <para>
            An implementation can favor responding to an interrupt over normal
            method return in response to a signal. In that case the implementation
            must ensure that the signal is redirected to another waiting thread, if
            there is one.
            </para>
            </remarks>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            if the current threada is interrupted (and interruption of thread suspension is supported.
            </exception>
        </member>
        <member name="M:Spring.Threading.Locks.ICondition.AwaitUninterruptibly">
            <summary>
            Causes the current thread to wait until it is signalled.
            </summary>
            <remarks>
            <para>
            The lock associated with this condition is atomically
            released and the current thread becomes disabled for thread scheduling
            purposes and lies dormant until <b>one</b> of three things happens:
            <list type="bullet">
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.Signal"/> method
            for this <see cref="T:Spring.Threading.Locks.ICondition"/> and the current thread happens to
            be chosen as the thread to be awakened.</item>
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.SignalAll"/>} method
            for this <see cref="T:Spring.Threading.Locks.ICondition"/>.</item>
            <item>A '<b>spurious wakeup</b>' occurs.</item>
            </list>
            </para>
            <para>
            In all cases, before this method can return the current thread must
            re-acquire the lock associated with this condition. When the
            thread returns it is <b>guaranteed</b> to hold this lock.
            </para>
            <para>
            If the current thread's interrupted status is set when it enters
            this method, or <see cref="M:System.Threading.Thread.Interrupt"/> is called
            while waiting, it will continue to wait until signalled. When it finally
            returns from this method its interrupted status will still
            be set.
            </para>
            <para>
            <b>Implementation Considerations</b>
            <br/>
            The current thread is assumed to hold the lock associated with this
            <see cref="T:Spring.Threading.Locks.ICondition"/> when this method is called.
            It is up to the implementation to determine if this is
            the case and if not, how to respond. Typically, an exception will be
            thrown (such as <see cref="T:System.Threading.SynchronizationLockException"/>) and the
            implementation must document that fact.
            </para>
            </remarks>
        </member>
        <member name="M:Spring.Threading.Locks.ICondition.Await(System.TimeSpan)">
            <summary>
            Causes the current thread to wait until it is signalled or interrupted,
            or the specified waiting time elapses.
            </summary>
            <remarks>
            <para>
            The lock associated with this condition is atomically
            released and the current thread becomes disabled for thread scheduling
            purposes and lies dormant until <i>one</i> of five things happens:
            <list type="bullet">
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.Signal"/> method for this
            <c>Condition</c> and the current thread happens to be chosen as the
            thread to be awakened; or</item>
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.SignalAll"/> method for this
            <c>Condition</c>; or</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt">interrupts</see> the
            current thread, and interruption of thread suspension is supported; or</item>
            <item>The specified waiting time elapses; or</item>
            <item>A "<i>spurious wakeup</i>" occurs.</item>
            </list>
            </para>
            <para>
            In all cases, before this method can return the current thread must
            re-acquire the lock associated with this condition. When the
            thread returns it is <i>guaranteed</i> to hold this lock.
            </para>
            <para>
            If the current thread:
            <list type="bullet">
            <item>has its interrupted status set on entry to this method; or</item>
            <item>is <see cref="M:System.Threading.Thread.Interrupt">interrupts</see> while waiting
            and interruption of thread suspension is supported,</item>
            </list>
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the current
            thread's interrupted status is cleared. It is not specified, in the first
            case, whether or not the test for interruption occurs before the lock
            is released.
            </para>
            <para>
            <b>Implementation Considerations</b>
            </para>
            <para>
            The current thread is assumed to hold the lock associated with this
            <c>Condition</c> when this method is called.
            It is up to the implementation to determine if this is
            the case and if not, how to respond. Typically, an exception will be
            thrown (such as <see cref="T:System.Threading.SynchronizationLockException"/>) and the
            implementation must document that fact.
            </para>
            <para>
            An implementation can favor responding to an interrupt over normal
            method return in response to a signal, or over indicating the elapse
            of the specified waiting time. In either case the implementation
            must ensure that the signal is redirected to another waiting thread, if
            there is one.
            </para>
            </remarks>
            <param name="timeSpan">The maximum time to wait.</param>
            <returns>
            <c>false</c> if the waiting time detectably elapsed
            before return from the method, else <c>true</c>.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread is interrupted ( and interruption of thread
            suspension is supported.
            </exception>
        </member>
        <member name="M:Spring.Threading.Locks.ICondition.AwaitUntil(System.DateTime)">
            <summary>
            Causes the current thread to wait until it is signalled or interrupted,
            or the specified deadline elapses.
            </summary>
            <remarks>
            <para>
            The lock associated with this condition is atomically
            released and the current thread becomes disabled for thread scheduling
            purposes and lies dormant until <b>one</b> of five things happens:
            <list type="bullet">
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.Signal"/> method for this
            <see cref="T:Spring.Threading.Locks.ICondition"/> and the current thread happens to be chosen as the
            thread to be awakened.</item>
            <item>Some other thread invokes the <see cref="M:Spring.Threading.Locks.ICondition.SignalAll"/>} method for this
            <see cref="T:Spring.Threading.Locks.ICondition"/>.</item>
            <item>Some other thread <see cref="M:System.Threading.Thread.Interrupt"/> is called the current
            thread, and interruption of thread suspension is supported.</item>
            <item>The specified deadline elapses.</item>	
            <item>A '<b>spurious wakeup</b>' occurs.</item>
            </list>
            </para>
            <para>
            In all cases, before this method can return the current thread must
            re-acquire the lock associated with this condition. When the
            thread returns it is <b>guaranteed</b> to hold this lock.
            </para>
            <para>
            If the current thread:
            <list type="bullet">
            <item>has its interrupted status set on entry to this method</item>
            <item><see cref="M:System.Threading.Thread.Interrupt"/> is called while waiting
            and interruption of thread suspension is supported</item>
            </list>
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the current thread's
            interrupted status is cleared. It is not specified, in the first
            case, whether or not the test for interruption occurs before the lock
            is released.
            </para>
            <example>
            The return value indicates whether the deadline has elapsed,
            which can be used as follows:
            <code>
            	bool AMethod(DateTime deadline) {
            		bool stillWaiting = true;
            		while (!conditionBeingWaitedFor) {
            				if (stillWaiting)
            						stillWaiting = theCondition.AwaitUntil(deadline);
            				else
            						return false;
            				}
            		// ...
            		}
            	}
            </code>
            </example>
            <para>
            <b>Implementation Considerations</b>
            </para>
            <para>
            The current thread is assumed to hold the lock associated with this
            <see cref="T:Spring.Threading.Locks.ICondition"/> when this method is called.
            It is up to the implementation to determine if this is
            the case and if not, how to respond. Typically, an exception will be
            thrown (such as <see cref="T:System.Threading.SynchronizationLockException"/>) and the
            implementation must document that fact.
            </para>
            <para>
            An implementation can favor responding to an interrupt over normal
            method return in response to a signal, or over indicating the passing
            of the specified deadline. In either case the implementation
            must ensure that the signal is redirected to another waiting thread, if
            there is one.
            </para>
            </remarks>
            <param name="deadline">The absolute UTC time to wait.</param>
            <returns> 
            <c>false</c> if the deadline has elapsed upon return, else <c>true</c>.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread is interrupted ( and interruption of thread
            suspension is supported.
            </exception>
        </member>
        <member name="M:Spring.Threading.Locks.ICondition.Signal">
            <summary> 
            Wakes up one waiting thread.
            If any threads are waiting on this condition then one
            is selected for waking up. That thread must then re-acquire the
            lock before returning from await.
            </summary>
        </member>
        <member name="M:Spring.Threading.Locks.ICondition.SignalAll">
            <summary> 
            Wakes up all waiting threads.
            If any threads are waiting on this condition then they are
            all woken up. Each thread must re-acquire the lock before it can
            return from await.
            </summary>
        </member>
        <member name="M:Spring.Threading.Locks.ConditionVariable.#ctor(Spring.Threading.Locks.ConditionVariable.IExclusiveLock)">
            <summary> 
            Create a new <see cref="T:Spring.Threading.Locks.ConditionVariable"/> that relies on the given mutual
            exclusion lock.
            </summary>
            <param name="lock">
            A non-reentrant mutual exclusion lock.
            </param>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.#ctor">
            <summary> Creates an instance of <see cref="T:Spring.Threading.Locks.ReentrantLock"/>.
            This is equivalent to using <tt>ReentrantLock(false)</tt>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.#ctor(System.Boolean)">
            <summary> 
            Creates an instance of <see cref="T:Spring.Threading.Locks.ReentrantLock"/> with the
            given fairness policy.
            </summary>
            <param name="fair"><c>true</c> if this lock will be fair, else <c>false</c>
            </param>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.Lock">
            <summary>
            Acquires the lock and returns an <see cref="T:System.IDisposable"/> that
            can be used to unlock when disposed.
            </summary>
            <remarks>
            <para>
            Acquires the lock if it is not held by another thread and returns
            immediately, setting the lock hold count to one.
            </para>
            <para>
            If the <see cref="P:System.Threading.Thread.CurrentThread">current thread</see>
            already holds the lock then the hold count is incremented by one and
            the method returns immediately.
            </para>
            <para>
            If the lock is held by another thread then the
            current thread becomes disabled for thread scheduling
            purposes and lies dormant until the lock has been acquired,
            at which time the lock hold count is set to one.
            </para>
            <example>
            Below is a typical use of <see cref="M:Spring.Threading.Locks.ReentrantLock.Lock"/>
            <code language="c#">
            ReentrantLock reentrantLock = ...;
            
            using(reentrantLock.Lock())
            {
               // locked
            }
            // unlocked.
            </code>
            it is equvilant to
            <code language="c#">
            ReentrantLock reentrantLock = ...;
            
            reentrantLock.Lock();
            try {
                // locked
            }
            finally
            {
                reentrantLock.Unlock();
            }
            // unlocked
            </code>
            </example>
            </remarks>
            <returns>
            An <see cref="T:System.IDisposable"/> object that unlocks current 
            <see cref="T:Spring.Threading.Locks.ReentrantLock"/> when it is disposed.
            </returns>
            <seealso cref="M:Spring.Threading.Locks.ReentrantLock.LockInterruptibly"/>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.LockInterruptibly">
            <summary> 
            Acquires the lock unless <see cref="M:System.Threading.Thread.Interrupt"/> is called on the current thread
            
            <p/>
            Acquires the lock if it is not held by another thread and returns
            immediately, setting the lock hold count to one.
            
            <p/>
            If the current thread already holds this lock then the hold count
            is incremented by one and the method returns immediately.
            
            <p/>
            If the lock is held by another thread then the
            current thread becomes disabled for thread scheduling
            purposes and lies dormant until one of two things happens:
            
            <list type="bullet">
            <item>The lock is acquired by the current thread</item>
            <item>Some other thread calls <see cref="M:System.Threading.Thread.Interrupt"/> on the current thread.</item>
            </list>
            
            <p/>If the lock is acquired by the current thread then the lock hold
            count is set to one.
            
            <p/>If the current thread:
            
            <list type="bullet">
            <item>has its interrupted status set on entry to this method</item> 
            <item><see cref="M:System.Threading.Thread.Interrupt"/> is called while acquiring the lock</item>
            </list>
            
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the current thread's
            interrupted status is cleared.
            
            <p/>
            In this implementation, as this method is an explicit interruption
            point, preference is given to responding to the interrupt over normal or reentrant
            acquisition of the lock.
            </summary>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread is interrupted</exception>
            
            <summary>
            Acquires the lock unless <see cref="M:System.Threading.Thread.Interrupt"/> is called 
            on the current thread. Returns an <see cref="T:System.IDisposable"/> that
            can be used to unlock if the lock is sucessfully obtained.
            </summary>
            <remarks>
            <para>
            Acquires the lock if it is not held by another thread and returns
            immediately, setting the lock hold count to one.
            </para>
            <para>
            If the current thread already holds this lock then the hold count
            is incremented by one and the method returns immediately.
            </para>
            <para>
            If the lock is held by another thread then the
            current thread becomes disabled for thread scheduling
            purposes and lies dormant until one of two things happens:
            </para>
            <list type="bullet">
            <item>
            The lock is acquired by the current thread.
            </item>
            <item>
            Some other thread calls <see cref="M:System.Threading.Thread.Interrupt"/> on the current thread.
            </item>
            </list>
            <para>
            If the lock is acquired by the current thread then the lock hold
            count is set to one.
            </para>
            <para>
            If the current thread:
            </para>
            <list type="bullet">
            <item>has its interrupted status set on entry to this method</item> 
            <item><see cref="M:System.Threading.Thread.Interrupt"/> is called while acquiring the lock</item>
            </list>
            <para>
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the current thread's
            interrupted status is cleared.
            </para>
            <para>
            In this implementation, as this method is an explicit interruption
            point, preference is given to responding to the interrupt over normal or reentrant
            acquisition of the lock.
            </para>
            <example>
            Below is a typical use of <see cref="M:Spring.Threading.Locks.ReentrantLock.LockInterruptibly"/>
            <code language="c#">
            ReentrantLock reentrantLock = ...;
            
            using(reentrantLock.LockInterruptibly())
            {
               // locked
            }
            // unlocked.
            </code>
            it is equvilant to
            <code language="c#">
            ReentrantLock reentrantLock = ...;
            
            reentrantLock.LockInterruptibly();
            try {
                // locked
            }
            finally
            {
                reentrantLock.Unlock();
            }
            // unlocked
            </code>
            </example>
            </remarks>
            <returns>
            An <see cref="T:System.IDisposable"/> object that unlocks current 
            <see cref="T:Spring.Threading.Locks.ReentrantLock"/> when it is disposed.
            </returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">
            If the current thread is interrupted.
            </exception>
            <seealso cref="M:Spring.Threading.Locks.ReentrantLock.Lock"/>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.TryLock">
            <summary> 
            Acquires the lock only if it is not held by another thread at the time
            of invocation.
            
            <p/>
            Acquires the lock if it is not held by another thread and
            returns immediately with the value <c>true</c>, setting the
            lock hold count to one. Even when this lock has been set to use a
            fair ordering policy, a call to <see cref="M:Spring.Threading.Locks.ReentrantLock.TryLock"/> <b>will</b>
            immediately acquire the lock if it is available, whether or not
            other threads are currently waiting for the lock.
            This "barging" behavior can be useful in certain
            circumstances, even though it breaks fairness. If you want to honor
            the fairness setting for this lock, then use
            <see cref="M:Spring.Threading.Locks.ReentrantLock.TryLock(System.TimeSpan)"/>
            which is almost equivalent (it also detects interruption).
            
            <p/> 
            If the current thread
            already holds this lock then the hold count is incremented by one and
            the method returns <c>true</c>.
            
            <p/>
            If the lock is held by another thread then this method will return
            immediately with the value <c>false</c>.
            
            </summary>
            <returns> <c>true</c> if the lock was free and was acquired by the
            current thread, or the lock was already held by the current thread,
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.TryLock(System.TimeSpan)">
            <summary> 
            Acquires the lock if it is not held by another thread within the given
            waiting time and <see cref="M:System.Threading.Thread.Interrupt"/> hasn't been called on the current thread
            
            <p/>
            Acquires the lock if it is not held by another thread and returns
            immediately with the value <c>true</c>, setting the lock hold count
            to one. If this lock has been set to use a fair ordering policy then
            an available lock <b>will not</b> be acquired if any other threads
            are waiting for the lock. This is in contrast to the <see cref="M:Spring.Threading.Locks.ReentrantLock.TryLock"/> 
            method. If you want a timed <see cref="M:Spring.Threading.Locks.ReentrantLock.TryLock"/> that does permit barging on
            a fair lock then combine the timed and un-timed forms together:
            
            <code>
            if (lock.TryLock() || lock.TryLock(timeSpan) ) { ... }
            </code>
            
            <p/>
            If the current thread
            already holds this lock then the hold count is incremented by one and
            the method returns <c>true</c>.
            
            <p/>
            If the lock is held by another thread then the
            current thread becomes disabled for thread scheduling
            purposes and lies dormant until one of three things happens:
            
            <list type="bullet">
            <item>The lock is acquired by the current thread</item>	
            <item>Some other thread calls <see cref="M:System.Threading.Thread.Interrupt"/> the current thread</item>
            <item>The specified waiting time elapses</item>
            </list>
            
            <p/>
            If the lock is acquired then the value <c>true</c> is returned and
            the lock hold count is set to one.
            
            <p/>If the current thread:
            <list type="bullet">
            <item>has its interrupted status set on entry to this method</item>	
            <item>has <see cref="M:System.Threading.Thread.Interrupt"/> called on it while acquiring the lock</item>	
            </list>
            
            then <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown and the current thread's
            interrupted status is cleared.
            
            <p/>
            If the specified waiting time elapses then the value <c>false</c>
            is returned.  If the time is less than or equal to zero, the method will not wait at all.
            
            <p/>
            In this implementation, as this method is an explicit interruption
            point, preference is given to responding to the interrupt over normal or reentrant
            acquisition of the lock, and over reporting the elapse of the waiting
            time.
            
            </summary>
            <param name="timeSpan">the <see cref="T:System.TimeSpan"/> to wait for the lock</param>
            <returns> <c>true</c> if the lock was free and was acquired by the
            current thread, or the lock was already held by the current thread; and
            <c>false</c> if the waiting time elapsed before the lock could be
            acquired.
            </returns>
            <throws>  InterruptedException if the current thread is interrupted </throws>
            <throws>  NullPointerException if unit is null </throws>
            <exception cref="T:System.NullReferenceException">If <paramref name="timeSpan"/> is null</exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">If the current thread is interrupted</exception>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.Unlock">
            <summary> 
            Attempts to release this lock.
            <p/>
            If the current thread is the
            holder of this lock then the hold count is decremented. If the
            hold count is now zero then the lock is released.  If the
            current thread is not the holder of this lock then <see cref="T:System.InvalidOperationException"/> is thrown.
            </summary>
            <exception cref="T:System.Threading.SynchronizationLockException">if the current thread does not hold this lock.</exception>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.NewCondition">
            <summary> 
            Returns a <see cref="T:Spring.Threading.Locks.ICondition"/> instance for use with this
            <see cref="T:Spring.Threading.Locks.ILock"/> instance.
            
            <p/>
            The returned <see cref="T:Spring.Threading.Locks.ICondition"/> instance supports the same
            usages as do the <see cref="T:System.Threading.Monitor"/> methods <see cref="M:System.Threading.Monitor.Wait(System.Object)"/>,
            <see cref="M:System.Threading.Monitor.Pulse(System.Object)"/>, and <see cref="M:System.Threading.Monitor.PulseAll(System.Object)"/>) when used with the built-in
            monitor lock.
            <list type="bullet">
            <item>
            If this lock is not held when either 
            <see cref="M:Spring.Threading.Locks.ICondition.Await"/> or <see cref="M:Spring.Threading.Locks.ICondition.Signal"/>
            methods are called, then an <see cref="T:System.InvalidOperationException"/>  is thrown.</item>
            <item>When the condition <see cref="T:Spring.Threading.Locks.ICondition"/>await() waiting}
            methods are called the lock is released and, before they
            return, the lock is reacquired and the lock hold count restored
            to what it was when the method was called.</item>
            <item>If <see cref="M:System.Threading.Thread.Interrupt"/> is called while
            waiting then the wait will terminate, an <see cref="T:System.Threading.ThreadInterruptedException"/>
            and the thread's interrupted status will be cleared.</item>
            <item> Waiting threads are signalled in FIFO order</item>
            <item>
            The ordering of lock reacquisition for threads returning
            from waiting methods is the same as for threads initially
            acquiring the lock, which is in the default case not specified,
            but for <b>fair</b> locks favors those threads that have been
            waiting the longest.</item>
            </list>
            </summary>
            <returns> the ICondition object
            </returns>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.IsQueuedThread(System.Threading.Thread)">
            <summary> 
            Queries whether the <paramref name="thread"/> is waiting to acquire this
            lock. Note that because cancellations may occur at any time, a
            <c>true</c> return does not guarantee that this thread
            will ever acquire this lock.  This method is designed primarily for use
            in monitoring of the system state.
            </summary>
            <param name="thread">the <see cref="T:System.Threading.Thread"/> instance.
            </param>
            <returns> <c>true</c> if the given thread is queued waiting for this lock, <c>false</c> otherwise.
            </returns>
            <throws>  NullPointerException if thread is null </throws>
            <exception cref="T:System.NullReferenceException">if <paramref name="thread"/> is null.</exception>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.HasWaiters(Spring.Threading.Locks.ICondition)">
            <summary> 
            Queries whether any threads are waiting on the <paramref name="condition"/>
            associated with this lock. Note that because timeouts and
            interrupts may occur at any time, a <c>true</c> return does
            not guarantee that a future <tt>signal</tt> will awaken any
            threads.  This method is designed primarily for use in
            monitoring of the system state.
            </summary>
            <param name="condition">the condition</param>
            <returns> <c>true</c> if there are any waiting threads.</returns>
            <exception cref="T:System.NullReferenceException">if the <paramref name="condition"/> is null</exception>
            <exception cref="T:System.ArgumentException">if the <paramref name="condition"/> is not associated with this lock</exception>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.GetWaitQueueLength(Spring.Threading.Locks.ICondition)">
            <summary> 
            Returns an estimate of the number of threads waiting on the
            <paramref name="condition"/> associated with this lock. Note that because
            timeouts and interrupts may occur at any time, the estimate
            serves only as an upper bound on the actual number of waiters.
            This method is designed for use in monitoring of the system
            state, not for synchronization control.
            </summary>
            <param name="condition">the condition</param>
            <returns> the estimated number of waiting threads.</returns>
            <exception cref="T:System.NullReferenceException">if the <paramref name="condition"/> is null</exception>
            <exception cref="T:System.ArgumentException">if the <paramref name="condition"/> is not associated with this lock</exception>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.GetWaitingThreads(Spring.Threading.Locks.ICondition)">
            <summary> 
            Returns a collection containing those threads that may be
            waiting on the <paramref name="condition"/> associated with this lock.
            Because the actual set of threads may change dynamically while
            constructing this result, the returned collection is only a
            best-effort estimate. The elements of the returned collection
            are in no particular order.  This method is designed to
            facilitate construction of subclasses that provide more
            extensive condition monitoring facilities.
            </summary>
            <param name="condition">the condition</param>
            <returns> the collection of threads waiting on <paramref name="condition"/></returns>
            <exception cref="T:System.NullReferenceException">if the <paramref name="condition"/> is null</exception>
            <exception cref="T:System.ArgumentException">if the <paramref name="condition"/> is not associated with this lock</exception>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.ToString">
            <summary> 
            Returns a string identifying this lock, as well as its lock
            state.  The state, in brackets, includes either the string
            'Unlocked' or the string 'Locked by'
            followed by the <see cref="P:System.Threading.Thread.Name"/>  of the owning thread.
            </summary>
            <returns> a string identifying this lock, as well as its lock state.</returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.HoldCount">
            <summary> 
            Queries the number of holds on this lock by the current thread.
            
            <p/>
            A thread has a hold on a lock for each lock action that is not
            matched by an unlock action.
            
            <p/>
            The hold count information is typically only used for testing and
            debugging purposes. For example, if a certain section of code should
            not be entered with the lock already held then we can assert that
            fact:
            
            <code>
            class X {
            	ReentrantLock lock = new ReentrantLock();
            	// ...
            	public void m() {
            		Debug.Assert( lock.HoldCount() == 0 );
            		lock.Lock();
            		try {
            			// ... method body
            		} finally {
            			lock.Unlock();
            		}
            	}
            }
            </code>
            </summary>
            <returns> 
            The number of holds on this lock by the current thread,
            or zero if this lock is not held by the current thread.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.IsHeldByCurrentThread">
            <summary> 
            Queries if this lock is held by the current thread.
            
            <p/>
            This method is typically used for debugging and
            testing. For example, a method that should only be called while
            a lock is held can assert that this is the case:
            
            <code>
            class X {
            	ReentrantLock lock = new ReentrantLock();
            	// ...
            
            	public void m() {
            		Debug.Assert( lock.IsHeldByCurrentThread );
            		// ... method body
            	}
            }
            </code>
            
            <p/>
            It can also be used to ensure that a reentrant lock is used
            in a non-reentrant manner, for example:
            
            <code>
            class X {
            	ReentrantLock lock = new ReentrantLock();
            	// ...
            
            	public void m() {
            		Debug.Assert( !lock.IsHeldByCurrentThread );
            		lock.Lock();
            		try {
            			// ... method body
            		} finally {
            			lock.Unlock();
            		}
            	}
            }
            </code>
            </summary>
            <returns> <c>true</c> if current thread holds this lock and
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.IsLocked">
            <summary> 
            Queries if this lock is held by any thread. This method is
            designed for use in monitoring of the system state,
            not for synchronization control.
            </summary>
            <returns> <c>true</c> if any thread holds this lock and
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.IsFair">
            <summary> Returns <c>true</c> if this lock has fairness set true.</summary>
            <returns> <c>true</c> if this lock has fairness set true.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.Owner">
            <summary> 
            Returns the thread that currently owns this lock, or
            <c>null</c> if not owned. Note that the owner may be
            momentarily <c>null</c> even if there are threads trying to
            acquire the lock but have not yet done so.  This method is
            designed to facilitate construction of subclasses that provide
            more extensive lock monitoring facilities.
            </summary>
            <returns> the owner, or <c>null</c> if not owned.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.QueueLength">
            <summary> 
            Returns an estimate of the number of threads waiting to
            acquire this lock.  The value is only an estimate because the number of
            threads may change dynamically while this method traverses
            internal data structures.  This method is designed for use in
            monitoring of the system state, not for synchronization
            control.
            </summary>
            <returns> the estimated number of threads waiting for this lock
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.HasQueuedThreads">
            <summary> 
            Queries whether any threads are waiting to acquire this lock. Note that
            because cancellations may occur at any time, a <c>true</c>
            return does not guarantee that any other thread will ever
            acquire this lock.  This method is designed primarily for use in
            monitoring of the system state.
            </summary>
            <returns> <c>true</c>if there may be other threads waiting to acquire
            the lock, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.ReentrantLock.QueuedThreads">
            <summary> 
            Returns a collection containing threads that may be waiting to
            acquire this lock.  Since the actual set of threads may change
            dynamically while constructing this result, the returned
            collection is only a best-effort estimate.  The elements of the
            returned collection are in no particular order.  This method is
            designed to facilitate construction of subclasses that provide
            more extensive monitoring facilities.
            </summary>
            <returns> collection of threads
            </returns>
        </member>
        <member name="T:Spring.Threading.Locks.ReentrantLock.Sync">
            <summary>
            Base of synchronization control for this lock. Subclassed
            into fair and nonfair versions below.
            </summary>
        </member>
        <member name="M:Spring.Threading.Locks.ReentrantLock.NonfairSync.Lock">
            <summary>
            Performs lock.  Try immediate barge, backing up to normal acquire on failure.
            </summary>
        </member>
        <member name="T:Spring.Threading.Helpers.IQueuedSync">
            <summary>
            Used by <see cref="T:Spring.Threading.Helpers.WaitNode"/>.
            NOTE: this class is NOT present in java.util.concurrent.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor.Worker.CompletedTasks">
            <summary> 
            Per thread completed task counter; accumulated
            into completedTaskCount upon termination.
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor.Worker.FirstTask">
            <summary> 
            Initial task to run before entering run loop
            </summary>
        </member>
        <member name="F:Spring.Threading.Execution.ThreadPoolExecutor.Worker.Thread">
            <summary> 
            Thread this worker is running in.  Acts as a final field,
            but cannot be set until thread is created.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Worker.#ctor(Spring.Threading.Execution.ThreadPoolExecutor,Spring.Threading.IRunnable)">
            <summary>
            Default Constructor
            </summary>
            <param name="firstTask">Task to run before entering run loop.</param>
            <param name="parentThreadPoolExecutor"><see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> that controls this worker</param>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.Worker.Run">
            <summary>
            Runs the associated task, signalling the <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> when exiting.
            </summary>
        </member>
        <member name="T:Spring.Threading.Execution.ThreadPoolExecutor.CallerRunsPolicy">
            <summary>
            A handler for rejected tasks that runs the rejected task
            directly in the calling thread of the <see cref="M:Spring.Threading.IRunnable.Run"/>
            method, unless the executor has been shut down, in which case the
            task is discarded.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.CallerRunsPolicy.RejectedExecution(Spring.Threading.IRunnable,Spring.Threading.Execution.ThreadPoolExecutor)">
             <summary>
             Executes task <paramref name="runnable"/> in the caller's
             thread, unless <paramref name="executor"/> has been shut down,
             in which case the task is discarded.
            
             <param name="executor">the executor attempting to execute this task</param>
             <param name="runnable">the runnable task requested to be executed</param>
             </summary>
        </member>
        <member name="T:Spring.Threading.Execution.ThreadPoolExecutor.AbortPolicy">
            <summary> 
            A <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/> for rejected tasks that
            throws a <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.AbortPolicy.RejectedExecution(Spring.Threading.IRunnable,Spring.Threading.Execution.ThreadPoolExecutor)">
            <summary> 
            Always throws <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>.
            </summary>
            <param name="runnable">
            The <see cref="T:Spring.Threading.IRunnable"/> task requested to be executed.
            </param>
            <param name="executor">
            The <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> attempting to execute this task.
            </param>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">
            Always thrown upon execution.
            </exception>
        </member>
        <member name="T:Spring.Threading.Execution.ThreadPoolExecutor.DiscardPolicy">
            <summary> 
            A <see cref="P:Spring.Threading.Execution.ThreadPoolExecutor.RejectedExecutionHandler"/> for rejected tasks that 
            silently discards the rejected task.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.DiscardPolicy.RejectedExecution(Spring.Threading.IRunnable,Spring.Threading.Execution.ThreadPoolExecutor)">
            <summary> 
            Does nothing, which has the effect of discarding task
            <paramref name="runnable"/>.
            </summary>
            <param name="runnable">
            The <see cref="T:Spring.Threading.IRunnable"/> task requested to be executed.
            </param>
            <param name="executor">
            The <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> attempting to execute this
            task.
            </param>
        </member>
        <member name="T:Spring.Threading.Execution.ThreadPoolExecutor.DiscardOldestPolicy">
            <summary> 
            A <see cref="T:Spring.Threading.Execution.IRejectedExecutionHandler"/> for rejected tasks that
            discards the oldest unhandled request and then retries
            <see cref="M:Spring.Threading.IExecutor.Execute(Spring.Threading.IRunnable)"/>, unless the executor
            is shut down, in which case the task is discarded.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ThreadPoolExecutor.DiscardOldestPolicy.RejectedExecution(Spring.Threading.IRunnable,Spring.Threading.Execution.ThreadPoolExecutor)">
            <summary> 
            Obtains and ignores the next task that the <paramref name="executor"/>
            would otherwise execute, if one is immediately available,
            and then retries execution of task <paramref name="runnable"/>,
            unless the <paramref name="executor"/> is shut down, in which
            case task <paramref name="runnable"/> is instead discarded.
            </summary>
            <param name="runnable">
            The <see cref="T:Spring.Threading.IRunnable"/> task requested to be executed.
            </param>
            <param name="executor">
            The <see cref="T:Spring.Threading.Execution.ThreadPoolExecutor"/> attempting to execute this
            task.
            </param>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.#ctor(System.Int32)">
            <summary> 
            Creates a new ScheduledThreadPoolExecutor with the given core
            pool size.
            </summary>
            <param name="corePoolSize">the number of threads to keep in the pool.</param>
            <exception cref="T:System.ArgumentException">if corePoolSize is less than 0</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.#ctor(System.Int32,Spring.Threading.IThreadFactory)">
            <summary> 
            Creates a new ScheduledThreadPoolExecutor with the given core
            pool size and using the specified <see cref="T:Spring.Threading.IThreadFactory"/>
            </summary>
            <param name="corePoolSize"></param>
            <param name="threadFactory"></param>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Shutdown">
            <summary> 
            Initiates an orderly shutdown in which previously submitted
            tasks are executed, but no new tasks will be
            accepted. Invocation has no additional effect if already shut
            down.
            </summary>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.ShutdownNow">
            <summary> 
            Attempts to stop all actively executing tasks, halts the
            processing of waiting tasks, and returns a list of the tasks that were
            awaiting execution.
            </summary>
            <remarks> 
            There are no guarantees beyond best-effort attempts to stop
            processing actively executing tasks.  For example, typical
            implementations will cancel via <see cref="M:System.Threading.Thread.Interrupt"/>, so if any
            tasks mask or fail to respond to interrupts, they may never terminate.
            </remarks>
            <returns> list of tasks that never commenced execution</returns>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.AwaitTermination(System.TimeSpan)">
            <summary> 
            Blocks until all tasks have completed execution after a shutdown
            request, or the timeout occurs, or the current thread is
            interrupted, whichever happens first. 
            </summary>
            <param name="timeSpan">the time span to wait.
            </param>
            <returns> <c>true</c> if this executor terminated and <c>false</c>
            if the timeout elapsed before termination
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Submit``1(Spring.Threading.ICallable{``0})">
            <summary> 
            Submits a value-returning task for execution and returns a
            Future representing the pending results of the task. The
            <see cref="T:Spring.Threading.IRunnable"/> method will return the task's result upon
            <b>successful</b> completion.
            </summary>
            <remarks> 
            If you would like to immediately block waiting
            for a task, you can use constructions of the form
            <code>
            	result = exec.Submit(aCallable).GetResult();
            </code> 
            <p/> 
            Note: The <see cref="T:Spring.Threading.ICallable`1"/> class includes a set of methods
            that can convert some other common closure-like objects,
            for example, <see cref="T:Spring.Threading.Future.IFuture`1"/> to
            <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> form so they can be submitted.
            </remarks>
            <param name="task">the task to submit</param>
            <returns> a <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> representing pending completion of the task</returns>
            <exception cref="T:Spring.Threading.Execution.Executors">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Submit``1(Spring.Threading.IRunnable,``0)">
            <summary> 
            Submits a <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> task for execution and returns a
            <see cref="T:Spring.Threading.Future.IFuture`1"/> 
            representing that task. The <see cref="T:Spring.Threading.IRunnable"/> method will
            return the given result upon successful completion.
            </summary>
            <param name="task">the task to submit</param>
            <param name="result">the result to return</param>
            <returns> a <see cref="T:System.ArgumentNullException"/> representing pending completion of the task</returns>
            <exception cref="M:Spring.Threading.Future.IFuture`1.GetResult">if the task cannot be accepted for execution.</exception>
            <exception cref="T:Spring.Threading.Future.IFuture`1">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Submit(Spring.Threading.IRunnable)">
            <summary> Submits a Runnable task for execution and returns a Future
            representing that task. The Future's <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/> method will
            return <c>null</c> upon successful completion.
            </summary>
            <param name="task">the task to submit
            </param>
            <returns> a Future representing pending completion of the task
            </returns>
            <exception cref="T:System.ArgumentNullException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.InvokeAll``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given tasks, returning a list of <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>s holding
            their status and results when all complete.
            </summary>
            <remarks>
            <see cref="T:System.ArgumentNullException"/>
            is <c>true</c> for each element of the returned list.
            Note that a <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            collection is modified while this operation is in progress.
            </remarks>
            <param name="tasks">the collection of tasks</param>
            <returns> A list of Futures representing the tasks, in the same
            sequential order as produced by the iterator for the given task
            list, each of which has completed.
            </returns>
            <exception cref="P:Spring.Threading.ICancellable.IsDone">if the task cannot be accepted for execution.</exception>
            <exception cref="T:Spring.Threading.Future.IFuture`1">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.InvokeAll``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given tasks, returning a list of <see cref="T:System.ArgumentNullException"/>s holding
            their status and results when all complete or the <paramref name="durationToWait"/> expires, whichever happens first.
            </summary>
            <remarks>
            <see cref="T:Spring.Threading.Execution.RejectedExecutionException"/>
            is <c>true</c> for each element of the returned list.
            Note that a <b>completed</b> task could have
            terminated either normally or by throwing an exception.
            The results of this method are undefined if the given
            collection is modified while this operation is in progress.
            </remarks>
            <param name="tasks">the collection of tasks</param>
            <param name="durationToWait">the time span to wait.</param> 
            <returns> A list of Futures representing the tasks, in the same
            sequential order as produced by the iterator for the given
            task list. If the operation did not time out, each task will
            have completed. If it did time out, some of these tasks will
            not have completed.
            </returns>
            <exception cref="P:Spring.Threading.ICancellable.IsDone">if the task cannot be accepted for execution.</exception>
            <exception cref="T:Spring.Threading.Future.IFuture`1">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.InvokeAny``1(System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> 
            Executes the given tasks, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do. 
            </summary>
            <remarks>
            Upon normal or exceptional return, tasks that have not completed are cancelled.
            The results of this method are undefined if the given
            collection is modified while this operation is in progress.
            </remarks>
            <param name="tasks">the collection of tasks</param>
            <returns> The result returned by one of the tasks.</returns>
            <exception cref="T:System.ArgumentNullException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Schedule(Spring.Threading.IRunnable,System.TimeSpan)">
            <summary> 
            Creates and executes a one-shot action that becomes enabled
            after the given delay.
            </summary>
            <param name="command">the task to execute.</param>
            <param name="delay">the <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> from now to delay execution.</param>
            <returns> 
            a <see cref="T:System.TimeSpan"/> representing pending completion of the task,
            and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will return <c>null</c>
            upon completion.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Schedule``1(Spring.Threading.ICallable{``0},System.TimeSpan)">
            <summary> 
            Creates and executes a <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> that becomes enabled after the
            given delay.
            </summary>
            <param name="callable">the function to execute.</param>
            <param name="delay">the <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> from now to delay execution.</param>
            <returns> a <see cref="T:System.TimeSpan"/> that can be used to extract result or cancel.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.ScheduleAtFixedRate(Spring.Threading.IRunnable,System.TimeSpan,System.TimeSpan)">
            <summary> 
            Creates and executes a periodic action that becomes enabled first
            after the given initial <paramref name="initialDelay"/>, and subsequently with the given
            <paramref name="period"/>
            </summary>
            <remarks>
            That is executions will commence after
            <paramref name="initialDelay"/>, the <paramref name="initialDelay"/> + <paramref name="period"/>, then
            <paramref name="initialDelay"/> + 2 * <paramref name="period"/>, and so on.
            <p/>
            
            If any execution of the task
            encounters an exception, subsequent executions are suppressed.
            Otherwise, the task will only terminate via cancellation or
            termination of the executor. If any execution of this task 
            takes longer than its period, then subsequent executions
            may start late, but will <b>NOT</b> concurrently execute.
            </remarks>
            <param name="command">the task to execute.</param>
            <param name="initialDelay">the time to delay first execution.</param>
            <param name="period">the period between successive executions.</param>
            <returns> a <see cref="T:Spring.Threading.Future.IFuture`1"/> representing pending completion of the task,
            and whose <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/> method will throw an exception upon
            cancellation.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.ScheduleWithFixedDelay(Spring.Threading.IRunnable,System.TimeSpan,System.TimeSpan)">
            <summary> 
            Creates and executes a periodic action that becomes enabled first
            after the given initial delay, and subsequently with the
            given delay between the termination of one execution and the
            commencement of the next. 
            </summary>
            <remarks> 
            If any execution of the task
            encounters an exception, subsequent executions are suppressed.
            Otherwise, the task will only terminate via cancellation or
            termination of the executor.
            </remarks>
            <param name="command">the task to execute.</param>
            <param name="initialDelay">the time to delay first execution.</param>
            <param name="delay">the delay between the termination of one execution and the commencement of the next.</param>
            <returns> a <see cref="M:Spring.Threading.Future.IFuture`1.GetResult"/>  representing pending completion of the task,
            and whose <see cref="T:Spring.Threading.Future.IFuture`1"/> method will throw an exception upon
            cancellation.
            </returns>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.InvokeAny``1(System.TimeSpan,System.Collections.Generic.IEnumerable{Spring.Threading.ICallable{``0}})">
            <summary> Executes the given tasks, returning the result
            of one that has completed successfully (i.e., without throwing
            an exception), if any do before the given timeout elapses.
            </summary>
            <remarks>
            Upon normal or exceptional return, tasks that have not
            completed are cancelled.
            The results of this method are undefined if the given
            collection is modified while this operation is in progress.
            </remarks>
            <param name="tasks">the collection of tasks</param>
            <param name="durationToWait">the time span to wait.</param> 
            <returns> The result returned by one of the tasks.
            </returns>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the task cannot be accepted for execution.</exception>
            <exception cref="T:System.ArgumentNullException">if the command is null</exception>
        </member>
        <member name="M:Spring.Threading.Execution.ScheduledThreadPoolExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> 
            Executes the given command at some time in the future.
            </summary>
            <remarks>
            The command may execute in a new thread, in a pooled thread, or in the calling
            thread, at the discretion of the <see cref="T:System.ArgumentNullException"/> implementation.
            </remarks>
            <param name="command">the runnable task</param>
            <exception cref="T:Spring.Threading.IExecutor">if the task cannot be accepted for execution.</exception>
            <exception cref="T:Spring.Threading.Execution.RejectedExecutionException">if the command is null</exception>
        </member>
        <member name="P:Spring.Threading.Execution.ScheduledThreadPoolExecutor.IsShutdown">
            <summary> 
            Returns <c>true</c> if this executor has been shut down.
            </summary>
            <returns> 
            Returns <c>true</c> if this executor has been shut down.
            </returns>
        </member>
        <member name="P:Spring.Threading.Execution.ScheduledThreadPoolExecutor.IsTerminated">
            <summary> 
            Returns <c>true</c> if all tasks have completed following shut down.
            </summary>
            <remarks>
            Note that this will never return <c>true</c> unless
            either <see cref="M:Spring.Threading.Execution.IExecutorService.Shutdown"/> or 
            <see cref="M:Spring.Threading.Execution.IExecutorService.ShutdownNow"/> was called first.
            </remarks>
            <returns> <c>true</c> if all tasks have completed following shut down
            </returns>
        </member>
        <member name="T:Spring.Threading.FIFOSemaphore">
            <summary> A First-in/First-out implementation of a Semaphore.
            Waiting requests will be satisified in
            the order that the processing of those requests got to a certain point.
            If this sounds vague it is meant to be. FIFO implies a
            logical timestamping at some point in the processing of the
            request. To simplify things we don't actually timestamp but
            simply store things in a FIFO queue. Thus the order in which
            requests enter the queue will be the order in which they come
            out.  This order need not have any relationship to the order in
            which requests were made, nor the order in which requests
            actually return to the caller. These depend on Java thread
            scheduling which is not guaranteed to be predictable (although
            JVMs tend not to go out of their way to be unfair). 
            </summary>
        </member>
        <member name="T:Spring.Threading.QueuedSemaphore">
            <summary> Abstract base class for semaphores relying on queued wait nodes.
            </summary>
        </member>
        <member name="F:Spring.Threading.QueuedSemaphore.wq_">
            <summary>
            The backing wait queue
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.Acquire">
            <summary>
            <see cref="M:Spring.Threading.ISync.Acquire"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.Attempt(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ISync.Attempt(System.Int64)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.Precheck">
            <summary>
            Check to do before a timed wait
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.Recheck(Spring.Threading.QueuedSemaphore.WaitQueue.WaitNode)">
            <summary>
            Check to do on a wait node
            </summary>
            <param name="w"></param>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.Release">
            <summary>
            <see cref="M:Spring.Threading.ISync.Release"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.Release(System.Int64)">
            <summary>Release N permits *</summary>
        </member>
        <member name="T:Spring.Threading.QueuedSemaphore.WaitQueue">
            <summary> Base class for internal queue classes for semaphores, etc.
            Relies on subclasses to actually implement queue mechanics
            
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.WaitQueue.Insert(Spring.Threading.QueuedSemaphore.WaitQueue.WaitNode)">
            <summary>
            assumed not to block
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedSemaphore.WaitQueue.Extract">
            <summary>
            should return null if empty
            </summary>
        </member>
        <member name="M:Spring.Threading.FIFOSemaphore.#ctor(System.Int64)">
            <summary> Create a Semaphore with the given initial number of permits.
            Using a seed of one makes the semaphore act as a mutual exclusion lock.
            Negative seeds are also allowed, in which case no acquires will proceed
            until the number of releases has pushed the number of permits past 0.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.FIFOSemaphore.FIFOWaitQueue">
            <summary> Simple linked list queue used in FIFOSemaphore.
            Methods are not synchronized; they depend on synch of callers
            
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTask">
            <summary> Abstract base class for Fork/Join Tasks.
            
            <p>
            FJTasks are lightweight, stripped-down analogs of Threads. 
            Many FJTasks share the same pool of Java threads. This is
            supported by the FJTaskRunnerGroup and FJTaskRunner classes, that 
            mainly contain
            methods called only internally by FJTasks.
            FJTasks support versions of the most common methods found in class Thread,
            including start(), yield() and join(). However, they
            don't support priorities, ThreadGroups or other bookkeeping
            or control methods of class Thread.
            </p>
            <p>
            FJTasks should normally be defined by subclassing and adding a run() method.
            Alternatively, inner class <see cref="T:Spring.Threading.ForkJoin.FJTask.Wrap"/> 
            can be used to
            wrap an existing <see cref="T:Spring.Threading.IRunnable"/> object in a <see cref="T:Spring.Threading.ForkJoin.FJTask"/>. 
            </p>
            <p>
            <c>FJTaskRunnerGroup.Execute</c> can be used to
            initiate a FJTask from a non-FJTask thread. 
            And <c>FJTaskRunnerGroup.Invoke</c> can be used to initiate
            a FJTask and then wait for it to complete before returning.
            These are the only entry-points from normal threads to FJTasks.
            Most FJTask methods themselves may only be called from within running FJTasks.
            They throw ClassCastExceptions if they are not, 
            reflecting the fact that these methods
            can only be executed using FJTaskRunner threads, not generic
            java.lang.Threads.
            </p>
            <p>
            There are three different ways to run a FJTask,
            with different scheduling semantics:
            <ul>
            <li> <see cref="M:Spring.Threading.ForkJoin.FJTask.Fork"/> (as well as FJTaskRunnerGroup.ExecuteTask) 
            behaves pretty much like <see cref="M:Thread.Start"/>. It enqueues a task to be
            run the next time any FJTaskRunner thread is otherwise idle.
            It maintains standard FIFO ordering with respect to
            the group of worker threads.
            </li>
            <li> <see cref="M:Spring.Threading.ForkJoin.FJTask.Fork"/> (as well as the two-task spawning method,
            <see cref="M:FJTask.CoInvoke"/>) starts a task 
            that will be executed in
            procedure-call-like LIFO order if executed by the 
            same worker thread as the one that created it, but is FIFO 
            with respect to other tasks if it is run by
            other worker threads. That is, earlier-forked
            tasks are preferred to later-forked tasks by other idle workers.
            Fork() is noticeably faster than start(), but can only be
            used when these scheduling semantics are acceptable.
            </li>
            <li> <see cref="M:Spring.Threading.ForkJoin.FJTask.Invoke(Spring.Threading.ForkJoin.FJTask)"/>  just executes the run method
            of one task from within another. It is the analog of a
            direct call.
            </li>
            </ul>
            </p>
            <p>
            The main economies of FJTasks stem from the fact that
            FJTasks do not support blocking operations of any kind. 
            FJTasks should just run to completion without
            issuing waits or performing blocking IO. 
            There are several styles for creating the run methods that
            execute as tasks, including
            event-style methods, and pure computational methods.
            Generally, the best kinds of FJTasks are those that in turn
            generate other FJTasks. 
            </p>
            <p>
            There is nothing actually
            preventing you from blocking within a FJTask, and very short waits/blocks are
            completely well behaved. But FJTasks are not designed
            to support arbitrary synchronization 
            since there is no way to suspend and resume individual tasks
            once they have begun executing. FJTasks should also be finite
            in duration -- they should not contain infinite loops.
            FJTasks that might need to perform a blocking
            action, or hold locks for extended periods, or 
            loop forever can instead create normal 
            <see cref="T:System.Threading.Thread"/>objects that will do so. FJTasks are just not
            designed to support these things. 
            FJTasks may however <see cref="M:Spring.Threading.ForkJoin.FJTask.Yield"/> control to allow their FJTaskRunner threads
            to run other tasks,
            and may wait for other dependent tasks via <see cref="M:Spring.Threading.ForkJoin.FJTask.Join"/>. These
            are the only coordination mechanisms supported by FJTasks.
            </p>
            <p>
            FJTasks, and the FJTaskRunners that execute them are not
            intrinsically robust with respect to exceptions. 
            A FJTask that aborts via an exception does not automatically
            have its completion flag (<see cref="P:Spring.Threading.ForkJoin.FJTask.Done"/>) set. 
            As with ordinary Threads, an uncaught exception will normally cause
            its FJTaskRunner thread to die, which in turn may sometimes
            cause other computations being performed to hang or abort.
            You can of course
            do better by trapping exceptions inside the run methods of FJTasks.
            </p>
            <p>
            The overhead differences between FJTasks and Threads are substantial,
            especially when using <see cref="M:Spring.Threading.ForkJoin.FJTask.Fork"/> or <see cref="M:FJTask.CoInvoke"/> .
            FJTasks can be two or three orders of magnitude faster than <see cref="T:System.Threading.Thread"/>s,
            at least with high-performance garbage collection
            (every FJTask quickly becomes garbage) and good native thread support.
            </p>
            <p>
            Given these overhead savings, you might be tempted to use FJTasks for 
            everything you would use a normal Thread to do. Don't. Threads
            remain better for general purpose thread-based programming. Remember
            that FJTasks cannot be used for designs involving arbitrary blocking 
            synchronization or I/O. Extending FJTasks to support such capabilities
            would amount to re-inventing the Thread class, and would make them
            less optimal in the contexts that they were designed for.
            </p>
            </summary>
            <seealso cref="P:Spring.Threading.ForkJoin.FJTask.FJTaskRunner"/>
            <seealso cref="P:Spring.Threading.ForkJoin.FJTask.FJTaskRunnerGroup"/>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.done">
            <summary> The only status information associated with FJTasks is whether
            the they are considered to have completed.
            It is set true automatically within
            FJTaskRunner methods upon completion
            of the run method, or manually via cancel.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.SetDone">
            <summary> Indicate termination. Intended only to be called by FJTaskRunner.
            FJTasks themselves should use (non-final) method
            cancel() to suppress execution.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Cancel">
            <summary> Set the termination status of this task. This simple-minded
            analog of Thread.interrupt
            causes the task not to execute if it has not already been started.
            Cancelling a running FJTask
            has no effect unless the run method itself uses isDone()
            to probe cancellation and take appropriate action.
            Individual run() methods may sense status and
            act accordingly, normally by returning early. 
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Reset">
            <summary> Clear the termination status of this task. 
            This method is intended to be used
            only as a means to allow task objects to be recycled. It should
            be called only when you are sure that the previous
            execution of this task has terminated and, if applicable, has
            been joined by all other waiting tasks. Usage in any other
            context is a very bad idea.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Start">
            <summary> Execute this task. This method merely places the task in a 
            group-wide scheduling queue.
            It will be run 
            the next time any TaskRunner thread is otherwise idle.
            This scheduling  maintains FIFO ordering of started tasks 
            with respect to
            the group of worker threads.
            </summary>		
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Fork">
            <summary> Arrange for execution of a strictly dependent task.
            The task that will be executed in
            procedure-call-like LIFO order if executed by the 
            same worker thread, but is FIFO with respect to other tasks
            forked by this thread when taken by other worker threads. 
            That is, earlier-forked
            tasks are preferred to later-forked tasks by other idle workers.
            <p>
            Fork() is noticeably
            faster than start(). However, it may only
            be used for strictly dependent tasks -- generally, those that
            could logically be issued as straight method calls without 
            changing the logic of the program.
            The method is optimized for use in parallel fork/join designs
            in which the thread that issues one or more forks
            cannot continue until at least some of the forked 
            threads terminate and are joined. 
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Yield">
            <summary> Allow the current underlying FJTaskRunner thread to process other tasks.
            <p>
            Spinloops based on yield() are well behaved so long
            as the event or condition being waited for is produced via another
            FJTask. Additionally, you must never hold a lock
            while performing a yield or join. (This is because
            multiple FJTasks can be run by the same Thread during
            a yield. Since java locks are held per-thread, the lock would not
            maintain the conceptual exclusion you have in mind.)
            </p>
            <p>
            Otherwise, spinloops using
            yield are the main construction of choice when a task must wait
            for a condition that it is sure will eventually occur because it
            is being produced by some other FJTask.  The most common
            such condition is built-in: join() repeatedly yields until a task
            has terminated after producing some needed results. You can also
            use yield to wait for callbacks from other FJTasks, to wait for
            status flags to be set, and so on. However, in all these cases,
            you should be confident that the condition being waited for will
            occur, essentially always because it is produced by 
            a FJTask generated by the current task, or one of its subtasks.
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Join">
            <summary> Yield until this task isDone.
            Equivalent to <code>while(!isDone()) yield(); </code>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Invoke(Spring.Threading.ForkJoin.FJTask)">
            <summary> Immediately execute task t by calling its run method. Has no
            effect if t has already been run or has been cancelled.
            It is equivalent to  calling t.run except that it
            deals with completion status, so should always be used
            instead of directly calling run.
            The method can be useful
            when a computation has been packaged as a FJTask, but you just need to 
            directly execute its body from within some other task.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.CoInvoke(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary> Fork both tasks and then wait for their completion. It behaves as:
            <pre>
            task1.fork(); task2.fork(); task2.join(); task1.join();
            </pre>
            As a simple classic example, here is
            a class that computes the Fibonacci function:
            <pre>
            public class Fib extends FJTask {
            
            // Computes fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);  for n> 1
            //          fibonacci(0) = 0; 
            //          fibonacci(1) = 1.       
            
            // Value to compute fibonacci function for.
            // It is replaced with the answer when computed.
            private volatile int number;
            
            public Fib(int n) { number = n; }
            
            public int getAnswer() {
            if (!isDone()) throw new Error("Not yet computed");
            return number;
            }
            
            public void run() {
            int n = number;
            if (n > 1) {
            Fib f1 = new Fib(n - 1);
            Fib f2 = new Fib(n - 2);
            
            coInvoke(f1, f2); // run these in parallel
            
            // we know f1 and f2 are computed, so just directly access numbers
            number = f1.number + f2.number;
            }
            }
            
            public static void main(String[] args) { // sample driver
            try {
            int groupSize = 2;    // 2 worker threads
            int num = 35;         // compute fib(35)
            FJTaskRunnerGroup group = new FJTaskRunnerGroup(groupSize);
            Fib f = new Fib(num);
            group.invoke(f);
            int result = f.getAnswer();
            System.out.println(" Answer: " + result);
            }
            catch (InterruptedException ex) {
            System.out.println("Interrupted");
            }
            }
            }
            </pre>
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.CoInvoke(Spring.Threading.ForkJoin.FJTask[])">
            <summary> Fork all tasks in array, and await their completion.
            Behaviorally equivalent to:
            <pre>
            for (int i = 0; i &lt; tasks.length; ++i) tasks[i].fork();
            for (int i = 0; i &lt; tasks.length; ++i) tasks[i].join();
            </pre>
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.NewSeq(Spring.Threading.ForkJoin.FJTask[],Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Construct and return a FJTask object that, when executed, will
            invoke the tasks in the tasks array in array order
            </summary>		
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.NewPar(Spring.Threading.ForkJoin.FJTask[],Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Construct and return a FJTask object that, when executed, will
            invoke the tasks in the tasks array in parallel using coInvoke
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.NewSeq(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Construct and return a FJTask object that, when executed, will
            invoke task1 and task2, in order
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.NewPar(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Construct and return a FJTask object that, when executed, will
            invoke task1 and task2, in parallel
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Run">
            <summary>
            The entry point
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTask.FJTaskRunner">
            <summary> Return the FJTaskRunner running the current FJTask.
            Most FJTask methods are just relays to their current
            FJTaskRunners, that perform the indicated actions.
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTask.FJTaskRunnerGroup">
            <summary> Return the FJTaskRunnerGroup of the thread running the current FJTask.</summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTask.Done">
            <summary>
            Was terminated ?
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTask.Wrap">
            <summary> A FJTask that holds a Runnable r, and calls r.run when executed.
            The class is a simple utilty to allow arbitrary Runnables
            to be used as FJTasks.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Wrap.runnable">
            <summary>
            the wrapped runnable
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Wrap.#ctor(Spring.Threading.IRunnable)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.FJTask.Wrap"/> instance.
            </summary>
            <param name="r">R.</param>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Wrap.Run">
            <summary>
            Runs the wrapped <see cref="T:Spring.Threading.IRunnable"/> instance.
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTask.Seq">
            <summary> A  <code>new Seq</code>, when executed,
            invokes each task provided in the constructor,  in order. 
            The class is a simple utility
            that makes it easier to create composite FJTasks. 
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Seq.tasks">
            <summary>
            The sequential task to run
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Seq.#ctor(Spring.Threading.ForkJoin.FJTask[])">
            <summary> Construct a Seq that, when executed, will process each of the
            tasks in the tasks array in order
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Seq.#ctor(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary> 
            Two-task constructor, for compatibility with previous release.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Seq.Run">
            <summary>
            Runs this instance.
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTask.Par">
            <summary> A <code>new Par</code>, when executed,
            runs the tasks provided in the constructor in parallel using 
            coInvoke(tasks).
            The class is a simple utility
            that makes it easier to create composite FJTasks. 
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Par.tasks">
            <summary>
            task list
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Par.#ctor(Spring.Threading.ForkJoin.FJTask[])">
            <summary> Construct a Seq that, when executed, will process each of the
            tasks in the tasks array in parallel
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Par.#ctor(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary> Two-task constructor, for compatibility with previous release.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Par.Run">
            <summary>
            <see cref="M:FJTask.CoInvoke"/> tasks
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTask.Seq2">
            <summary> A  <code>new Seq2(task1, task2)</code>, when executed,
            invokes task1 and then task2, in order. 
            The class is a simple utility
            that makes it easier to create composite Tasks. 
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Seq2.fst">
            <summary>
            fisrt task
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Seq2.snd">
            <summary>
            second task
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Seq2.#ctor(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.FJTask.Seq2"/> instance.
            </summary>
            <param name="task1">Task1.</param>
            <param name="task2">Task2.</param>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Seq2.Run">
            <summary>
            Invoke first and second task
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTask.Par2">
            <summary> A <code>new Par(task1, task2)</code>, when executed,
            runs task1 and task2 in parallel using coInvoke(task1, task2).
            The class is a simple utility
            that makes it easier to create composite Tasks. 
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Par2.fst">
            <summary>
            first task
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTask.Par2.snd">
            <summary>
            second task
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Par2.#ctor(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.FJTask.Par2"/> instance.
            </summary>
            <param name="task1">Task1.</param>
            <param name="task2">Task2.</param>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTask.Par2.Run">
            <summary>
            run first and second task
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTaskRunner">
            <summary> Specialized Thread subclass for running FJTasks.
            <p>
            Each FJTaskRunner keeps FJTasks in a double-ended queue (DEQ).
            Double-ended queues support stack-based operations
            push and pop, as well as queue-based operations put and take.
            Normally, threads run their own tasks. But they
            may also steal tasks from each others DEQs.
            </p>
            <p>
            The algorithms are minor variants of those used
            in <A href="http://supertech.lcs.mit.edu/cilk/"> Cilk</A> and
            <A href="http://www.cs.utexas.edu/users/hood/"> Hood</A>, and
            to a lesser extent 
            <A href="http://www.cs.uga.edu/~dkl/filaments/dist.html"> Filaments</A>,
            but are adapted to work in Java.
            </p>
            <p>
            The two most important capabilities are:
            <ul>
            <li> Fork a FJTask:</li>
            <pre>
            Push task onto DEQ
            </pre>
            <li> Get a task to run (for example within taskYield)</li>
            <pre>
            If DEQ is not empty, 
            Pop a task and run it.
            Else if any other DEQ is not empty, 
            Take ("steal") a task from it and run it.
            Else if the entry queue for our group is not empty,
            Take a task from it and run it.
            Else if current thread is otherwise idling
            If all threads are idling
            Wait for a task to be put on group entry queue
            Else
            Yield or Sleep for a while, and then retry
            </pre>
            </ul>
            The push, pop, and put are designed to only ever called by the
            current thread, and take (steal) is only ever called by
            other threads.
            All other operations are composites and variants of these,
            plus a few miscellaneous bookkeeping methods.
            </p>
            <p>
            Implementations of the underlying representations and operations
            are geared for use on JVMs operating on multiple CPUs (although
            they should of course work fine on single CPUs as well).
            </p>
            <p>
            A possible snapshot of a FJTaskRunner's DEQ is:
            <pre>
            0     1     2     3     4     5     6    ...
            +-----+-----+-----+-----+-----+-----+-----+--
            |     |  t  |  t  |  t  |  t  |     |     | ...  deq array
            +-----+-----+-----+-----+-----+-----+-----+--
            ^                       ^
            base                    top 
            (incremented                     (incremented 
            on take,                         on push    
            decremented                     decremented
            on put)                          on pop)
            </pre>
            </p>
            <p>
            FJTasks are held in elements of the DEQ. 
            They are maintained in a bounded array that
            works similarly to a circular bounded buffer. To ensure
            visibility of stolen FJTasks across threads, the array elements
            must be <code>volatile</code>. 
            Using volatile rather than synchronizing suffices here since
            each task accessed by a thread is either one that it
            created or one that has never seen before. Thus we cannot
            encounter any staleness problems executing run methods,
            although FJTask programmers must be still sure to either synch or use
            volatile for shared data within their run methods.
            </p>
            <p>
            However, since there is no way
            to declare an array of volatiles in Java, the DEQ elements actually
            hold VolatileTaskRef objects, each of which in turn holds a
            volatile reference to a FJTask. 
            Even with the double-indirection overhead of 
            volatile refs, using an array for the DEQ works out
            better than linking them since fewer shared
            memory locations need to be
            touched or modified by the threads while using the DEQ.
            Further, the double indirection may alleviate cache-line
            sharing effects (which cannot otherwise be directly dealt with in Java).
            </p>
            <p>
            The indices for the <code>base</code> and <code>top</code> of the DEQ
            are declared as volatile. The main contention point with
            multiple FJTaskRunner threads occurs when one thread is trying
            to pop its own stack while another is trying to steal from it.
            This is handled via a specialization of Dekker's algorithm,
            in which the popping thread pre-decrements <code>top</code>,
            and then checks it against <code>base</code>. 
            To be conservative in the face of JVMs that only partially
            honor the specification for volatile, the pop proceeds
            without synchronization only if there are apparently enough
            items for both a simultaneous pop and take to succeed.
            It otherwise enters a 
            synchronized lock to check if the DEQ is actually empty,
            if so failing. The stealing thread
            does almost the opposite, but is set up to be less likely
            to win in cases of contention: Steals always run under synchronized
            locks in order to avoid conflicts with other ongoing steals.
            They pre-increment <code>base</code>, and then check against
            <code>top</code>. They back out (resetting the base index 
            and failing to steal) if the
            DEQ is empty or is about to become empty by an ongoing pop.
            </p>
            <p>
            A push operation can normally run concurrently with a steal.
            A push enters a synch lock only if the DEQ appears full so must
            either be resized or have indices adjusted due to wrap-around
            of the bounded DEQ. The put operation always requires synchronization.
            </p>
            <p>
            When a FJTaskRunner thread has no tasks of its own to run, 
            it tries to be a good citizen. 
            Threads run at lower priority while scanning for work.
            </p>
            <p>
            If the task is currently waiting
            via yield, the thread alternates scans (starting at a randomly 
            chosen victim) with Thread.yields. This is
            well-behaved so long as the JVM handles Thread.yield in a
            sensible fashion. (It need not. Thread.yield is so underspecified
            that it is legal for a JVM to treat it as a no-op.) This also
            keeps things well-behaved even if we are running on a uniprocessor
            JVM using a simple cooperative threading model.
            </p>
            <p>
            If a thread needing work is
            is otherwise idle (which occurs only in the main runloop), and
            there are no available tasks to steal or poll, it
            instead enters into a sleep-based (actually timed wait(msec))
            phase in which it progressively sleeps for longer durations
            (up to a maximum of FJTaskRunnerGroup.MAX_SLEEP_TIME,
            currently 100ms) between scans. 
            If all threads in the group
            are idling, they further progress to a hard wait phase, suspending
            until a new task is entered into the FJTaskRunnerGroup entry queue.
            A sleeping FJTaskRunner thread may be awakened by a new
            task being put into the group entry queue or by another FJTaskRunner
            becoming active, but not merely by some DEQ becoming non-empty.
            Thus the MAX_SLEEP_TIME provides a bound for sleep durations
            in cases where all but one worker thread start sleeping
            even though there will eventually be work produced
            by a thread that is taking a long time to place tasks in DEQ.
            These sleep mechanics are handled in the FJTaskRunnerGroup class.
            </p>
            <p>
            Composite operations such as taskJoin include heavy
            manual inlining of the most time-critical operations
            (mainly FJTask.invoke). 
            This opens up a few opportunities for further hand-optimizations. 
            Until Java compilers get a lot smarter, these tweaks
            improve performance significantly enough for task-intensive 
            programs to be worth the poorer maintainability and code duplication.
            </p>
            <p>
            Because they are so fragile and performance-sensitive, nearly
            all methods are declared as final. However, nearly all fields
            and methods are also declared as protected, so it is possible,
            with much care, to extend functionality in subclasses. (Normally
            you would also need to subclass FJTaskRunnerGroup.)
            </p>
            <p>
            None of the normal java.lang.Thread class methods should ever be called
            on FJTaskRunners. For this reason, it might have been nicer to
            declare FJTaskRunner as a Runnable to run within a Thread. However,
            this would have complicated many minor logistics. And since
            no FJTaskRunner methods should normally be called from outside the
            FJTask and FJTaskRunnerGroup classes either, this decision doesn't impact
            usage.
            </p>
            <p>
            You might think that layering this kind of framework on top of
            Java threads, which are already several levels removed from raw CPU
            scheduling on most systems, would lead to very poor performance. 
            But on the platforms
            tested, the performance is quite good.
            </p>
            </summary>
            <seealso cref="T:Spring.Threading.ForkJoin.FJTask">
            </seealso>
            <seealso cref="T:Spring.Threading.ForkJoin.FJTaskRunnerGroup">
            </seealso>
        </member>
        <member name="T:Spring.Threading.ForkJoin.ThreadClass">
            <summary>
            <see cref="T:System.Threading.Thread"/> wrapper for <see cref="T:Spring.Threading.ForkJoin.FJTask"/> stuff
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.ThreadClass.thread">
            <summary>
            The backing thread
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.#ctor">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.ThreadClass"/> instance.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.#ctor(System.Threading.Thread)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.ThreadClass"/> instance.
            </summary>
            <param name="thread">Thread.</param>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.SetThread(System.Threading.Thread)">
            <summary>
            sets the backing thread
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.Start">
            <summary>
            Starts this instance.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.Interrupt">
            <summary>
            Interrupts this instance.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.Join">
            <summary>
            Joins this instance.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.Join(System.Int32)">
            <summary>
            Joins the specified milliseconds timeout.
            </summary>
            <param name="millisecondsTimeout">Milliseconds timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.ForkJoin.ThreadClass.Join(System.TimeSpan)">
            <summary>
            Joins the specified timeout.
            </summary>
            <param name="timeout">Timeout.</param>
            <returns></returns>
        </member>
        <member name="P:Spring.Threading.ForkJoin.ThreadClass.Interrupted">
            <summary>
            Gets a value indicating whether this <see cref="T:Spring.Threading.ForkJoin.ThreadClass"/> is interrupted.
            </summary>
            <value>
            	<c>true</c> if interrupted; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Spring.Threading.ForkJoin.ThreadClass.Priority">
            <summary>
            Gets or sets the priority.
            </summary>
            <value></value>
        </member>
        <member name="P:Spring.Threading.ForkJoin.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating whether this instance is alive.
            </summary>
            <value>
            	<c>true</c> if this instance is alive; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Spring.Threading.ForkJoin.ThreadClass.IsThreadPoolThread">
            <summary>
            Gets a value indicating whether this instance is thread pool thread.
            </summary>
            <value>
            	<c>true</c> if this instance is thread pool thread; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Spring.Threading.ForkJoin.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether this instance is background.
            </summary>
            <value>
            	<c>true</c> if this instance is background; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Spring.Threading.ForkJoin.ThreadClass.Current">
            <summary>
            Gets the current Thread.
            </summary>
            <value></value>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.INITIAL_CAPACITY">
            <summary> FJTasks are held in an array-based DEQ with INITIAL_CAPACITY
            elements. The DEQ is grown if necessary, but default value is
            normally much more than sufficient unless  there are
            user programming errors or questionable operations generating
            large numbers of Tasks without running them.
            Capacities must be a power of two. 
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.MAX_CAPACITY">
            <summary> The maximum supported DEQ capacity.
            When exceeded, FJTaskRunner operations throw Errors
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.#ctor(System.Threading.Thread)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.FJTaskRunner"/> instance.
            </summary>
            <param name="thread">backing thread</param>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.group_">
            <summary>The group of which this FJTaskRunner is a member *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.#ctor(Spring.Threading.ForkJoin.FJTaskRunnerGroup)">
            <summary>  
            Constructor called only during FJTaskRunnerGroup initialization
            </summary>		
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.deq">
            <summary> 
            The DEQ array.
            </summary>		
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.deqSize">
            <summary>Current size of the task DEQ *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.top">
            <summary> Current top of DEQ. Generally acts just like a stack pointer in an 
            array-based stack, except that it circularly wraps around the
            array, as in an array-based queue. The value is NOT
            always kept within <code>0 ... deq.length</code> though. 
            The current top element is always at <code>top &amp; (deq.length-1)</code>.
            To avoid integer overflow, top is reset down 
            within bounds whenever it is noticed to be out out bounds;
            at worst when it is at <code>2 * deq.length</code>.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.base_Renamed">
            <summary> Current base of DEQ. Acts like a take-pointer in an
            array-based bounded queue. Same bounds and usage as top.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.barrier">
            <summary> An extra object to synchronize on in order to
            achieve a memory barrier.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.active">
            <summary> Record whether current thread may be processing a task
            (i.e., has been started and is not in an idle wait).
            Accessed, under synch, ONLY by FJTaskRunnerGroup, but the field is
            stored here for simplicity.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.victimRNG">
            <summary>Random starting point generator for scan() *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.scanPriority_">
            <summary>Priority to use while scanning for work *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.runPriority_">
            <summary>Priority to use while running tasks *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.runs">
            <summary>Total number of tasks run *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.scans">
            <summary>Total number of queues scanned for work *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.steals">
            <summary>Total number of tasks obtained via scan *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.push(Spring.Threading.ForkJoin.FJTask)">
            <summary> Push a task onto DEQ.
            Called ONLY by current thread.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.slowPush(Spring.Threading.ForkJoin.FJTask)">
            <summary> Handle slow case for push
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.put(Spring.Threading.ForkJoin.FJTask)">
            <summary> Enqueue task at base of DEQ.
            Called ONLY by current thread.
            This method is currently not called from class FJTask. It could be used
            as a faster way to do FJTask.start, but most users would
            find the semantics too confusing and unpredictable.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.pop">
            <summary> Return a popped task, or null if DEQ is empty.
            Called ONLY by current thread.
            <p>
            This is not usually called directly but is
            instead inlined in callers. This version differs from the
            cilk algorithm in that pop does not fully back down and
            retry in the case of potential conflict with take. It simply
            rechecks under synch lock. This gives a preference
            for threads to run their own tasks, which seems to
            reduce flailing a bit when there are few tasks to run.
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.confirmPop(System.Int32)">
            <summary> Check under synch lock if DEQ is really empty when doing pop. 
            Return task if not empty, else null.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.take">
            <summary> Take a task from the base of the DEQ.
            Always called by other threads via scan()
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.confirmTake(System.Int32)">
            <summary> double-check a potential take
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.checkOverflow">
            <summary> Adjust top and base, and grow DEQ if necessary.
            Called only while DEQ synch lock being held.
            We don't expect this to be called very often. In most
            programs using FJTasks, it is never called.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.scan(Spring.Threading.ForkJoin.FJTask)">
            <summary> Do all but the pop() part of yield or join, by
            traversing all DEQs in our group looking for a task to
            steal. If none, it checks the entry queue. 
            <p>
            Since there are no good, portable alternatives,
            we rely here on a mixture of Thread.yield and priorities
            to reduce wasted spinning, even though these are
            not well defined. We are hoping here that the JVM
            does something sensible.
            </p>
            </summary>
            <param name="waitingFor">if non-null, the current task being joined
            
            </param>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.scanWhileIdling">
            <summary> Same as scan, but called when current thread is idling.
            It repeatedly scans other threads for tasks,
            sleeping while none are available. 
            <p>
            This differs from scan mainly in that
            since there is no reason to return to recheck any
            condition, we iterate until a task is found, backing
            off via sleeps if necessary.
            </p>
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.DoStart">
            <summary> Main runloop
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.taskYield">
            <summary> Execute a task in this thread. Generally called when current task
            cannot otherwise continue.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.taskJoin(Spring.Threading.ForkJoin.FJTask)">
            <summary> Process tasks until w is done.
            Equivalent to <code>while(!w.isDone()) taskYield(); </code>
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.coInvoke(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary> A specialized expansion of
            <code> w.fork(); invoke(v); w.join(); </code>
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.slowCoInvoke(Spring.Threading.ForkJoin.FJTask,Spring.Threading.ForkJoin.FJTask)">
            <summary> Backup to handle noninlinable cases of coInvoke
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.coInvoke(Spring.Threading.ForkJoin.FJTask[])">
            <summary> Array-based version of coInvoke
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.slowCoInvoke(Spring.Threading.ForkJoin.FJTask[])">
            <summary> Backup to handle atypical or noninlinable cases of coInvoke
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.New(Spring.Threading.ForkJoin.FJTaskRunnerGroup)">
            <summary>
            Create a new <see cref="T:Spring.Threading.ForkJoin.FJTaskRunner"/>, setting its thread
            as needed
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.SetThread(System.Threading.Thread)">
            <summary>
            sets the backing thread and priority
            <seealso cref="T:Spring.Threading.ForkJoin.ThreadClass"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunner.Group">
            <summary> Return the FJTaskRunnerGroup of which this thread is a member
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunner.ScanPriority">
            <summary> Set the priority to use while scanning.
            We do not bother synchronizing access, since
            by the time the value is needed, both this FJTaskRunner 
            and its FJTaskRunnerGroup will
            necessarily have performed enough synchronization
            to avoid staleness problems of any consequence.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunner.RunPriority">
            <summary> Set the priority to use while running tasks.
            Same usage and rationale as setScanPriority.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTaskRunner.VolatileTaskRef">
            <summary> An object holding a single volatile reference to a FJTask.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunner.VolatileTaskRef.ref_">
            <summary>The reference *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.VolatileTaskRef.Put(Spring.Threading.ForkJoin.FJTask)">
            <summary>Set the reference *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.VolatileTaskRef.Get">
            <summary>Return the reference *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.VolatileTaskRef.Take">
            <summary>Return the reference and clear it *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunner.VolatileTaskRef.NewArray(System.Int32)">
            <summary> Initialization utility for constructing arrays. 
            Make an array of given capacity and fill it with
            VolatileTaskRefs.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTaskRunnerGroup">
            <summary> A stripped down analog of a ThreadGroup used for
            establishing and managing FJTaskRunner threads.
            ThreadRunnerGroups serve as the control boundary separating
            the general world of normal threads from the specialized world
            of FJTasks. 
            <p>
            By intent, this class does not subclass java.lang.ThreadGroup, and
            does not support most methods found in ThreadGroups, since they
            would make no sense for FJTaskRunner threads. In fact, the class
            does not deal with ThreadGroups at all. If you want to restrict
            a FJTaskRunnerGroup to a particular ThreadGroup, you can create
            it from within that ThreadGroup.
            </p>
            <p>
            The main contextual parameter for a FJTaskRunnerGroup is
            the group size, established in the constructor. 
            Groups must be of a fixed size.
            There is no way to dynamically increase or decrease the number
            of threads in an existing group.
            </p>
            <p>
            In general, the group size should be equal to the number
            of CPUs on the system. (Unfortunately, there is no portable
            means of automatically detecting the number of CPUs on a JVM, so there is
            no good way to automate defaults.)  In principle, when
            FJTasks are used for computation-intensive tasks, having only 
            as many threads as CPUs should minimize bookkeeping overhead
            and contention, and so maximize throughput. However, because
            FJTaskRunners lie atop CLR threads, and in turn operating system
            thread support and scheduling policies, 
            it is very possible that using more threads
            than CPUs will improve overall throughput even though it adds
            to overhead. This will always be so if FJTasks are I/O bound.
            So it may pay to experiment a bit when tuning on particular platforms.
            You can also use <code>setRunPriorities</code> to either
            increase or decrease the priorities of active threads, which
            may interact with group size choice.
            </p>
            <p>
            In any case, overestimating group sizes never
            seriously degrades performance (at least within reasonable bounds). 
            You can also use a value
            less than the number of CPUs in order to reserve processing
            for unrelated threads. 
            </p>
            <p>
            There are two general styles for using a FJTaskRunnerGroup.
            You can create one group per entire program execution, for example 
            as a static singleton, and use it for all parallel tasks:
            <pre>
            class Tasks {
            static FJTaskRunnerGroup group;
            public void initialize(int groupsize) {
            group = new FJTaskRunnerGroup(groupSize);
            }
            // ...
            }
            </pre>
            Alternatively, you can make new groups on the fly and use them only for
            particular task sets. This is more flexible,,
            and leads to more controllable and deterministic execution patterns,
            but it encounters greater overhead on startup. Also, to reclaim
            system resources, you should
            call <code>FJTaskRunnerGroup.interruptAll</code> when you are done
            using one-shot groups. Otherwise, because FJTaskRunners set 
            <code>Thread.isDaemon</code>
            status, they will not normally be reclaimed until program termination.
            </p>
            <p>
            The main supported methods are <code>execute</code>,
            which starts a task processed by FJTaskRunner threads,
            and <code>invoke</code>, which starts one and waits for completion.
            For example, you might extend the above <code>FJTasks</code>
            class to support a task-based computation, say, the
            <code>Fib</code> class from the <code>FJTask</code> documentation:
            <pre>
            class Tasks { // continued
            // ...
            static int fib(int n) {
            try {
            Fib f = new Fib(n);
            group.invoke(f);
            return f.getAnswer();
            }
            catch (InterruptedException ex) {
            throw new Error("Interrupted during computation");
            }
            }
            }
            </pre>
            </p>
            <p>
            Method <code>stats()</code> can be used to monitor performance.
            Both FJTaskRunnerGroup and FJTaskRunner may be compiled with
            the compile-time constant COLLECT_STATS set to false. In this
            case, various simple counts reported in stats() are not collected.
            On platforms tested,
            this leads to such a tiny performance improvement that there is 
            very little motivation to bother.
            </p>
            </summary>
            <seealso cref="T:Spring.Threading.ForkJoin.FJTask">
            </seealso>
            <seealso cref="T:Spring.Threading.ForkJoin.FJTaskRunner">
            
            </seealso>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.CollectStats">
            <summary> Compile-time constant. If true, various counts of
            runs, waits, etc., are maintained. These are NOT
            updated with synchronization, so statistics reports
            might not be accurate.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.ScansPerSleep">
            <summary> The number of times to scan other threads for tasks 
            before transitioning to a mode where scans are
            interleaved with sleeps (actually timed waits).
            Upon transition, sleeps are for duration of
            scans / SCANS_PER_SLEEP milliseconds.
            <p>
            This is not treated as a user-tunable parameter because
            good values do not appear to vary much across JVMs or
            applications. Its main role is to help avoid some
            useless spinning and contention during task startup.
            </p>
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.MaxSleepTime">
            <summary> The maximum time (in msecs) to sleep when a thread is idle,
            yet others are not, so may eventually generate work that
            the current thread can steal. This value reflects the maximum time
            that a thread may sleep when it possibly should not, because there
            are other active threads that might generate work. In practice,
            designs in which some threads become stalled because others
            are running yet not generating tasks are not likely to work
            well in this framework anyway, so the exact value does not matter
            too much. However, keeping it in the sub-second range does
            help smooth out startup and shutdown effects.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.threads">
            <summary>The threads in this group *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.entryQueue">
            <summary>Group-wide queue for tasks entered via execute() *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.activeCount_">
            <summary>Number of threads that are not waiting for work *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.nstarted">
            <summary>Number of threads that have been started. Used to avoid
            unecessary contention during startup of task sets.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.initTime">
            <summary>The time at which this ThreadRunnerGroup was constructed *</summary>
        </member>
        <member name="F:Spring.Threading.ForkJoin.FJTaskRunnerGroup.entries">
            <summary>Total number of executes or invokes *</summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.#ctor(System.Int32)">
            <summary> Create a FJTaskRunnerGroup with the indicated number
            of FJTaskRunner threads. Normally, the best size to use is
            the number of CPUs on the system. 
            <p>
            The threads in a FJTaskRunnerGroup are created with their
            isDaemon status set, so do not normally need to be
            shut down manually upon program termination.
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Execute(Spring.Threading.IRunnable)">
            <summary> Arrange for execution of the given task
            by placing it in a work queue. If the argument
            is not of type FJTask, it is embedded in a FJTask via 
            <code>FJTask.Wrap</code>.
            </summary>
            <exception cref="T:System.Threading.ThreadInterruptedException">  if current Thread is
            currently interrupted 
            
            </exception>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Execute(System.Action)">
            <summary> Arrange for execution of the given task
            by placing it in a work queue. If the argument
            is not of type FJTask, it is embedded in a FJTask via 
            <code>FJTask.Wrap</code>.
            </summary>
            <exception cref="T:System.Threading.ThreadInterruptedException">  if current Thread is
            currently interrupted 
            
            </exception>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.ExecuteTask(Spring.Threading.ForkJoin.FJTask)">
            <summary> 
            Specialized form of execute called only from within FJTasks
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Invoke(Spring.Threading.IRunnable)">
            <summary> Start a task and wait it out. Returns when the task completes.</summary>
            <exception cref="T:System.Threading.ThreadInterruptedException">  if current Thread is
            interrupted before completion of the task.
            </exception>		
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.InterruptAll">
            <summary> Try to shut down all FJTaskRunner threads in this group
            by interrupting them all. This method is designed
            to be used during cleanup when it is somehow known
            that all threads are idle.
            FJTaskRunners only
            check for interruption when they are not otherwise
            processing a task (and its generated subtasks,
            if any), so if any threads are active, shutdown may
            take a while, and may lead to unpredictable
            task processing.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Size">
            <summary>
            Return the number of FJTaskRunner threads in this group
            </summary>		
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Stats(System.IO.TextWriter)">
            <summary> Prints various snapshot statistics to System.out.
            <ul>
            <li> For each FJTaskRunner thread (labeled as T<em>n</em>, for
            <em>n</em> from zero to group size - 1):</li>
            <ul>
            <li> A star "*" is printed if the thread is currently active;
            that is, not sleeping while waiting for work. Because
            threads gradually enter sleep modes, an active thread
            may in fact be about to sleep (or wake up).</li>
            <li> <em>Q Cap</em> The current capacity of its task queue.</li>
            <li> <em>Run</em> The total number of tasks that have been run.</li>
            <li> <em>New</em> The number of these tasks that were
            taken from either the entry queue or from other 
            thread queues; that is, the number of tasks run
            that were <em>not</em> forked by the thread itself.</li>
            <li> <em>Scan</em> The number of times other task</li>
            queues or the entry queue were polled for tasks.
            </ul>
            <li> <em>Execute</em> The total number of tasks entered
            (but not necessarily yet run) via execute or invoke.</li>
            <li> <em>Time</em> Time in seconds since construction of this
            FJTaskRunnerGroup.</li>
            <li> <em>Rate</em> The total number of tasks processed
            per second across all threads. This
            may be useful as a simple throughput indicator
            if all processed tasks take approximately the
            same time to run.</li>
            </ul>
            <p>
            Cautions: Some statistics are updated and gathered 
            without synchronization,
            so may not be accurate. However, reported counts may be considered
            as lower bounds of actual values. 
            Some values may be zero if classes are compiled
            with COLLECT_STATS set to false. (FJTaskRunner and FJTaskRunnerGroup
            classes can be independently compiled with different values of
            COLLECT_STATS.) Also, the counts are maintained as ints so could
            overflow in exceptionally long-lived applications.
            </p>
            <p>
            These statistics can be useful when tuning algorithms or diagnosing
            problems. For example:
            </p>
            <ul>
            <li> High numbers of scans may mean that there is insufficient
            parallelism to keep threads busy. However, high scan rates
            are expected if the number
            of Executes is also high or there is a lot of global
            synchronization in the application, and the system is not otherwise
            busy. Threads may scan
            for work hundreds of times upon startup, shutdown, and
            global synch points of task sets.</li>
            <li> Large imbalances in tasks run across different threads might
            just reflect contention with unrelated threads on a system
            (possibly including JVM threads such as GC), but may also
            indicate some systematic bias in how you generate tasks.</li>
            <li> Large task queue capacities may mean that too many tasks are being
            generated before they can be run. 
            Capacities are reported rather than current numbers of tasks
            in queues because they are better indicators of the existence
            of these kinds of possibly-transient problems.
            Queue capacities are
            resized on demand from their initial value of 4096 elements,
            which is much more than sufficient for the kinds of 
            applications that this framework is intended to best support.</li>
            </ul>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.PollEntryQueue(Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Return a task from entry queue, or null if empty.
            Called only by FJTaskRunner.scan().
            
            </summary>		
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.GetActive(Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Return active status of t.
            Per-thread active status can only be accessed and
            modified via synchronized method here in the group class.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.SetActive(Spring.Threading.ForkJoin.FJTaskRunner)">
            <summary> Set active status of thread t to true, and notify others
            that might be waiting for work. 
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.CheckActive(Spring.Threading.ForkJoin.FJTaskRunner,System.Int64)">
            <summary> Set active status of thread t to false, and
            then wait until: (a) there is a task in the entry 
            queue, or (b) other threads are active, or (c) the current
            thread is interrupted. Upon return, it
            is not certain that there will be work available.
            The thread must itself check. 
            <p>
            The main underlying reason
            for these mechanics is that threads do not
            signal each other when they add elements to their queues.
            (This would add to task overhead, reduce locality.
            and increase contention.)
            So we must rely on a tamed form of polling. However, tasks
            inserted into the entry queue do result in signals, so
            tasks can wait on these if all of them are otherwise idle.
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.SignalNewTask">
            <summary> Start or wake up any threads waiting for work
            
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.InitializeThreads">
            <summary> Create all FJTaskRunner threads in this group.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunnerGroup.ScanPriorities">
            <summary> Set the priority to use while a FJTaskRunner is
            polling for new tasks to perform. Default
            is currently Thread.MIN_PRIORITY+1. The value
            set may not go into effect immediately, but
            will be used at least the next time a thread scans for work.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunnerGroup.RunPriorities">
            <summary> Set the priority to use while a FJTaskRunner is
            actively running tasks. Default
            is the priority that was in effect by the thread that
            constructed this FJTaskRunnerGroup. Setting this value
            while threads are running may momentarily result in
            them running at this priority even when idly waiting for work.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunnerGroup.ActiveCount">
            <summary> Return the number of threads that are not idly waiting for work.
            Beware that even active threads might not be doing any useful
            work, but just spinning waiting for other dependent tasks.
            Also, since this is just a snapshot value, some tasks
            may be in the process of becoming idle.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Array">
            <summary> Return the array of threads in this group. 
            Called only by FJTaskRunner.scan().
            
            </summary>
        </member>
        <member name="P:Spring.Threading.ForkJoin.FJTaskRunnerGroup.Inactive">
            <summary> Set active status of thread t to false.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.ForkJoin.FJTaskRunnerGroup.InvokableFJTask">
            <summary> 
            Wrap wait/notify mechanics around a task so that
            invoke() can wait it out 
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.InvokableFJTask.#ctor(Spring.Threading.IRunnable,Spring.Threading.ForkJoin.FJTaskRunnerGroup)">
            <summary>
            Creates a new <see cref="T:Spring.Threading.ForkJoin.FJTaskRunnerGroup.InvokableFJTask"/> instance.
            </summary>
        </member>
        <member name="M:Spring.Threading.ForkJoin.FJTaskRunnerGroup.InvokableFJTask.Run">
            <summary>
            <see cref="T:Spring.Threading.IRunnable"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.Future.TaskState">
            <summary>
            Enumeration representing a task execution status.
            </summary>
        </member>
        <member name="F:Spring.Threading.Future.TaskState.Ready">
            <summary>State value representing that task is ready to run </summary>
        </member>
        <member name="F:Spring.Threading.Future.TaskState.Running">
            <summary>State value representing that task is running </summary>
        </member>
        <member name="F:Spring.Threading.Future.TaskState.Complete">
            <summary>State value representing that task ran </summary>
        </member>
        <member name="F:Spring.Threading.Future.TaskState.Cancelled">
            <summary>State value representing that task was cancelled </summary>
        </member>
        <member name="F:Spring.Threading.Future.TaskState.Stop">
            <summary>State value representing that the task should be stopped.</summary>
        </member>
        <member name="T:Spring.Threading.Future.IDelayed">
            <summary> 
            A mix-in style interface for marking objects that should be
            acted upon after a given delay.
            </summary>
            <remarks> 
            <p/>
            An implementation of this interface must define a
            <see cref="M:System.IComparable.CompareTo(System.Object)"/> method that provides an ordering consistent with
            its <see cref="M:Spring.Threading.Future.IDelayed.GetRemainingDelay"/> method.
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <changes>
            <list type="number">
            <item>Changed GetDelay return type from long to TimeSpan, and remove parameter.</item>
            </list>
            </changes>
        </member>
        <member name="M:Spring.Threading.Future.IDelayed.GetRemainingDelay">
            <summary> 
            Returns the remaining delay associated with this object
            </summary>
            <returns>the remaining delay; zero or negative values indicate
            that the delay has already elapsed
            </returns>
        </member>
        <member name="T:Spring.Threading.Future.IRunnableScheduledFuture`1">
            <summary> 
            A <see cref="T:Spring.Threading.Future.IScheduledFuture`1"/> that is a <see cref="T:Spring.Threading.IRunnable"/>. 
            </summary>
            <remarks>
            Successful execution of the <see cref="M:Spring.Threading.IRunnable.Run"/> method causes 
            completion of the <see cref="T:Spring.Threading.Future.IFuture`1"/> and allows access to its results.
            </remarks>
            <seealso cref="T:Spring.Threading.Future.FutureTask`1"/>
            <seealso cref="T:Spring.Threading.IExecutor"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="T:Spring.Threading.Future.IScheduledFuture`1">
            <summary> 
            A delayed result-bearing action that can be cancelled.
            </summary>
            <remarks>
            Usually a scheduled future is the result of scheduling
            a task with a <see cref="T:Spring.Threading.Execution.IScheduledExecutorService"/>.
            </remarks>
            <author>Doug Lea</author>
            <author>Griffin Caprio(.NET)</author>
        </member>
        <member name="P:Spring.Threading.Future.IRunnableScheduledFuture`1.IsPeriodic">
            <summary>
            Returns <c>true</c> if this is a periodic task. 
            </summary>
            <remarks>
            A periodic task may re-run according to some schedule. A non-periodic task can be
            run only once.
            </remarks>
            <returns><c>true</c> if this task is periodic, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Spring.Threading.Heap">
            <summary> A heap-based priority queue, without any concurrency control
            (i.e., no blocking on empty/full states).
            This class provides the data structure mechanics for BoundedPriorityQueue.
            <p>
            The class currently uses a standard array-based heap, as described
            in, for example, Sedgewick's Algorithms text. All methods
            are fully synchronized. In the future,
            it may instead use structures permitting finer-grained locking.
            </p>
            </summary>
        </member>
        <member name="F:Spring.Threading.Heap.nodes_">
            <summary>
            the tree nodes, packed into an array
            </summary>
        </member>
        <member name="F:Spring.Threading.Heap.count_">
            <summary>
            number of used slots
            </summary>
        </member>
        <member name="F:Spring.Threading.Heap.cmp_">
            <summary>
            comparer for ordering
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.#ctor(System.Int32,System.Collections.IComparer)">
            <summary> Create a Heap with the given initial capacity and comparator</summary>
            <exception cref="T:System.ArgumentException"> if capacity less or equal to zero
            
            </exception>
        </member>
        <member name="M:Spring.Threading.Heap.#ctor(System.Int32)">
            <summary> Create a Heap with the given capacity,
            and relying on natural ordering.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.Compare(System.Object,System.Object)">
            <summary>perform element comaprisons using comparator or natural ordering *</summary>
        </member>
        <member name="M:Spring.Threading.Heap.Parent(System.Int32)">
            <summary>
            index of heap parent
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.Left(System.Int32)">
            <summary>
            index of left child 
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.Right(System.Int32)">
            <summary>
            index of right child 
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.Insert(System.Object)">
            <summary> insert an element, resize if necessary
            
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.Extract">
            <summary> Return and remove least element, or null if empty
            
            </summary>
        </member>
        <member name="M:Spring.Threading.Heap.Peek">
            <summary>Return least element without removing it, or null if empty *</summary>
        </member>
        <member name="M:Spring.Threading.Heap.Size">
            <summary>Return number of elements *</summary>
        </member>
        <member name="M:Spring.Threading.Heap.Clear">
            <summary>remove all elements *</summary>
        </member>
        <member name="T:Spring.Threading.Helpers.Exchanger">
            <summary> 
            A synchronization point at which two threads can exchange objects.
            Each thread presents some object on entry to the <see cref="M:Spring.Threading.Helpers.Exchanger.Exchange(System.Object)"/>
            method, and receives the object presented by the other
            thread on return.
            </summary>
            <author>Doug Lea</author>
            <author>Bill Scherer</author>
            <author>Michael Scott</author>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="F:Spring.Threading.Helpers.Exchanger._itemToBeExchanged">
            <summary>Holder for the item being exchanged </summary>
        </member>
        <member name="F:Spring.Threading.Helpers.Exchanger._arrivalCount">
            <summary> 
            Arrival count transitions from 0 to 1 to 2 then back to 0
            during an exchange.
            </summary>
        </member>
        <member name="M:Spring.Threading.Helpers.Exchanger.doExchange(System.Object,System.Boolean,System.TimeSpan)">
            <summary> Main exchange function, handling the different policy variants.</summary>
        </member>
        <member name="M:Spring.Threading.Helpers.Exchanger.Exchange(System.Object)">
            <summary> 
            Waits for another thread to arrive at this exchange point (unless
            <see cref="M:System.Threading.Thread.Interrupt"/> is called,
            and then transfers the given object to it, receiving its object
            in return.
            </summary>
            <remarks> 
            If another thread is already waiting at the exchange point then
            it is resumed for thread scheduling purposes and receives the object
            passed in by the current thread. The current thread returns immediately,
            receiving the object passed to the exchange by that other thread.
            
            <p/>
            If no other thread is already waiting at the exchange then the
            current thread is disabled for thread scheduling purposes and lies
            dormant until one of two things happens:
            <ul>
            <li>Some other thread enters the exchange</li>
            <li><see cref="M:System.Threading.Thread.Interrupt"/> is called on the current thread.</li>
            </ul>
            <p/>
            If <see cref="M:System.Threading.Thread.Interrupt"/> is called on the current thread,
            then a <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown
            </remarks>
            <param name="objectToExchange">the object to exchange</param>
            <returns> the object provided by the other thread.</returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread was interrupted</exception>
        </member>
        <member name="M:Spring.Threading.Helpers.Exchanger.Exchange(System.Object,System.TimeSpan)">
            <summary> 
            Waits for another thread to arrive at this exchange point (unless
            <see cref="M:System.Threading.Thread.Interrupt"/> is called, or the specified 
            <paramref name="duration"/> elapses, and then transfers the given object to it, receiving its object
            in return.
            </summary>
            <remarks> 
            If another thread is already waiting at the exchange point then
            it is resumed for thread scheduling purposes and receives the object
            passed in by the current thread. The current thread returns immediately,
            receiving the object passed to the exchange by that other thread.
            
            <p/>
            If no other thread is already waiting at the exchange then the
            current thread is disabled for thread scheduling purposes and lies
            dormant until one of two things happens:
            <ul>
            <li>Some other thread enters the exchange</li>
            <li><see cref="M:System.Threading.Thread.Interrupt"/> is called on the current thread.</li>
            </ul>
            <p/>
            If <see cref="M:System.Threading.Thread.Interrupt"/> is called on the current thread,
            then a <see cref="T:System.Threading.ThreadInterruptedException"/> is thrown
            </remarks>
            <param name="objectToExchange">the object to exchange</param>
            <param name="duration">Duration to wait for another thread to enter.</param>
            <returns> the object provided by the other thread.</returns>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the current thread was interrupted</exception>
        </member>
        <member name="T:Spring.Threading.Helpers.UncaughtExceptionHandlerDelegate">
            <summary> 
            Notification of the uncaught exception that occurred within specified
            thread.
            </summary>
            <param name="thread">the thread where the exception occurred</param>
            <param name="exception">the exception</param>
        </member>
        <member name="T:Spring.Threading.Helpers.ThreadExceptionHandlerHelpers">
            <summary>
            Helper class for providing unhandled exception handlers for <see cref="T:Spring.Threading.IRunnable"/> instances.
            </summary>
            <author>Griffin Caprio (.NET)</author>
        </member>
        <member name="M:Spring.Threading.Helpers.ThreadExceptionHandlerHelpers.AssignExceptionHandler(Spring.Threading.IRunnable,Spring.Threading.Helpers.UncaughtExceptionHandlerDelegate)">
            <summary> Returns wrapped runnable that ensures that if an exception occurs
            during the execution, the specified exception handler is invoked.
            </summary>
            <param name="runnable">runnable for which exceptions are to be intercepted
            </param>
            <param name="handler">the exception handler to call when exception occurs
            during execution of the given runnable
            </param>
            <returns> wrapped runnable
            </returns>
            <exception cref="T:System.ArgumentNullException">If either parameter is <c>null</c></exception>
        </member>
        <member name="T:Spring.Threading.Helpers.WaitNode">
            <summary>
            The wait node used by implementations of <see cref="T:Spring.Threading.Helpers.IWaitQueue"/>.
            NOTE: this class is NOT present in java.util.concurrent.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.IContextCarrierFactory">
            <summary>
            A context carrier factory creates instances of 
            <see cref="T:Spring.Threading.IContextCarrier"/>.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.IContextCarrierFactory.CreateContextCarrier">
            <summary>
            Create a new instance of <see cref="T:Spring.Threading.IContextCarrier"/>
            </summary>
            <returns>A new instance of <see cref="T:Spring.Threading.IContextCarrier"/>.</returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AbstractAtomicArray`1">
            <summary>
            Provide common implementation that making atomic arrays also
            <see cref="T:System.Collections.Generic.IList`1"/>s.
            </summary>
            <typeparam name="T">Type of the atomic array element.</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AbstractAtomicArray`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <remarks>
            Subclass must implement this method.
            </remarks>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate 
            through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AbstractAtomicArray`1.IsFixedSize">
            <summary>
            Called by implicit implementation of <see cref="P:System.Collections.IList.IsFixedSize"/>.
            All atomic arrays are fixed size so this always return <c>false</c>.
            </summary>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AbstractAtomicArray`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is 
            read-only.  All atomic arrays are designed to be updated so this 
            implementation always return <c>false</c>;
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            This implementation always return <c>false</c>;
            </returns>
            
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AbstractAtomicArray`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> 
            is synchronized (thread safe).
            </summary>
            <remarks>
            As all atomic arrays are thread safe, this implementaiton always return 
            <see langword="true"/>.
            </remarks>
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread 
            safe); otherwise, false. This implementaiton always return <c>true</c>.
            
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AbstractAtomicArray`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <remarks>
            All atomic array must implement this indexer.
            </remarks>
            <returns>
            The element at the specified index.
            </returns>
            <param name="index">
            The zero-based index of the element to get or set.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AbstractAtomicArray`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <remarks>
            All atomic array must implement this property.
            </remarks>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            
        </member>
        <member name="T:Spring.Threading.AtomicTypes.Atomic`1">
            <summary> 
            <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/> provide atomic access to an instance of type
            <typeparamref name="T"/> with the equality defined as value equals. 
            Always consider to use other type specific atomic whenever possible.
            </summary>
            <remarks>
            Based on the on the back port of JCP JSR-166.
            <p/>
            <b>Note:</b>This implementation boxes the value in an private
            reference type holder and uses <see cref="T:Spring.Threading.AtomicTypes.AtomicReference`1"/> to
            accomplish the atomic access.
            </remarks>
            <author>Doug Lea</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.IAtomic`1">
            <summary>
            Provide atomic access to an instance of <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the instance to be updated atomically.</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomic`1.LazySet(`0)">
            <summary> 
            Eventually sets to the given value.
            </summary>
            <param name="newValue">
            the new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomic`1.CompareAndSet(`0,`0)">
            <summary> 
            Atomically sets the value to the <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns> 
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomic`1.WeakCompareAndSet(`0,`0)">
            <summary> 
            Atomically sets the value to the <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            May fail spuriously.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns>
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomic`1.Exchange(`0)">
            <summary> 
            Atomically sets to the given value and returns the previous value.
            </summary>
            <param name="newValue">
            The new value for the instance.
            </param>
            <returns> 
            the previous value of the instance.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomic`1.ToString">
            <summary> 
            Returns the String representation of the current value.
            </summary>
            <returns> 
            The String representation of the current value.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.IAtomic`1.Value">
            <summary> 
            Gets and sets the current value.
            </summary>
        </member>
        <member name="F:Spring.Threading.AtomicTypes.Atomic`1._atomicReference">
            <summary>
            Holds the <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/> reference
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.#ctor(`0)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/> with the given
            initial values.
            </summary>
            <param name="initialValue">
            the initial value.
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.#ctor">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/> with <c>default<typeparamref name="T"/></c> 
            as initial value.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.LazySet(`0)">
            <summary> 
            Eventually sets to the given value.
            </summary>
            <param name="newValue">
            the new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.CompareAndSet(`0,`0)">
            <summary> 
            Atomically sets the value to the <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>
            determined by <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns> 
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.WeakCompareAndSet(`0,`0)">
            <summary> 
            Atomically sets the value to the <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>
            determined by <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.
            May fail spuriously.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns>
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.Exchange(`0)">
            <summary> 
            Atomically sets to the given value and returns the previous value.
            </summary>
            <param name="newValue">
            The new value for the instance.
            </param>
            <returns> 
            the previous value of the instance.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.ToString">
            <summary> 
            Returns the String representation of the current value.
            </summary>
            <returns> 
            The String representation of the current value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.Atomic`1.op_Implicit(Spring.Threading.AtomicTypes.Atomic{`0})~`0">
            <summary>
            Implicit converts <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/> to <typeparamref name="T"/>.
            </summary>
            <param name="atomic">
            Instance of <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/>.
            </param>
            <returns>
            The converted int value of <paramref name="atomic"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.Atomic`1.Holder">
            <summary>
            Returns the <see cref="T:Spring.Threading.AtomicTypes.ValueHolder`1"/> held but this instance.
            </summary>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.Atomic`1.Value">
            <summary> 
            Gets and sets the current value.
            </summary>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicArray`1">
            <summary> 
            An array of instances of type <typeparamref name="T"/> in which 
            elements may be updated atomically. Always consider to user other
            type specific atomic arraies whenever possible.
            </summary>
            <remarks>
            Based on the on the back port of JCP JSR-166.
            <p/>
            <b>Note:</b>This implementation boxes the value in an private
            reference type holder and uses <see cref="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1"/> to
            accomplish the atomic access.
            </remarks>
            <seealso cref="T:Spring.Threading.AtomicTypes.AtomicIntegerArray"/>
            <seealso cref="T:Spring.Threading.AtomicTypes.AtomicLongArray"/>
            <seealso cref="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1"/>
            <author>Doug Lea</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.IAtomicArray`1">
            <summary>
            Provide atomic access to an array of <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">
            The type of the array in which the elements are updated atomically.
            </typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomicArray`1.LazySet(System.Int32,`0)">
            <summary> 
            Eventually sets to the given value at the given <paramref name="index"/>
            </summary>
            <param name="newValue">
            the new value
            </param>
            <param name="index">
            the index to set
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomicArray`1.Exchange(System.Int32,`0)">
            <summary> 
            Atomically sets the element at position <paramref name="index"/> to <paramref name="newValue"/> 
            and returns the old value.
            </summary>
            <param name="index">
            Ihe index
            </param>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomicArray`1.CompareAndSet(System.Int32,`0,`0)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            true if successful. False return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.IAtomicArray`1.WeakCompareAndSet(System.Int32,`0,`0)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            May fail spuriously.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            True if successful, false otherwise.
            </returns>
        </member>
        <member name="F:Spring.Threading.AtomicTypes.AtomicArray`1._atomicReferenceArray">
            <summary>
            Holds the object array reference
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.#ctor(System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1"/> of <paramref name="length"/>.
            </summary>
            <param name="length">
            the length of the array
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.#ctor(`0[])">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1"/> with the same length as, and
            all elements copied from <paramref name="array"/>
            </summary>
            <param name="array">
            The array to copy elements from
            </param>
            <throws><see cref="T:System.ArgumentNullException"/>if array is null</throws>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.LazySet(System.Int32,`0)">
            <summary> 
            Eventually sets to the given value at the given <paramref name="index"/>
            </summary>
            <param name="newValue">
            the new value
            </param>
            <param name="index">
            the index to set
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.Exchange(System.Int32,`0)">
            <summary> 
            Atomically sets the element at position <paramref name="index"/> to <paramref name="newValue"/> 
            and returns the old value.
            </summary>
            <param name="index">
            Ihe index
            </param>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.CompareAndSet(System.Int32,`0,`0)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            true if successful. False return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.WeakCompareAndSet(System.Int32,`0,`0)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            May fail spuriously.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            True if successful, false otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicArray`1.ToString">
            <summary> 
            Returns the String representation of the current values of array.</summary>
            <returns> the String representation of the current values of array.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicArray`1.Count">
            <summary> 
            Returns the length of the array.
            </summary>
            <returns> 
            The length of the array
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicArray`1.Item(System.Int32)">
            <summary> 
            Indexer for getting and setting the current value at position <paramref name="index"/>.
            <p/>
            </summary>
            <param name="index">
            The index to use.
            </param>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicBoolean">
            <summary>
            A <see cref="T:System.Boolean"/> value that may be updated atomically. An <see cref="T:Spring.Threading.AtomicTypes.AtomicBoolean"/> 
            is used for instances of atomically updated flags, and cannot be used as a replacement for a <see cref="T:System.Boolean"/> value.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (Interlocked)</author>
        </member>
        <member name="F:Spring.Threading.AtomicTypes.AtomicBoolean._booleanValue">
            <summary>
            Holds a <see cref="T:System.Int32"/> representation of the flag value.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.#ctor(System.Boolean)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicBoolean"/> with the given initial value.
            </summary>
            <param name="initialValue">
            The initial value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.#ctor">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicBoolean"/> with initial value of <c>false</c>.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.CompareAndSet(System.Boolean,System.Boolean)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns> 
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.WeakCompareAndSet(System.Boolean,System.Boolean)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>
            May fail spuriously.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns>
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.LazySet(System.Boolean)">
            <summary> 
            Eventually sets to the given value.
            </summary>
            <param name="newValue">
            the new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.Exchange(System.Boolean)">
            <summary> 
            Atomically sets the current value to <parmref name="newValue"/> and returns the previous value.
            </summary>
            <param name="newValue">
            The new value for the instance.
            </param>
            <returns> 
            the previous value of the instance.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.ToString">
            <summary> 
            Returns the String representation of the current value.
            </summary>
            <returns> 
            The String representation of the current value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicBoolean.op_Implicit(Spring.Threading.AtomicTypes.AtomicBoolean)~System.Boolean">
            <summary>
            Implicit convert <see cref="T:Spring.Threading.AtomicTypes.AtomicBoolean"/> to bool.
            </summary>
            <param name="atomicBoolean">
            Instance of <see cref="T:Spring.Threading.AtomicTypes.AtomicBoolean"/>
            </param>
            <returns>
            The boolean value of <paramref name="atomicBoolean"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicBoolean.Value">
            <summary> 
            Gets and sets the current value.
            </summary>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicInteger">
            <summary> 
            An <see cref="T:System.Int32"/> value that may be updated atomically.
            An <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/> is used in applications such as atomically
            incremented counters, and cannot be used as a replacement for an
            <see cref="T:System.Int32"/>. 
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (Interlocked)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.#ctor(System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/> with a value of <paramref name="initialValue"/>.
            </summary>
            <param name="initialValue">
            The initial value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.#ctor">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/> with initial value 0.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.ReturnValueAndIncrement">
            <summary> 
            Atomically increments by one the current value.
            </summary>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.ReturnValueAndDecrement">
            <summary> 
            Atomically decrements by one the current value.
            </summary>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.LazySet(System.Int32)">
            <summary> 
            Eventually sets to the given value.
            </summary>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.Exchange(System.Int32)">
            <summary> 
            Atomically sets value to <paramref name="newValue"/> and returns the old value.
            </summary>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.CompareAndSet(System.Int32,System.Int32)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> <c>true</c> if successful. <c>false</c> return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.WeakCompareAndSet(System.Int32,System.Int32)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> <c>true</c> if successful. <c>false</c> return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.AddDeltaAndReturnPreviousValue(System.Int32)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the current value.
            </summary>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.AddDeltaAndReturnNewValue(System.Int32)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the current value.
            </summary>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.IncrementValueAndReturn">
            <summary> 
            Atomically increments the current value by one.
            </summary>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.DecrementValueAndReturn">
            <summary> 
            Atomically decrements by one the current value.
            </summary>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.ToString">
            <summary> 
            Returns the String representation of the current value.
            </summary>
            <returns> 
            The String representation of the current value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicInteger.op_Implicit(Spring.Threading.AtomicTypes.AtomicInteger)~System.Int32">
            <summary>
            Implicit converts <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/> to int.
            </summary>
            <param name="atomicInteger">
            Instance of <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/>.
            </param>
            <returns>
            The converted int value of <paramref name="atomicInteger"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicInteger.Value">
            <summary> 
            Gets and sets the current value.
            </summary>
            <returns>
            The current value
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicIntegerArray">
            <summary> A <see cref="T:System.Int32"/> array in which elements may be updated atomically.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring(.NET)</author>
            <author>Kenneth Xu (Interlock)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.#ctor(System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicIntegerArray"/> of given length.
            </summary>
            <param name="length">
            The length of the array
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.#ctor(System.Int32[])">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicIntegerArray"/> with the same length as, and
            all elements copied from <paramref name="array"/>.
            </summary>
            <param name="array">
            The array to copy elements from
            </param>
            <exception cref="T:System.ArgumentNullException"> if the array is null</exception>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.LazySet(System.Int32,System.Int32)">
            <summary> 
            Eventually sets the element at position index to the given value.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.Exchange(System.Int32,System.Int32)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            and returns the old value.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.CompareAndSet(System.Int32,System.Int32,System.Int32)">
            <summary>
            Atomically sets the value to <paramref name="newValue"/>
            if the value at <paramref name="index"/> == <paramref name="expectedValue"/>
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> true if successful. False return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.WeakCompareAndSet(System.Int32,System.Int32,System.Int32)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the value at <paramref name="index"/> == <paramref name="expectedValue"/>
            May fail spuriously.
            </summary>
            <param name="index">the index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            True if successful.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.ReturnValueAndIncrement(System.Int32)">
            <summary> 
            Atomically increments by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.ReturnValueAndDecrement(System.Int32)">
            <summary> 
            Atomically decrements by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.AddDeltaAndReturnPreviousValue(System.Int32,System.Int32)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.IncrementValueAndReturn(System.Int32)">
            <summary> 
            Atomically increments by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.DecrementValueAndReturn(System.Int32)">
            <summary> 
            Atomically decrements by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.AddDeltaAndReturnNewValue(System.Int32,System.Int32)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicIntegerArray.ToString">
            <summary> 
            Returns the String representation of the current values of array.
            </summary>
            <returns> 
            The String representation of the current values of array.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicIntegerArray.Count">
            <summary> 
            Returns the length of the array.
            </summary>
            <returns> 
            The length of the array
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicIntegerArray.Item(System.Int32)">
            <summary> 
            Gets / Sets the current value at position index.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The current value
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicLong">
            <summary> A <see cref="T:System.Int64"/> value that may be updated atomically.  See the
            An <see cref="T:Spring.Threading.AtomicTypes.AtomicLong"/> is used in applications such as atomically
            incremented sequence numbers, and cannot be used as a replacement
            for a <see cref="T:System.Int64"/>. 
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.#ctor(System.Int64)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicLong"/> with the given initial value.
            </summary>
            <param name="initialValue">
            The initial value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.#ctor">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicLong"/> with initial value 0.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.ReturnValueAndIncrement">
            <summary> 
            Atomically increments by one the current value.
            </summary>
            <returns> the previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.ReturnValueAndDecrement">
            <summary> 
            Atomically decrements by one the current value.
            </summary>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.LazySet(System.Int64)">
            <summary> 
            Eventually sets to the given value.
            </summary>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.Exchange(System.Int64)">
            <summary> 
            Atomically sets value to <paramref name="newValue"/> and returns the old value.
            </summary>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.CompareAndSet(System.Int64,System.Int64)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> true if successful. False return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.WeakCompareAndSet(System.Int64,System.Int64)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>.
            May fail spuriously.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            True if successful.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.AddDeltaAndReturnPreviousValue(System.Int64)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the current value.
            </summary>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.IncrementValueAndReturn">
            <summary> 
            Atomically increments by one the current value.
            </summary>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.DecrementValueAndReturn">
            <summary> 
            Atomically decrements by one the current value.
            </summary>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.AddDeltaAndReturnNewValue(System.Int64)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the current value.
            </summary>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.ToString">
            <summary> 
            Returns the String representation of the current value.
            </summary>
            <returns> 
            The String representation of the current value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLong.op_Implicit(Spring.Threading.AtomicTypes.AtomicLong)~System.Int64">
            <summary>
            Implicit converts <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/> to int.
            </summary>
            <param name="atomicLong">
            Instance of <see cref="T:Spring.Threading.AtomicTypes.AtomicInteger"/>.
            </param>
            <returns>
            The converted int value of <paramref name="atomicLong"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicLong.Value">
            <summary> 
            Gets / Sets the current value.
            </summary>
            <returns> 
            The current value
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicLongArray">
            <summary> 
            A long array in which elements may be updated atomically.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.#ctor(System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicLongArray"/> of given <paramref name="length"/>.
            </summary>
            <param name="length">
            The length of the array
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.#ctor(System.Int64[])">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicLongArray"/> with the same length as, and
            all elements copied from, <paramref name="array"/>.
            </summary>
            <param name="array">
            The array to copy elements from
            </param>
            <exception cref="T:System.ArgumentNullException"> if the array is null</exception>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.LazySet(System.Int32,System.Int64)">
            <summary> 
            Eventually sets the element at position <paramref name="index"/> to the given <paramref name="newValue"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.Exchange(System.Int32,System.Int64)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to the <paramref name="newValue"/>
            and returns the old value.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.CompareAndSet(System.Int32,System.Int64,System.Int64)">
            <summary>
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> true if successful. False return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.WeakCompareAndSet(System.Int32,System.Int64,System.Int64)">
            <summary> 
            Atomically sets the value to <paramref name="newValue"/>
            if the current value == <paramref name="expectedValue"/>
            May fail spuriously.
            </summary>
            <param name="index">the index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            True if successful.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.ReturnValueAndIncrement(System.Int32)">
            <summary> 
            Atomically increments by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.ReturnValueAndDecrement(System.Int32)">
            <summary> 
            Atomically decrements by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.AddDeltaAndReturnPreviousValue(System.Int32,System.Int64)">
            <summary> 
            Atomically adds the given value to the element at <paramref name="index"/>. 
            </summary>
            <param name="index">
            The index
            </param>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The previous value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.IncrementValueAndReturn(System.Int32)">
            <summary> 
            Atomically increments by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.DecrementValueAndReturn(System.Int32)">
            <summary> 
            Atomically decrements by one the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.AddDeltaAndReturnNewValue(System.Int32,System.Int64)">
            <summary> 
            Atomically adds <paramref name="deltaValue"/> to the element at <paramref name="index"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="deltaValue">
            The value to add
            </param>
            <returns> 
            The updated value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicLongArray.ToString">
            <summary> 
            Returns the String representation of the current values of array.
            </summary>
            <returns> 
            The String representation of the current values of array.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicLongArray.Count">
            <summary> 
            Returns the length of the array.
            </summary>
            <returns> 
            The length of the array
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicLongArray.Item(System.Int32)">
            <summary> 
            Gets / Sets the current value at position index.
            </summary>
            <param name="index">
            The index
            </param>
            <returns> 
            The current value
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicMarkable`1">
            <summary> 
            An <see cref="T:Spring.Threading.AtomicTypes.AtomicMarkable`1"/> maintains an instance of type
            <typeparamref name="T"/> along with a mark bit, that can be updated 
            atomically.
            <p/>
            <b>Note:</b>This implementation maintains markable
            value by creating internal objects representing "boxed"
            [value, boolean] pairs.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="F:Spring.Threading.AtomicTypes.AtomicMarkable`1._atomicReference">
            <summary>
            Holds the <see cref="T:Spring.Threading.AtomicTypes.AtomicReference`1"/> reference
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.#ctor(`0,System.Boolean)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicMarkable`1"/> with the given
            initial values.
            </summary>
            <param name="initialValue">
            the initial value
            </param>
            <param name="initialMark">
            the initial mark
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.GetValue(System.Boolean@)">
            <summary> 
            Returns both the current value and the current mark.
            Typical usage is:
            <code>
            bool isMarked;
            var reference = v.GetValue(out isMarked);
            </code>
            </summary>
            <param name="isMarked">
            return the value of the mark.
            </param>
            <returns> 
            The current value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.WeakCompareAndSet(`0,`0,System.Boolean,System.Boolean)">
            <summary> 
            Atomically sets both the value and mark to the given update values if the
            current value and <paramref name="expectedValue"/> <see cref="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.AreEqual(`0,`0)"/>
            and the current mark is equal to the <paramref name="expectedMark"/>.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <param name="expectedMark">
            The expected value of the mark
            </param>
            <param name="newMark">
            The new value for the mark
            </param>
            <returns> 
            <c>true</c> if successful, <c>false</c> otherwise
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.CompareAndSet(`0,`0,System.Boolean,System.Boolean)">
            <summary> 
            Atomically sets both the value and mark to the given update values if the
            current value and <paramref name="expectedValue"/> <see cref="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.AreEqual(`0,`0)"/>
            and the current mark is equal to the <paramref name="expectedMark"/>.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <param name="expectedMark">
            The expected value of the mark
            </param>
            <param name="newMark">
            The new value for the mark
            </param>
            <returns> 
            <c>true</c> if successful, <c>false</c> otherwise
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.SetNewAtomicValue(`0,System.Boolean)">
            <summary> 
            Unconditionally sets both the value and mark if any of them are
            not equal. Method <see cref="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.AreEqual(`0,`0)"/> is used to compare the 
            value.
            </summary>
            <param name="newValue">the new value
            </param>
            <param name="newMark">the new value for the mark
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.AttemptMark(`0,System.Boolean)">
            <summary> 
            Atomically sets the value of the mark to the given update value
            if the current value and the expected value <see cref="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.AreEqual(`0,`0)"/>.  
            Any given invocation of this operation may fail
            (return false) spuriously, but repeated invocation
            when the current value holds the expected value and no other
            thread is also attempting to set the value will eventually
            succeed.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newMark">
            The new value for the mark
            </param>
            <returns> 
            <c>true</c> if successful, <c>false</c> otherwise
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkable`1.AreEqual(`0,`0)">
            <summary>
            Determine if two instances are equals. This implementation uses
            <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to determine the equality.
            </summary>
            <param name="x">first instance to compare.</param>
            <param name="y">second instance to compare</param>
            <returns>
            <c>true</c> when and only when <paramref name="x"/> equals 
            <paramref name="y"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicMarkable`1.Pair">
            <summary>
            Returns the <see cref="T:Spring.Threading.AtomicTypes.AtomicMarkable`1.ValueBooleanPair"/> held but this instance.
            </summary>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicMarkable`1.Value">
            <summary> 
            Returns the current value.
            </summary>
            <returns> 
            The current value
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicMarkable`1.IsMarked">
            <summary> 
            Returns the current value of the mark.
            </summary>
            <returns> 
            The current value of the mark
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicMarkableReference`1">
            <summary> 
            An <see cref="T:Spring.Threading.AtomicTypes.AtomicMarkableReference`1"/> maintains an object reference
            along with a mark bit, that can be updated atomically.
            <p/>
            <b>Note:</b>This implementation maintains markable
            references by creating internal objects representing "boxed"
            [reference, boolean] pairs.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkableReference`1.#ctor(`0,System.Boolean)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicMarkable`1"/> with the given
            initial values.
            </summary>
            <param name="initialReference">
            the initial value of the reference
            </param>
            <param name="initialMark">
            the initial mark
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicMarkableReference`1.AreEqual(`0,`0)">
            <summary>
            Determine if two instances are equals. This implementation uses
            <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> to determine 
            the equality.
            </summary>
            <param name="x">first instance to compare.</param>
            <param name="y">second instance to compare</param>
            <returns>
            <c>true</c> when and only when <paramref name="x"/> equals 
            <paramref name="y"/>.
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicReference`1">
            <summary>
            A object reference that may be updated atomically with the equality
            defined as reference equals.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (Interlocked)</author>
        </member>
        <member name="F:Spring.Threading.AtomicTypes.AtomicReference`1._reference">
            <summary>
            Holds the object reference.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.#ctor(`0)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicReference`1"/> with the given initial value.
            </summary>
            <param name="initialValue">
            The initial value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.#ctor">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.Atomic`1"/> with <c>default<typeparamref name="T"/></c> 
            as initial value.
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.LazySet(`0)">
            <summary> 
            Eventually sets to the given value.
            </summary>
            <param name="newValue">
            the new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.CompareAndSet(`0,`0)">
            <summary> 
            Atomically sets the value to the <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns> 
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.WeakCompareAndSet(`0,`0)">
            <summary> 
            Atomically sets the value to the <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            May fail spuriously.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value to use of the current value equals the expected value.
            </param>
            <returns>
            <c>true</c> if the current value equaled the expected value, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.Exchange(`0)">
            <summary> 
            Atomically sets to the given value and returns the previous value.
            </summary>
            <param name="newValue">
            The new value for the instance.
            </param>
            <returns> 
            the previous value of the instance.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.ToString">
            <summary> 
            Returns the String representation of the current value.
            </summary>
            <returns> 
            The String representation of the current value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReference`1.op_Implicit(Spring.Threading.AtomicTypes.AtomicReference{`0})~`0">
            <summary>
            Implicit converts <see cref="T:Spring.Threading.AtomicTypes.AtomicReference`1"/> to <typeparamref name="T"/>.
            </summary>
            <param name="atomicReference">
            Instance of <see cref="T:Spring.Threading.AtomicTypes.AtomicReference`1"/>.
            </param>
            <returns>
            The converted int value of <paramref name="atomicReference"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicReference`1.Value">
            <summary> 
            Gets and sets the current value.
            </summary>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1">
            <summary> 
            An array of object references in which elements may be updated
            atomically. 
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (Interlocked)</author>
        </member>
        <member name="F:Spring.Threading.AtomicTypes.AtomicReferenceArray`1._referenceArray">
            <summary>
            Holds the object array reference
            </summary>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.#ctor(System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1"/> of <paramref name="length"/>.
            </summary>
            <param name="length">
            the length of the array
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.#ctor(`0[])">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicReferenceArray`1"/> with the same length as, and
            all elements copied from <paramref name="array"/>
            </summary>
            <param name="array">
            The array to copy elements from
            </param>
            <throws><see cref="T:System.ArgumentNullException"/>if array is null</throws>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.LazySet(System.Int32,`0)">
            <summary> 
            Eventually sets to the given value at the given <paramref name="index"/>
            </summary>
            <param name="newValue">
            the new value
            </param>
            <param name="index">
            the index to set
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.Exchange(System.Int32,`0)">
            <summary> 
            Atomically sets the element at position <paramref name="index"/> to <paramref name="newValue"/> 
            and returns the old value.
            </summary>
            <param name="index">
            Ihe index
            </param>
            <param name="newValue">
            The new value
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.CompareAndSet(System.Int32,`0,`0)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            true if successful. False return indicates that
            the actual value was not equal to the expected value.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.WeakCompareAndSet(System.Int32,`0,`0)">
            <summary> 
            Atomically sets the element at <paramref name="index"/> to <paramref name="newValue"/>
            if the current value equals the <paramref name="expectedValue"/>.
            May fail spuriously.
            </summary>
            <param name="index">
            The index
            </param>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <returns> 
            True if successful, false otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.ToString">
            <summary> 
            Returns the String representation of the current values of array.</summary>
            <returns> the String representation of the current values of array.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.Count">
            <summary> 
            Returns the length of the array.
            </summary>
            <returns> 
            The length of the array
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicReferenceArray`1.Item(System.Int32)">
            <summary> 
            Indexer for getting and setting the current value at position <paramref name="index"/>.
            <p/>
            </summary>
            <param name="index">
            The index to use.
            </param>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicStamped`1">
            <summary>
            An <see cref="T:Spring.Threading.AtomicTypes.AtomicStamped`1"/> maintains an instance of type
            <typeparamref name="T"/> along with an integer "stamp", that can 
            be updated atomically.
            
            <p/>
            <b>Note:</b>This implementation maintains stamped
            value by creating internal objects representing "boxed"
            [value, integer] pairs.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.#ctor(`0,System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicStamped`1"/> with the given
            initial values.
            </summary>
            <param name="initialValue">
            The initial value
            </param>
            <param name="initialStamp">
            The initial stamp
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.GetValue(System.Int32@)">
            <summary> 
            Returns both the current value and the stamp.
            Typical usage is:
            <code>
            int stamp;
            object value = v.GetValue(out stamp);
            </code> 
            </summary>
            <param name="stamp">
            An array of size of at least one.  On return,
            <tt>stampholder[0]</tt> will hold the value of the stamp.
            </param>
            <returns> 
            The current value
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.WeakCompareAndSet(`0,`0,System.Int32,System.Int32)">
            <summary> 
            Atomically sets both the value and stamp to the given update values 
            if the current value and the expected value <see cref="M:Spring.Threading.AtomicTypes.AtomicStamped`1.AreEqual(`0,`0)"/>
            and the current stamp is equal to the expected stamp.  Any given
            invocation of this operation may fail (return
            false) spuriously, but repeated invocation when
            the current value holds the expected value and no other thread
            is also attempting to set the value will eventually succeed.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <param name="expectedStamp">
            The expected value of the stamp
            </param>
            <param name="newStamp">
            The new value for the stamp
            </param>
            <returns> 
            True if successful
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.CompareAndSet(`0,`0,System.Int32,System.Int32)">
            <summary> 
            Atomically sets both the value and stamp to the given update values 
            if the current value and the expected value <see cref="M:Spring.Threading.AtomicTypes.AtomicStamped`1.AreEqual(`0,`0)"/>
            and the current stamp is equal to the expected stamp.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newValue">
            The new value
            </param>
            <param name="expectedStamp">
            The expected value of the stamp
            </param>
            <param name="newStamp">
            The new value for the stamp
            </param>
            <returns> 
            True if successful, false otherwise.
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.SetNewAtomicValue(`0,System.Int32)">
            <summary> 
            Unconditionally sets both the value and stamp if any of them are
            not equal. Method <see cref="M:Spring.Threading.AtomicTypes.AtomicStamped`1.AreEqual(`0,`0)"/> is used to compare the 
            value.
            </summary>
            <param name="newValue">
            The new value
            </param>
            <param name="newStamp">
            The new value for the stamp
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.AttemptStamp(`0,System.Int32)">
            <summary> 
            Atomically sets the value of the stamp to the given update value
            if the current value and the expected value <see cref="M:Spring.Threading.AtomicTypes.AtomicStamped`1.AreEqual(`0,`0)"/>.
            Any given invocation of this operation may fail
            (return false) spuriously, but repeated invocation
            when the current value holds the expected value and no other
            thread is also attempting to set the value will eventually
            succeed.
            </summary>
            <param name="expectedValue">
            The expected value
            </param>
            <param name="newStamp">
            The new value for the stamp
            </param>
            <returns> 
            True if successful
            </returns>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStamped`1.AreEqual(`0,`0)">
            <summary>
            Determine if two instances are equals. This implementation uses
            <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to determine the equality.
            </summary>
            <param name="x">first instance to compare.</param>
            <param name="y">second instance to compare</param>
            <returns>
            <c>true</c> when and only when <paramref name="x"/> equals 
            <paramref name="y"/>.
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicStamped`1.Value">
            <summary> 
            Returns the current value.
            </summary>
            <returns> 
            The current value
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicStamped`1.Stamp">
            <summary> 
            Returns the current value of the stamp.
            </summary>
            <returns> 
            The current value of the stamp
            </returns>
        </member>
        <member name="P:Spring.Threading.AtomicTypes.AtomicStamped`1.Pair">
            <summary>
            Gets the <see cref="T:Spring.Threading.AtomicTypes.AtomicStamped`1.ValueIntegerPair"/> represented by this instance.
            </summary>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.AtomicStampedReference`1">
            <summary>
            An <see cref="T:Spring.Threading.AtomicTypes.AtomicStampedReference`1"/> maintains an object reference
            along with an integer "stamp", that can be updated atomically. 
            
            <p/>
            <b>Note:</b>This implementation maintains stamped
            references by creating internal objects representing "boxed"
            [reference, integer] pairs.
            <p/>
            Based on the on the back port of JCP JSR-166.
            </summary>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Andreas Doehring (.NET)</author>
            <author>Kenneth Xu (.NET)</author>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStampedReference`1.#ctor(`0,System.Int32)">
            <summary> 
            Creates a new <see cref="T:Spring.Threading.AtomicTypes.AtomicStampedReference`1"/> with the given
            initial values.
            </summary>
            <param name="initialReference">
            The initial reference
            </param>
            <param name="initialStamp">
            The initial stamp
            </param>
        </member>
        <member name="M:Spring.Threading.AtomicTypes.AtomicStampedReference`1.AreEqual(`0,`0)">
            <summary>
            Determine if two instances are equals. This implementation uses
            <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to determine the equality.
            </summary>
            <param name="x">first instance to compare.</param>
            <param name="y">second instance to compare</param>
            <returns>
            <c>true</c> when and only when <paramref name="x"/> equals 
            <paramref name="y"/>.
            </returns>
        </member>
        <member name="T:Spring.Threading.AtomicTypes.ValueHolder`1">
            <summary>
            Used to hold a value type in a reference type.
            </summary>
            <typeparam name="T">The type of the value to hold.</typeparam>
            <author>Kenneth Xu</author>
        </member>
        <member name="T:Spring.Threading.LayeredSync">
            <summary> A class that can be used to compose Syncs.
            A LayeredSync object manages two other Sync objects,
            <em>outer</em> and <em>inner</em>. The acquire operation
            invokes <em>outer</em>.acquire() followed by <em>inner</em>.acquire(),
            but backing out of outer (via release) upon an exception in inner.
            The other methods work similarly.
            <p>
            LayeredSyncs can be used to compose arbitrary chains
            by arranging that either of the managed Syncs be another
            LayeredSync.
            </p>
            </summary>
        </member>
        <member name="F:Spring.Threading.LayeredSync.outer_">
            <summary>
            The outer sync
            </summary>
        </member>
        <member name="F:Spring.Threading.LayeredSync.inner_">
            <summary>
            the inner sync
            </summary>
        </member>
        <member name="M:Spring.Threading.LayeredSync.#ctor(Spring.Threading.ISync,Spring.Threading.ISync)">
            <summary> Create a LayeredSync managing the given outer and inner Sync
            objects
            </summary>		
        </member>
        <member name="M:Spring.Threading.LayeredSync.Acquire">
            <summary>
            Invokes <c>outer_.Acquire</c> followed by <c>inner_.Acquire</c>,
            but backing out of outer (via <c>outer_.Release</c>) upon an 
            exception in <c>inner_.Acquire</c>.
            </summary>
        </member>
        <member name="M:Spring.Threading.LayeredSync.Attempt(System.Int64)">
            <summary>
            Attempt to get outer and then inner sync.
            Release outer, if gor, on interruption while
            attempting inner 
            </summary>
        </member>
        <member name="M:Spring.Threading.LayeredSync.Release">
            <summary>
            Relese outer and inner
            </summary>
        </member>
        <member name="T:Spring.Threading.LinkedNode">
            <summary>A standard linked list node used in various queue classes</summary>
        </member>
        <member name="F:Spring.Threading.LinkedNode.Value">
            <summary>
            The object paired to this node
            </summary>
        </member>
        <member name="F:Spring.Threading.LinkedNode.Next">
            <summary>
            The next linked node
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedNode.#ctor">
            <summary>
            Creates a node, with no <see cref="F:Spring.Threading.LinkedNode.Value"/> and no <see cref="F:Spring.Threading.LinkedNode.Next"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedNode.#ctor(System.Object)">
            <summary>
            Creates a node
            </summary>
            <param name="x">the object paired to this node</param>
        </member>
        <member name="M:Spring.Threading.LinkedNode.#ctor(System.Object,Spring.Threading.LinkedNode)">
            <summary>
            Creates a node
            </summary>
            <param name="x">the object paired to this node</param>
            <param name="n">a node to link to</param>
        </member>
        <member name="T:Spring.Threading.LinkedQueue">
            <summary> A linked list based channel implementation.
            The algorithm avoids contention between puts
            and takes when the queue is not empty. 
            Normally a put and a take can proceed simultaneously. 
            (Although it does not allow multiple concurrent puts or takes.)
            This class tends to perform more efficently than
            other <see cref="T:Spring.Threading.IChannel"/> implementations in producer/consumer
            applications.
            </summary>
        </member>
        <member name="F:Spring.Threading.LinkedQueue.head_">
            <summary> Dummy header node of list. The first actual node, if it exists, is always 
            at head_.Next. After each take, the old first node becomes the head.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.LinkedQueue.putLock_">
            <summary> Helper monitor for managing access to last node.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.LinkedQueue.last_">
            <summary> The last node of list. Put() appends to list, so modifies last_
            
            </summary>
        </member>
        <member name="F:Spring.Threading.LinkedQueue.waitingForTake_">
            <summary> The number of threads waiting for a take.
            Notifications are provided in put only if greater than zero.
            The bookkeeping is worth it here since in reasonably balanced
            usages, the notifications will hardly ever be necessary, so
            the call overhead to notify can be eliminated.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.#ctor">
            <summary>
            creates a new queue with a node not paired to any object
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.insert(System.Object)">
            <summary>Main mechanics for put/offer *</summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.Extract">
            <summary>Main mechanics for take/poll *</summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.Put(System.Object)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.Offer(System.Object,System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.Take">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Take"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.Peek">
            <summary>
            <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.LinkedQueue.Poll(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Poll(System.Int64)"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.LinkedQueue.IsEmpty">
            <summary>
            Utility method to avoid to call <see cref="M:Spring.Threading.LinkedQueue.Peek"/>
            </summary>
            <returns><code>true</code> if there are no items in the queue</returns>
        </member>
        <member name="T:Spring.Threading.LockedExecutor">
            <summary> An implementation of Executor that 
            invokes the run method of the supplied command within
            a synchronization lock and then returns.
            </summary>
        </member>
        <member name="F:Spring.Threading.LockedExecutor.mutex_">
            <summary>The mutex *</summary>
        </member>
        <member name="M:Spring.Threading.LockedExecutor.#ctor(Spring.Threading.ISync)">
            <summary> Create a new LockedExecutor that relies on the given mutual
            exclusion lock. 
            </summary>
            <param name="mutex">Any mutual exclusion lock.
            Standard usage is to supply an instance of <code>Mutex</code>,
            but, for example, a Semaphore initialized to 1 also works.
            On the other hand, many other ISync implementations would not
            work here, so some care is required to supply a sensible 
            synchronization object.
            
            </param>
        </member>
        <member name="M:Spring.Threading.LockedExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> Execute the given command directly in the current thread,
            within the supplied lock.
            </summary>
        </member>
        <member name="M:Spring.Threading.LockedExecutor.Execute(System.Action)">
            <summary>
            Execute the given task directly in the current thread,
            within the supplied lock.
            </summary>
            <param name="action">The task to be executed.</param>
        </member>
        <member name="T:Spring.Threading.Locks.FIFOConditionVariable">
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.Locks.FIFOConditionVariable.#ctor(Spring.Threading.Locks.ConditionVariable.IExclusiveLock)">
            <summary>
            Create a new <see cref="T:Spring.Threading.Locks.FIFOConditionVariable"/> that relies on the
            given mutual exclusion lock.
            </summary>
            <param name="lock">A non-reentrant mutual exclusion lock.</param>
        </member>
        <member name="T:Spring.Threading.Locks.IReadWriteLock">
            <summary> 
            A <see cref="T:Spring.Threading.Locks.IReadWriteLock"/> maintains a pair of associated
            <see cref="T:Spring.Threading.Locks.ILock"/> instances, one for read-only operations and one 
            for writing. The <see cref="P:Spring.Threading.Locks.IReadWriteLock.ReaderLock"/> may be held simultaneously 
            by multiple reader threads, so long as there are no writers.  The
            <see cref="P:Spring.Threading.Locks.IReadWriteLock.WriterLock"/> is exclusive.
            </summary>
            <remarks>
            <para>
            All <see cref="T:Spring.Threading.Locks.IReadWriteLock"/> implementations must guarantee that
            the memory synchronization effects of <see cref="P:Spring.Threading.Locks.IReadWriteLock.WriterLock"/> operations
            (as specified in the <see cref="T:Spring.Threading.Locks.ILock"/> interface) also hold with respect
            to the associated <see cref="P:Spring.Threading.Locks.IReadWriteLock.ReaderLock"/>. That is, a thread successfully
            acquiring the read lock will see all updates made upon previous
            release of the write lock.
            </para>
            <para>
            A read-write lock allows for a greater level of concurrency in
            accessing shared data than that permitted by a mutual exclusion lock.
            It exploits the fact that while only a single thread at a time (a
            <b>writer</b> thread) can modify the shared data, in many cases any
            number of threads can concurrently read the data (hence <b>reader</b>
            threads).
            In theory, the increase in concurrency permitted by the use of a read-write
            lock will lead to performance improvements over the use of a mutual
            exclusion lock. In practice this increase in concurrency will only be fully
            realized on a multi-processor, and then only if the access patterns for
            the shared data are suitable.
            </para>
            <para>
            Whether or not a read-write lock will improve performance over the use
            of a mutual exclusion lock depends on the frequency that the data is
            read compared to being modified, the duration of the read and write
            operations, and the contention for the data - that is, the number of
            threads that will try to read or write the data at the same time.
            For example, a collection that is initially populated with data and
            thereafter infrequently modified, while being frequently searched
            (such as a directory of some kind) is an ideal candidate for the use of
            a read-write lock. However, if updates become frequent then the data
            spends most of its time being exclusively locked and there is little, if any
            increase in concurrency. Further, if the read operations are too short
            the overhead of the read-write lock implementation (which is inherently
            more complex than a mutual exclusion lock) can dominate the execution
            cost, particularly as many read-write lock implementations still serialize
            all threads through a small section of code. Ultimately, only profiling
            and measurement will establish whether the use of a read-write lock is
            suitable for your application.
            </para>
            <para>
            Although the basic operation of a read-write lock is straight-forward,
            there are many policy decisions that an implementation must make, which
            may affect the effectiveness of the read-write lock in a given application.
            Examples of these policies include:
            <list type="bullet">
            <item>
            Determining whether to grant the read lock or the write lock, when
            both readers and writers are waiting, at the time that a writer releases
            the write lock. Writer preference is common, as writes are expected to be
            short and infrequent. Reader preference is less common as it can lead to
            lengthy delays for a write if the readers are frequent and long-lived as
            expected. Fair, or 'in-order' implementations are also possible.
            </item> 
            <item>
            Determining whether readers that request the read lock while a
            reader is active and a writer is waiting, are granted the read lock.
            Preference to the reader can delay the writer indefinitely, while
            preference to the writer can reduce the potential for concurrency.
            </item> 
            <item>
            Determining whether the locks are reentrant: can a thread with the
            write lock reacquire it? Can it acquire a read lock while holding the
            write lock? Is the read lock itself reentrant?
            </item> 
            <item>
            Can the write lock be downgraded to a read lock without allowing
            an intervening writer? Can a read lock be upgraded to a write lock,
            in preference to other waiting readers or writers?
            </item>
            </list>
            You should consider all of these things when evaluating the suitability
            of a given implementation for your application.
            </para>
            </remarks>
            <seealso cref="T:Spring.Threading.Locks.ILock"/>
            <seealso cref="T:Spring.Threading.Locks.ReentrantLock"/>
            <author>Doug Lea</author>
            <author>Griffin Caprio (.NET)</author>
            <author>Kenneth Xu</author>
        </member>
        <member name="P:Spring.Threading.Locks.IReadWriteLock.ReaderLock">
            <summary> 
            Returns the lock used for reading.
            </summary>
            <returns>
            The lock used for reading.
            </returns>
        </member>
        <member name="P:Spring.Threading.Locks.IReadWriteLock.WriterLock">
            <summary>
            Returns the lock used for writing.
            </summary>
            <returns>
            The lock used for writing.
            </returns>
        </member>
        <member name="T:Spring.Threading.LogicalThreadContextCarrierFactory">
            <summary>
            A factory that creates instance of <see cref="T:Spring.Threading.IContextCarrier"/> that
            copies specified data slots in the "Spring.Threading.LogicalThreadContext, Spring.Core"
            and <see cref="P:System.Threading.Thread.CurrentPrincipal"/>.
            </summary>
            <author>Kenneth Xu</author>
        </member>
        <member name="M:Spring.Threading.LogicalThreadContextCarrierFactory.CreateContextCarrier">
            <summary>
            Create a new instance of <see cref="T:Spring.Threading.IContextCarrier"/>
            </summary>
            <returns>A new instance of <see cref="T:Spring.Threading.IContextCarrier"/>.</returns>
        </member>
        <member name="P:Spring.Threading.LogicalThreadContextCarrierFactory.Names">
            <summary>
            Gets and sets the names of the data slots to be copied.
            </summary>
        </member>
        <member name="T:Spring.Threading.Mutex">
            <summary> A simple non-reentrant mutual exclusion lock.
            The lock is free upon construction. Each acquire gets the
            lock, and each release frees it. Releasing a lock that
            is already free has no effect. 
            <p>
            This implementation makes no attempt to provide any fairness
            or ordering guarantees. If you need them, consider using one of
            the Semaphore implementations as a locking mechanism.
            </p>
            <p>
            <b>Sample usage</b>
            </p>
            <p>
            Mutex can be useful in constructions that cannot be
            expressed using java synchronized blocks because the
            acquire/release pairs do not occur in the same method or
            code block. For example, you can use them for hand-over-hand
            locking across the nodes of a linked list. This allows
            extremely fine-grained locking,  and so increases 
            potential concurrency, at the cost of additional complexity and
            overhead that would normally make this worthwhile only in cases of
            extreme contention.
            <pre>
            class Node { 
            Object item; 
            Node next; 
            Mutex lock = new Mutex(); // each node keeps its own lock
            
            Node(Object x, Node n) { item = x; next = n; }
            }
            
            class List {
            protected Node head; // pointer to first node of list
            
            // Use plain java synchronization to protect head field.
            //  (We could instead use a Mutex here too but there is no
            //  reason to do so.)
            protected synchronized Node getHead() { return head; }
            
            boolean search(Object x) throws InterruptedException {
            Node p = getHead();
            if (p == null) return false;
            
            //  (This could be made more compact, but for clarity of illustration,
            //  all of the cases that can arise are handled separately.)
            
            p.lock.acquire();              // Prime loop by acquiring first lock.
            //    (If the acquire fails due to
            //    interrupt, the method will throw
            //    InterruptedException now,
            //    so there is no need for any
            //    further cleanup.)
            for (;;) {
            if (x.equals(p.item)) {
            p.lock.release();          // release current before return
            return true;
            }
            else {
            Node nextp = p.next;
            if (nextp == null) {
            p.lock.release();       // release final lock that was held
            return false;
            }
            else {
            try {
            nextp.lock.acquire(); // get next lock before releasing current
            }
            catch (InterruptedException ex) {
            p.lock.release();    // also release current if acquire fails
            throw ex;
            }
            p.lock.release();      // release old lock now that new one held
            p = nextp;
            }
            }
            }
            }
            
            synchronized void add(Object x) { // simple prepend
            // The use of `synchronized'  here protects only head field.
            // The method does not need to wait out other traversers 
            // who have already made it past head.
            
            head = new Node(x, head);
            }
            
            // ...  other similar traversal and update methods ...
            }
            </pre>
            </p>
            </summary>
            <remarks>There already exists a <see cref="T:System.Threading.Mutex"/>, 
            and you probably want to use that; note however that this class can be used as an
            <see cref="T:Spring.Threading.ISync"/>
            </remarks>
            <seealso cref="T:Spring.Threading.Semaphore">
            </seealso>
        </member>
        <member name="F:Spring.Threading.Mutex.inuse_">
            <summary>The lock status *</summary>
        </member>
        <member name="M:Spring.Threading.Mutex.Acquire">
            <summary>
            <see cref="M:Spring.Threading.ISync.Acquire"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.Mutex.Release">
            <summary>
            <see cref="M:Spring.Threading.ISync.Release"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.Mutex.Attempt(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ISync.Attempt(System.Int64)"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.NullRunnable">
            <summary>
            A do-nothing runnable used to signal shutdown
            </summary>
        </member>
        <member name="M:Spring.Threading.NullRunnable.Run">
            <summary>
            <see cref="M:Spring.Threading.IRunnable.Run"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor">
             <summary> 
             A tunable, extensible thread pool class. The main supported public
             method are <see cref="M:Spring.Threading.PooledExecutor.Execute(Spring.Threading.IRunnable)"/> and
             <see cref="M:Spring.Threading.PooledExecutor.Execute(System.Action)"/>, which can be
             called instead of directly creating threads to execute commands.
             
             <p>
             Please be aware that there exists a race condition when you use 
             the <see cref="T:Spring.Threading.PooledExecutor.WaitWhenBlocked_"/> policy with a pool size of 1.
             This condition will manifest itself if a <see cref="T:Spring.Threading.IRunnable"/>
             will throw any exception.
             </p>
             
             <p>
             Thread pools can be useful for several, usually intertwined
             reasons:</p>
             
             <list type="bullet">
             <item>
              To bound resource use. A limit can be placed on the maximum
             number of simultaneously executing threads.
             </item>
             <item>
             To manage concurrency levels. A targeted number of threads
             can be allowed to execute simultaneously.
             </item>
             <item>
             To manage a set of threads performing related tasks.
             </item>
             <item>
             To minimize overhead, by reusing previously constructed
             Thread objects rather than creating new ones.  (Note however
             that pools are hardly ever cure-alls for performance problems
             associated with thread construction, especially on JVMs that
             themselves internally pool or recycle threads.)  
             </item>
             </list>
             <p>
             These goals introduce a number of policy parameters that are
             encapsulated in this class. All of these parameters have defaults
             and are tunable, either via get/set methods, or, in cases where
             decisions should hold across lifetimes, via methods that can be
             easily overridden in subclasses.  The main, most commonly set
             parameters can be established in constructors.  Policy choices
             across these dimensions can and do interact.  Be careful, and
             please read this documentation completely before using!  See also
             the usage examples below.
             </p>
             
             <p>Queueing</p>
             
             <p>By default, this pool uses queueless synchronous channels to
             to hand off work to threads. This is a safe, conservative policy
             that avoids lockups when handling sets of requests that might
             have internal dependencies. (In these cases, queuing one task
             could lock up another that would be able to continue if the
             queued task were to run.)  If you are sure that this cannot
             happen, then you can instead supply a queue of some sort (for
             example, a BoundedBuffer or LinkedQueue) in the constructor.
             This will cause new commands to be queued in cases where all
             MaximumPoolSize threads are busy. Queues are sometimes
             appropriate when each task is completely independent of others,
             so tasks cannot affect each others execution.  For example, in an
             http server.</p> 
             <p>
             When given a choice, this pool always prefers adding a new thread
             rather than queueing if there are currently fewer than the
             current getMinimumPoolSize threads running, but otherwise always
             prefers queuing a request rather than adding a new thread. Thus,
             if you use an unbounded buffer, you will never have more than
             getMinimumPoolSize threads running. (Since the default
             minimumPoolSize is one, you will probably want to explicitly
             setMinimumPoolSize.)</p>   
             <p>
             While queuing can be useful in smoothing out transient bursts of
             requests, especially in socket-based services, it is not very
             well behaved when commands continue to arrive on average faster
             than they can be processed.  Using bounds for both the queue and
             the pool size, along with run-when-blocked policy is often a
             reasonable response to such possibilities.  
             </p>
             
             <p>
             Queue sizes and maximum pool sizes can often be traded off for
             each other. Using large queues and small pools minimizes CPU
             usage, OS resources, and context-switching overhead, but can lead
             to artifically low throughput. Especially if tasks frequently
             block (for example if they are I/O bound), a JVM and underlying
             OS may be able to schedule time for more threads than you
             otherwise allow. Use of small queues or queueless handoffs
             generally requires larger pool sizes, which keeps CPUs busier but
             may encounter unacceptable scheduling overhead, which also
             decreases throughput.  
             </p>
             
             <p>Maximum Pool size</p>
             
             <p> The maximum number of threads to use, when needed.  The pool
             does not by default preallocate threads.  Instead, a thread is
             created, if necessary and if there are fewer than the maximum,
             only when an <see cref="M:Spring.Threading.IExecutor.Execute(Spring.Threading.IRunnable)"/> or
             <see cref="M:Spring.Threading.IExecutor.Execute(System.Action)"/> request arrives.
             The default value is (for all practical purposes) infinite --
             <see cref="F:System.Int32.MaxValue"/>, so should be set in the
             constructor or the set method unless you are just using the pool
             to minimize construction overhead.  Because task handoffs to idle
             worker threads require synchronization that in turn relies on 
             scheduling policies to ensure progress, it is possible that a new
             thread will be created even though an existing worker thread has
             just become idle but has not progressed to the point at which it
             can accept a new task. 
             </p>
             
             <p>Minimum Pool size</p>
             
             <p>The minimum number of threads to use, when needed (default
             1).  When a new request is received, and fewer than the minimum
             number of threads are running, a new thread is always created to
             handle the request even if other worker threads are idly waiting
             for work. Otherwise, a new thread is created only if there are
             fewer than the maximum and the request cannot immediately be
             queued.</p>
             
             <p>Preallocation</p>
             
             <p> You can override lazy thread construction policies via
             method <see cref="M:Spring.Threading.PooledExecutor.CreateThreads(System.Int32)"/>, 
             which establishes a given number of warm
             threads. Be aware that these preallocated threads will time out
             and die (and later be replaced with others if needed) if not used
             within the keep-alive time window. If you use preallocation, you
             probably want to increase the keepalive time.  The difference
             between <see cref="P:Spring.Threading.PooledExecutor.MinimumPoolSize"/> and 
             <see cref="M:Spring.Threading.PooledExecutor.CreateThreads(System.Int32)"/> is that
             <see cref="M:Spring.Threading.PooledExecutor.CreateThreads(System.Int32)"/> immediately establishes threads, 
             while setting the
             minimum pool size waits until requests arrive.  
             </p>
             
             <p>Keep-alive time</p>
             
             <p>If the pool maintained references to a fixed set of threads
             in the pool, then it would impede garbage collection of otherwise
             idle threads. This would defeat the resource-management aspects
             of pools. One solution would be to use weak references.  However,
             this would impose costly and difficult synchronization issues.
             Instead, threads are simply allowed to terminate and thus be
             GCable if they have been idle for the given keep-alive time.  The
             value of this parameter represents a trade-off between GCability
             and construction time. The default keep-alive value is one minute, which
             means that the time needed to construct and then GC a thread is
             expended at most once per minute.  
             </p>
             <p> 
             To establish worker threads permanently, use a <em>negative</em>
             argument to <see cref="P:Spring.Threading.PooledExecutor.KeepAliveTime"/>.  </p>
            
             <p>Blocked execution policy</p>
             
             <p> If the maximum pool size or queue size is bounded, then it
             is possible for incoming <c>execute</c> requests to
             block. There are four supported policies for handling this
             problem, and mechanics (based on the Strategy Object pattern) to
             allow others in subclasses: </p>
             
             <list type="bullet">
             <item>
             <term> 
             Run (the default)
             </term>
             <description>
             The thread making the <c>execute</c> request
             runs the task itself. This policy helps guard against lockup. 
             </description> 
             </item>
             <item>
             <term> 
             Wait
             </term>
             <description>
             Wait until a thread becomes available.  This
             policy should, in general, not be used if the minimum number of
             of threads is zero, in which case a thread may never become
             available. It will cause a race condition when the pool size is 
             1 (one) and the <see cref="T:Spring.Threading.IRunnable"/> throws any exception.
             </description> 
             </item>
             <item>
             <term> 
             Abort
             </term>
             <description>
             Throw a RuntimeException
             </description> 
             </item>
             <item>
             <term> 
             Discard 
             </term>
             <description>
             Throw away the current request and return.
             </description> 
             </item>
             <item>
             <term> 
             DiscardOldest
             </term>
             <description>
             Throw away the oldest request and return.
             </description> 
             </item>
             </list>
             
             <p>
             Other plausible policies include raising the maximum pool size
             after checking with some other objects that this is OK.</p>
             
             <p>
             These cases can never occur if the maximum pool size is unbounded
             or the queue is unbounded.  In these cases you instead face
             potential resource exhaustion.)  The execute method does not
             throw any checked exceptions in any of these cases since any
             errors associated with them must normally be dealt with via
             handlers or callbacks. (Although in some cases, these might be
             associated with throwing unchecked exceptions.)  You may wish to
             add special implementations even if you choose one of the listed
             policies. For example, the supplied Discard policy does not
             inform the caller of the drop. You could add your own version
             that does so.  Since choice of policies is normally a system-wide
             decision, selecting a policy affects all calls to
             <c>execute</c>.  If for some reason you would instead like
             to make per-call decisions, you could add variant versions of the
             <c>execute</c> method (for example,
             <c>executeIfWouldNotBlock</c>) in subclasses.
             </p>
             
             <p>Thread construction parameters</p>
             
             <p> A settable ThreadFactory establishes each new thread.  By
             default, it merely generates a new instance of class Thread, but
             can be changed to use a Thread subclass, to set priorities,
             ThreadLocals, etc.</p>
             
             <p>Interruption policy</p>
             
             <p> Worker threads check for interruption after processing each
             command, and terminate upon interruption.  Fresh threads will
             replace them if needed. Thus, new tasks will not start out in an
             interrupted state due to an uncleared interruption in a previous
             task. Also, unprocessed commands are never dropped upon
             interruption. It would conceptually suffice simply to clear
             interruption between tasks, but implementation characteristics of
             interruption-based methods are uncertain enough to warrant this
             conservative strategy. It is a good idea to be equally
             conservative in your code for the tasks running within pools.
             </p>
             
             <p> Shutdown policy</p>
             
             <p> The interruptAll method interrupts, but does not disable the
             pool. Two different shutdown methods are supported for use when
             you do want to (permanently) stop processing tasks. Method
             shutdownAfterProcessingCurrentlyQueuedTasks waits until all
             current tasks are finished. The shutDownNow method interrupts
             current threads and leaves other queued requests unprocessed.
             </p>
             
             <p>Handling requests after shutdown</p>
             
             <p> When the pool is shutdown, new incoming requests are handled
             by the blockedExecutionHandler. By default, the handler is set to
             discard new requests, but this can be set with an optional
             argument to method
             shutdownAfterProcessingCurrentlyQueuedTasks.
             </p>
              <p> Also, if you are
             using some form of queuing, you may wish to call method drain()
             to remove (and return) unprocessed commands from the queue after
             shutting down the pool and its clients. If you need to be sure
             these commands are processed, you can then run() each of the
             commands in the list returned by drain().
             </p>
             
             <p>Usage examples.</p>
             
             Probably the most common use of pools is in statics or singletons
             accessible from a number of classes in a package; for example:
             
             <code>
             class MyPool {
             // initialize to use a maximum of 8 threads.
             static PooledExecutor pool = new PooledExecutor(8);
             }
             </code>
             Here are some sample variants in initialization:
             <list type="number">
             <item> Using a bounded buffer of 10 tasks, at least 4 threads (started only
             when needed due to incoming requests), but allowing
             up to 100 threads if the buffer gets full.
             <code>
             pool = new PooledExecutor(new BoundedBuffer(10), 100);
             pool.MinimumPoolSize = 4;
             </code>
             </item>
             <item> Same as (1), except pre-start 9 threads, allowing them to
             die if they are not used for five minutes.
             <code>
             pool = new PooledExecutor(new BoundedBuffer(10), 100);
             pool.MinimumPoolSize = 4;
             pool.KeepAliveTime = 1000 * 60 * 5;
             pool.CreateThreads(9);
             </code>
             </item>
             <item> Same as (2) except clients abort if both the buffer is full and
             all 100 threads are busy:
             <code>
             pool = new PooledExecutor(new BoundedBuffer(10), 100);
             pool.MinimumPoolSize = 4;
             pool.KeepAliveTime = 1000 * 60 * 5;
             pool.AbortWhenBlocked();
             pool.CreateThreads(9);
             </code>
             </item>
             <item> An unbounded queue serviced by exactly 5 threads:
             <code>
             pool = new PooledExecutor(new LinkedQueue());
             pool.KeepAliveTime = -1; // live forever
             pool.CreateThreads(5);
             </code>
             </item>
             </list>
             
             <p>Usage notes.</p>
             
             <p>
             Pools do not mesh well with using thread-specific storage
             via <see cref="T:System.LocalDataStoreSlot"/>.
             <see cref="T:System.LocalDataStoreSlot"/> relies on the identity of a
             thread executing a particular task. Pools use the same thread to
             perform different tasks.  </p>
             <p>
             If you need a policy not handled by the parameters in this class
             consider writing a subclass.  </p>
             </summary>
        </member>
        <member name="T:Spring.Threading.ThreadFactoryUser">
            <summary> 
            Base class for Executors and related classes that rely on thread factories.
            Generally intended to be used as a mixin-style abstract class, but
            can also be used stand-alone.
            </summary>
        </member>
        <member name="F:Spring.Threading.ThreadFactoryUser.threadFactory_">
            <summary>
            the <see cref="T:Spring.Threading.IThreadFactory"/> used by this instance
            </summary>
        </member>
        <member name="P:Spring.Threading.ThreadFactoryUser.ThreadFactory">
            <summary> The factory for creating new threads.
            By default, new threads are created without any special priority,
            threadgroup, or status parameters.
            You can use a different factory
            to change the kind of Thread class used or its construction
            parameters.
            </summary>		
        </member>
        <member name="T:Spring.Threading.ThreadFactoryUser.DefaultThreadFactory">
            <summary>
            The thread factory that intantiates standard <see cref="T:System.Threading.Thread"/>
            objects
            </summary>
        </member>
        <member name="M:Spring.Threading.ThreadFactoryUser.DefaultThreadFactory.NewThread(Spring.Threading.IRunnable)">
            <summary>
            A sort of factory method that creates intances of 
            <see cref="T:System.Threading.Thread"/> that will run the given runnable object
            </summary>
            <param name="runnable">the runnable object to start</param>
            <returns>new Thread(new ThreadStart(runnable.Run))</returns>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.DEFAULT_MINIMUMPOOLSIZE">
            <summary> The minimum pool size; used if not otherwise specified.  Default
            value is 1.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.DEFAULT_KEEPALIVETIME">
            <summary> The maximum time to keep worker threads alive waiting for new
            tasks; used if not otherwise specified. Default value is one
            minute (60000 milliseconds).
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.DefaultMaximumPoolSize">
            <summary> The maximum pool size; used if not otherwise specified.  Default
            value is essentially infinite (<see cref="F:System.Int32.MaxValue"/>)
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.maximumPoolSize_">
            <summary>The maximum number of threads allowed in pool. *</summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.minimumPoolSize_">
            <summary>The minumum number of threads to maintain in pool. *</summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.poolSize_">
            <summary>Current pool size.  *</summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.keepAliveTime_">
            <summary>The maximum time for an idle thread to wait for new task. *</summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.shutdown_">
            <summary> Shutdown flag - latches true when a shutdown method is called 
            in order to disable queuing/handoffs of new tasks.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.handOff_">
            <summary> The channel used to hand off the command to a thread in the pool.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.threads_">
            <summary> The set of active threads, declared as a map from workers to
            their threads.  This is needed by the interruptAll method.  It
            may also be useful in subclasses that need to perform other
            thread management chores.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.blockedExecutionHandler_">
            <summary>The current handler for unserviceable requests. *</summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.#ctor">
            <summary> Create a new pool with all default settings
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.#ctor(System.Int32)">
            <summary> Create a new pool with all default settings except
            for maximum pool size.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.#ctor(Spring.Threading.IChannel)">
            <summary> Create a new pool that uses the supplied Channel for queuing, and
            with all default parameter settings.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.#ctor(Spring.Threading.IChannel,System.Int32)">
            <summary> Create a new pool that uses the supplied Channel for queuing, and
            with all default parameter settings except for maximum pool size.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.AddThread(Spring.Threading.IRunnable)">
            <summary> Create and start a thread to handle a new command.  Call only
            when holding lock.
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.CreateThreads(System.Int32)">
            <summary> Create and start up to numberOfThreads threads in the pool.
            Return the number created. This may be less than the number
            requested if creating more would exceed maximum pool size bound.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.InterruptAll">
            <summary> Interrupt all threads in the pool, causing them all to
            terminate. Assuming that executed tasks do not disable (clear)
            interruptions, each thread will terminate after processing its
            current task. Threads will terminate sooner if the executed tasks
            themselves respond to interrupts.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.ShutdownNow">
            <summary> Interrupt all threads and disable construction of new
            threads. Any tasks entered after this point will be discarded. A
            shut down pool cannot be restarted.
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.ShutdownNow(Spring.Threading.PooledExecutor.IBlockedExecutionHandler)">
            <summary> Interrupt all threads and disable construction of new
            threads. Any tasks entered after this point will be handled by
            the given BlockedExecutionHandler.  A shut down pool cannot be
            restarted.
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.ShutdownAfterProcessingCurrentlyQueuedTasks">
            <summary> Terminate threads after processing all elements currently in
            queue. Any tasks entered after this point will be discarded. A
            shut down pool cannot be restarted.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.ShutdownAfterProcessingCurrentlyQueuedTasks(Spring.Threading.PooledExecutor.IBlockedExecutionHandler)">
            <summary> Terminate threads after processing all elements currently in
            queue. Any tasks entered after this point will be handled by the
            given BlockedExecutionHandler.  A shut down pool cannot be
            restarted.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.AwaitTerminationAfterShutdown(System.Int64)">
            <summary> Wait for a shutdown pool to fully terminate, or until the timeout
            has expired. This method may only be called <em>after</em>
            invoking shutdownNow or
            shutdownAfterProcessingCurrentlyQueuedTasks.
            
            </summary>
            <param name="maxWaitTime"> the maximum time in milliseconds to wait
            </param>
            <returns> <c>true</c> if the pool has terminated within the max wait period
            </returns>
            <exception cref="T:System.InvalidOperationException"> if shutdown has not been requested
            </exception>
            <exception cref="T:System.Threading.ThreadInterruptedException"> if the current thread has been interrupted in the course of waiting
            </exception>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.AwaitTerminationAfterShutdown">
            <summary> Wait for a shutdown pool to fully terminate.  This method may
            only be called <em>after</em> invoking shutdownNow or
            shutdownAfterProcessingCurrentlyQueuedTasks.
            
            </summary>
            <exception cref="T:System.InvalidOperationException"> if shutdown has not been requested
            </exception>
            <exception cref="T:System.Threading.ThreadInterruptedException"> if the current thread has been interrupted in the course of waiting
            </exception>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.Drain">
            <summary> Remove all unprocessed tasks from pool queue, and return them in
            a <see cref="T:System.Collections.IList"/>. This method should be used only when there are
            not any active clients of the pool. Otherwise you face the
            possibility that the method will loop pulling out tasks as
            clients are putting them in.  This method can be useful after
            shutting down a pool (via shutdownNow) to determine whether there
            are any pending tasks that were not processed.  You can then, for
            example execute all unprocessed commands via code along the lines
            of:
            <code>
            List tasks = pool.Drain();
            foreach (IRunnable r in tasks) 
                r.Run();
            </code>
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.WorkerDone(Spring.Threading.PooledExecutor.Worker)">
            <summary> Cleanup method called upon termination of worker thread.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.RunWhenBlocked">
            <summary> Set the policy for blocked execution to be that the current
            thread executes the command if there are no available threads in
            the pool.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.WaitWhenBlocked">
            <summary> Set the policy for blocked execution to be to wait until a thread
            is available, unless the pool has been shut down, in which case
            the action is discarded.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.DiscardWhenBlocked">
            <summary> Set the policy for blocked execution to be to return without
            executing the request.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.AbortWhenBlocked">
            <summary> Set the policy for blocked execution to be to
            throw a RuntimeException.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.DiscardOldestWhenBlocked">
            <summary> Set the policy for blocked execution to be to discard the oldest
            unhandled request
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> Arrange for the given command to be executed by a thread in this
            pool.  The method normally returns when the command has been
            handed off for (possibly later) execution.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.Execute(System.Action)">
            <summary>
            Arrange for the given <paramref name="action"/> to be executed by a 
            thread in this pool.  The method normally returns when the task 
            has been handed off for (possibly later) execution.
            </summary>
            <param name="action">The task to be executed.</param>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.MaximumPoolSize">
            <summary> Return the maximum number of threads to simultaneously execute
            New unqueued requests will be handled according to the current
            blocking policy once this limit is exceeded.
            
            </summary>
            <summary> Set the maximum number of threads to use. Decreasing the pool
            size will not immediately kill existing threads, but they may
            later die when idle.
            </summary>
            <exception cref="T:System.ArgumentException">  if less or equal to zero.
            (It is
            not considered an error to set the maximum to be less than than
            the minimum. However, in this case there are no guarantees
            about behavior.)
            
            </exception>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.MinimumPoolSize">
            <summary>The minimum number of threads to simultaneously execute.
            (Default value is <see cref="F:Spring.Threading.PooledExecutor.DEFAULT_MINIMUMPOOLSIZE"/>).  
            If fewer than the mininum number are
            running upon reception of a new request, a new thread is started
            to handle this request.
            </summary>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.PoolSize">
            <summary> Return the current number of active threads in the pool.  This
            number is just a snaphot, and may change immediately upon
            returning
            
            </summary>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.KeepAliveTime">
            <summary> The number of milliseconds to keep threads alive waiting
            for new commands. A negative value means to wait forever. A zero
            value means not to wait at all.
            </summary>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.TerminatedAfterShutdown">
            <summary> Return true if a shutDown method has succeeded in terminating all
            threads.
            </summary>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.Task">
            <summary> Get a task from the handoff queue, or null if shutting down.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.PooledExecutor.BlockedExecutionHandler">
            <summary>The handler for blocked execution *</summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.Worker">
            <summary> Class defining the basic run loop for pooled threads.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.PooledExecutor.Worker.firstTask_">
            <summary>
            The first task to execute
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.Worker.#ctor(Spring.Threading.PooledExecutor,Spring.Threading.IRunnable)">
            <summary>
            <see cref="T:Spring.Threading.PooledExecutor"/> helper class
            </summary>
            <param name="executor">pooled executor</param>
            <param name="firstTask">the first task to execute</param>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.Worker.Run">
            <summary>
            <see cref="M:Spring.Threading.IRunnable.Run"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.IBlockedExecutionHandler">
            <summary> Class for actions to take when execute() blocks. Uses Strategy
            pattern to represent different actions. You can add more in
            subclasses, and/or create subclasses of these. If so, you will
            also want to add or modify the corresponding methods that set the
            current blockedExectionHandler_.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.IBlockedExecutionHandler.BlockedAction(Spring.Threading.IRunnable)">
            <summary> Return true if successfully handled so, execute should
            terminate; else return false if execute loop should be retried.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.RunWhenBlocked_">
            <summary>Class defining Run action. *</summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.RunWhenBlocked_.BlockedAction(Spring.Threading.IRunnable)">
            <summary>
            <see cref="M:Spring.Threading.PooledExecutor.IBlockedExecutionHandler.BlockedAction(Spring.Threading.IRunnable)"/>
            </summary>
            <returns><c>true</c></returns>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.WaitWhenBlocked_">
            <summary>Class defining Wait action: don't use with a 
            pollsize of 1 and <see cref="T:Spring.Threading.IRunnable"/>s that can throws
            exceptions in ther <see cref="M:Spring.Threading.IRunnable.Run"/> method.
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.WaitWhenBlocked_.#ctor(Spring.Threading.PooledExecutor)">
            <summary>
            Creates new instance tied to the given <see cref="T:Spring.Threading.PooledExecutor"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.WaitWhenBlocked_.BlockedAction(Spring.Threading.IRunnable)">
            <summary>
            <see cref="M:Spring.Threading.PooledExecutor.IBlockedExecutionHandler.BlockedAction(Spring.Threading.IRunnable)"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.DiscardWhenBlocked_">
            <summary>Class defining Discard action. *</summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.DiscardWhenBlocked_.BlockedAction(Spring.Threading.IRunnable)">
            <summary>
            <see cref="M:Spring.Threading.PooledExecutor.IBlockedExecutionHandler.BlockedAction(Spring.Threading.IRunnable)"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.AbortWhenBlocked_">
            <summary>Class defining Abort action. *</summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.AbortWhenBlocked_.BlockedAction(Spring.Threading.IRunnable)">
            <summary>
            <see cref="M:Spring.Threading.PooledExecutor.IBlockedExecutionHandler.BlockedAction(Spring.Threading.IRunnable)"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.PooledExecutor.DiscardOldestWhenBlocked_">
            <summary> Class defining DiscardOldest action.  Under this policy, at most
            one old unhandled task is discarded.  If the new task can then be
            handed off, it is.  Otherwise, the new task is run in the current
            thread (i.e., RunWhenBlocked is used as a backup policy.)
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.DiscardOldestWhenBlocked_.#ctor(Spring.Threading.PooledExecutor)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:Spring.Threading.PooledExecutor.DiscardOldestWhenBlocked_.BlockedAction(Spring.Threading.IRunnable)">
            <summary>
            <see cref="M:Spring.Threading.PooledExecutor.IBlockedExecutionHandler.BlockedAction(Spring.Threading.IRunnable)"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.PrioritySemaphore">
            <summary> A Semaphore that grants requests to threads with higher
            Thread priority rather than lower priority when there is
            contention. Ordering of requests with the same priority
            is approximately FIFO.
            Priorities are based on Thread.getPriority.
            Changing the priority of an already-waiting thread does NOT 
            change its ordering. This class also does not specially deal with priority
            inversion --  when a new high-priority thread enters
            while a low-priority thread is currently running, their
            priorities are <em>not</em> artificially manipulated.
            </summary>
        </member>
        <member name="M:Spring.Threading.PrioritySemaphore.#ctor(System.Int64)">
            <summary> Create a Semaphore with the given initial number of permits.
            Using a seed of one makes the semaphore act as a mutual exclusion lock.
            Negative seeds are also allowed, in which case no acquires will proceed
            until the number of releases has pushed the number of permits past 0.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.PrioritySemaphore.PriorityWaitQueue">
            <summary>
            Class to used back <see cref="T:Spring.Threading.PrioritySemaphore"/>
            </summary>
        </member>
        <member name="F:Spring.Threading.PrioritySemaphore.PriorityWaitQueue.cells_">
            <summary>An array of wait queues, one per priority *</summary>
        </member>
        <member name="F:Spring.Threading.PrioritySemaphore.PriorityWaitQueue.maxIndex_">
            <summary> The index of the highest priority cell that may need to be signalled,
            or -1 if none. Used to minimize array traversal.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.PrioritySemaphore.PriorityWaitQueue.#ctor">
            <summary>
            Creates a new <see cref="T:Spring.Threading.PrioritySemaphore.PriorityWaitQueue"/> instance.
            </summary>
        </member>
        <member name="T:Spring.Threading.QueuedExecutor">
            <summary> 
            An implementation of Executor that queues incoming
            requests until they can be processed by a single background
            thread.
            <p>
            The thread is not actually started until the first 
            <code>execute</code> request is encountered. Also, if the
            thread is stopped for any reason (for example, after hitting
            an unrecoverable exception in an executing task), one is started 
            upon encountering a new request, or if <code>restart()</code> is
            invoked.</p>
            <p>
            Beware that, especially in situations
            where command objects themselves invoke execute, queuing can
            sometimes lead to lockups, since commands that might allow
            other threads to terminate do not run at all when they are in the queue.
            </p>
            </summary>
        </member>
        <member name="F:Spring.Threading.QueuedExecutor.thread_">
            <summary>The thread used to process commands *</summary>
        </member>
        <member name="F:Spring.Threading.QueuedExecutor.endTask_">
            <summary>Special queue element to signal termination *</summary>
        </member>
        <member name="F:Spring.Threading.QueuedExecutor.shutdown_">
            <summary>true if thread should shut down after processing current task *</summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.ClearThread">
            <summary>set thread_ to null to indicate termination *</summary>
        </member>
        <member name="F:Spring.Threading.QueuedExecutor.queue_">
            <summary>The queue *</summary>
        </member>
        <member name="F:Spring.Threading.QueuedExecutor.runLoop_">
            <summary>
            support for running <see cref="T:Spring.Threading.IRunnable">s</see> in background 
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.#ctor(Spring.Threading.IChannel)">
            <summary> Construct a new QueuedExecutor that uses
            the supplied Channel as its queue. 
            <p>
            This class does not support any methods that 
            reveal this queue. If you need to access it
            independently (for example to invoke any
            special status monitoring operations), you
            should record a reference to it separately.
            </p>
            </summary>		
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.#ctor">
            <summary> Construct a new QueuedExecutor that uses
            a <see cref="T:Spring.Threading.BoundedLinkedQueue"/> with the current
            <see cref="T:Spring.Threading.DefaultChannelCapacity"/> as its queue.
            
            </summary>		
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.#ctor(Spring.Threading.IRunnable)">
            <summary> Construct a new QueuedExecutor that uses
            the given <see cref="T:Spring.Threading.IRunnable"/> to be used to shut down 
            the executor thread. 
            </summary>
            <param name="endTask"></param>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.Restart">
            <summary> Start (or restart) the background thread to process commands. It has
            no effect if a thread is already running. This
            method can be invoked if the background thread crashed
            due to an unrecoverable exception.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> Arrange for execution of the command in the
            background thread by adding it to the queue. 
            The method may block if the channel's put
            operation blocks.
            <p>
            If the background thread
            does not exist, it is created and started.
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.Execute(System.Action)">
            <summary>
            <para>
            Arrange for execution of the <paramref name="action"/> in the
            background thread by adding it to the queue.  The method may 
            block if the channel's put operation blocks.
            </para>
            <para>
            If the background thread does not exist, it is created and started.
            </para>
            </summary>
            <param name="action">The task to be executed.</param>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.ShutdownAfterProcessingCurrentlyQueuedTasks">
            <summary> Terminate background thread after it processes all
            elements currently in queue. Any tasks entered after this point will
            not be processed. A shut down thread cannot be restarted.
            This method may block if the task queue is finite and full.
            Also, this method 
            does not in general apply (and may lead to comparator-based
            exceptions) if the task queue is a priority queue.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.ShutdownAfterProcessingCurrentTask">
            <summary> Terminate background thread after it processes the 
            current task, removing other queued tasks and leaving them unprocessed.
            A shut down thread cannot be restarted.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.ShutdownNow">
            <summary> Terminate background thread even if it is currently processing
            a task. <p>This method uses Thread.Interrupt, so relies on tasks
            themselves responding appropriately to interruption.</p>
            <p>If the current tasks does not terminate on interruption, then the 
            thread will not terminate until processing current task.</p>
            A shut down thread cannot be restarted.
            
            </summary>
        </member>
        <member name="P:Spring.Threading.QueuedExecutor.Thread">
            <summary> Return the thread being used to process commands, or
            null if there is no such thread. You can use this
            to invoke any special methods on the thread, for
            example, to interrupt it.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.QueuedExecutor.RunLoop">
            <summary> The runloop is isolated in its own Runnable class
            just so that the main
            class need not implement Runnable,  which would
            allow others to directly invoke run, which would
            never make sense here.
            
            </summary>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.RunLoop.#ctor(Spring.Threading.QueuedExecutor)">
            <summary>
            Initializes a new instance of RunLoop connected to the given executor
            </summary>
            <param name="executor">the executor from which to dequeue the <see cref="T:Spring.Threading.IRunnable">s</see></param>
        </member>
        <member name="M:Spring.Threading.QueuedExecutor.RunLoop.Run">
            <summary>
            <see cref="M:Spring.Threading.IRunnable.Run"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.QueuedExecutor.RunLoop.Executor">
            <summary>
            The enclosing Executor
            </summary>
        </member>
        <member name="T:Spring.Threading.Rendezvous">
            <summary> A rendezvous is a barrier that:
            <ul>
            <li> Unlike a CyclicBarrier, is not restricted to use 
            with fixed-sized groups of threads.
            Any number of threads can attempt to enter a rendezvous,
            but only the predetermined number of parties enter
            and later become released from the rendezvous at any give time.
            </li>
            <li> Enables each participating thread to exchange information
            with others at the rendezvous point. Each entering thread
            presents some object on entry to the rendezvous, and
            returns some object on release. The object returned is
            the result of a RendezvousFunction that is run once per
            rendezvous, (it is run by the last-entering thread). By
            default, the function applied is a rotation, so each
            thread returns the object given by the next (modulo parties)
            entering thread. This default function faciliates simple
            application of a common use of rendezvous, as exchangers.
            </li>
            </ul>
            <p>
            Rendezvous use an all-or-none breakage model
            for failed synchronization attempts: If threads
            leave a rendezvous point prematurely because of timeout
            or interruption, others will also leave abnormally
            (via BrokenBarrierException), until
            the rendezvous is <code>restart</code>ed. This is usually
            the simplest and best strategy for sharing knowledge
            about failures among cooperating threads in the most
            common usages contexts of Rendezvous.
            </p>
            <p>
            While any positive number (including 1) of parties can
            be handled, the most common case is to have two parties.
            </p>
            <p>
            <b>Sample Usage</b>
            </p>
            <p>
            Here are the highlights of a class that uses a Rendezvous to
            swap buffers between threads so that the thread filling the
            buffer  gets a freshly
            emptied one when it needs it, handing off the filled one to
            the thread emptying the buffer.
            <pre>
            class FillAndEmpty {
            Rendezvous exchanger = new Rendezvous(2);
            Buffer initialEmptyBuffer = ... a made-up type
            Buffer initialFullBuffer = ...
            
            class FillingLoop implements Runnable {
            public void run() {
            Buffer currentBuffer = initialEmptyBuffer;
            try {
            while (currentBuffer != null) {
            addToBuffer(currentBuffer);
            if (currentBuffer.full()) 
            currentBuffer = (Buffer)(exchanger.rendezvous(currentBuffer));
            }
            }
            catch (BrokenBarrierException ex) {
            return;
            }
            catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
            }
            }
            }
            
            class EmptyingLoop implements Runnable {
            public void run() {
            Buffer currentBuffer = initialFullBuffer;
            try {
            while (currentBuffer != null) {
            takeFromBuffer(currentBuffer);
            if (currentBuffer.empty()) 
            currentBuffer = (Buffer)(exchanger.rendezvous(currentBuffer));
            }
            }
            catch (BrokenBarrierException ex) {
            return;
            }
            catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
            }
            }
            }
            
            void start() {
            new Thread(new FillingLoop()).start();
            new Thread(new EmptyingLoop()).start();
            }
            }
            </pre>
            </p>
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.parties_">
            <summary>
            number of parties that must meet 
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.broken_">
            <summary>
            broken by any thread ?
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.entries_">
            <summary> Number of threads that have entered rendezvous
            
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.departures_">
            <summary> Number of threads that are permitted to depart rendezvous 
            
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.entryGate_">
            <summary> Incoming threads pile up on entry until last set done.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.slots_">
            <summary> Temporary holder for items in exchange
            
            </summary>
        </member>
        <member name="F:Spring.Threading.Rendezvous.rendezvousFunction_">
            <summary> The function to run at rendezvous point
            
            </summary>
        </member>
        <member name="M:Spring.Threading.Rendezvous.#ctor(System.Int32)">
            <summary> Create a Barrier for the indicated number of parties,
            and the default Rotator function to run at each barrier point.
            </summary>
            <exception cref="T:System.ArgumentException"> if parties less than or equal to zero.
            
            </exception>		
        </member>
        <member name="M:Spring.Threading.Rendezvous.#ctor(System.Int32,Spring.Threading.Rendezvous.IRendezvousFunction)">
            <summary> Create a Barrier for the indicated number of parties.
            and the given function to run at each barrier point.
            </summary>
            <exception cref="T:System.ArgumentException">if parties less than or equal to zero.
            
            </exception>
        </member>
        <member name="M:Spring.Threading.Rendezvous.SetRendezvousFunction(Spring.Threading.Rendezvous.IRendezvousFunction)">
            <summary> Set the function to call at the point at which all threads reach the
            rendezvous. This function is run exactly once, by the thread
            that trips the barrier. The function is not run if the barrier is
            broken. 
            </summary>
            <param name="function">the function to run. If null, no function is run.
            </param>
            <returns> the previous function
            
            </returns>				
        </member>
        <member name="M:Spring.Threading.Rendezvous.Restart">
            <summary> Reset to initial state. Clears both the broken status
            and any record of waiting threads, and releases all
            currently waiting threads with indeterminate return status.
            This method is intended only for use in recovery actions
            in which it is somehow known
            that no thread could possibly be relying on the
            the synchronization properties of this barrier.
            
            </summary>		
        </member>
        <member name="M:Spring.Threading.Rendezvous.RendezVous(System.Object)">
            <summary> Enter a rendezvous; returning after all other parties arrive.</summary>
            <param name="x">the item to present at rendezvous point. 
            By default, this item is exchanged with another.
            </param>
            <returns> an item x given by some thread, and/or processed
            by the rendezvousFunction.
            </returns>
            <exception cref="T:Spring.Threading.BrokenBarrierException">
            if any other thread
            in any previous or current barrier 
            since either creation or the last <code>restart</code>
            operation left the barrier
            prematurely due to interruption or time-out. (If so,
            the <code>broken</code> status is also set.) 
            Also returns as
            broken if the RendezvousFunction encountered a run-time exception.
            Threads that are noticed to have been
            interrupted <em>after</em> being released are not considered
            to have broken the barrier.
            In all cases, the interruption
            status of the current thread is preserved, so can be tested
            by checking <code>Thread.interrupted</code>. 
            </exception>
            <exception cref="T:System.Threading.ThreadInterruptedException"> if this thread was interrupted
            during the exchange. If so, <code>broken</code> status is also set.
            
            </exception>
        </member>
        <member name="M:Spring.Threading.Rendezvous.AttemptRendezVous(System.Object,System.Int64)">
            <summary> Wait msecs to complete a rendezvous.</summary>
            <param name="x">the item to present at rendezvous point. 
            By default, this item is exchanged with another.
            </param>
            <param name="msecs">The maximum time to wait.
            </param>
            <returns> an item x given by some thread, and/or processed
            by the rendezvousFunction.
            </returns>
            <exception cref="T:Spring.Threading.BrokenBarrierException"> 
            if any other thread
            in any previous or current barrier 
            since either creation or the last <code>restart</code>
            operation left the barrier
            prematurely due to interruption or time-out. (If so,
            the <code>broken</code> status is also set.) 
            Also returns as
            broken if the RendezvousFunction encountered a run-time exception.
            Threads that are noticed to have been
            interrupted <em>after</em> being released are not considered
            to have broken the barrier.
            In all cases, the interruption
            status of the current thread is preserved, so can be tested
            by checking <code>Thread.interrupted</code>. 
            </exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">  if this thread was interrupted
            during the exchange. If so, <code>broken</code> status is also set.
            </exception>
            <exception cref="T:Spring.Threading.TimeoutException">  if this thread timed out waiting for
            the exchange. If the timeout occured while already in the
            exchange, <code>broken</code> status is also set.
            
            </exception>
        </member>
        <member name="M:Spring.Threading.Rendezvous.doRendezvous(System.Object,System.Boolean,System.Int64)">
            <summary>
            The actual rendezvous logic for the given time
            </summary>
        </member>
        <member name="P:Spring.Threading.Rendezvous.Parties">
            <summary>
            <see cref="P:Spring.Threading.IBarrier.Parties"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.Rendezvous.IsBroken">
            <summary>
            <see cref="P:Spring.Threading.IBarrier.IsBroken"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.Rendezvous.IRendezvousFunction">
            <summary> Interface for functions run at rendezvous points
            
            </summary>
        </member>
        <member name="M:Spring.Threading.Rendezvous.IRendezvousFunction.RendezvousFunction(System.Object[])">
            <summary> Perform some function on the objects presented at
            a rendezvous. The objects array holds all presented
            items; one per thread. Its length is the number of parties. 
            The array is ordered by arrival into the rendezvous.
            So, the last element (at objects[objects.length-1])
            is guaranteed to have been presented by the thread performing
            this function. No identifying information is
            otherwise kept about which thread presented which item.
            If you need to 
            trace origins, you will need to use an item type for rendezvous
            that includes identifying information. After return of this
            function, other threads are released, and each returns with
            the item with the same index as the one it presented.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.Rendezvous.Rotator">
            <summary> The default rendezvous function. Rotates the array
            so that each thread returns an item presented by some
            other thread (or itself, if parties is 1).
            
            </summary>
        </member>
        <member name="M:Spring.Threading.Rendezvous.Rotator.RendezvousFunction(System.Object[])">
            <summary>Rotate the array *</summary>
        </member>
        <member name="T:Spring.Threading.Slot">
            <summary> A one-slot buffer, using semaphores to control access.
            Slots are usually more efficient and controllable than using other
            bounded buffers implementations with capacity of 1.
            <p>
            Among other applications, Slots can be convenient in token-passing
            designs: Here. the Slot holds a some object serving as a token,
            that can be obtained
            and returned by various threads.
            </p>
            </summary>
        </member>
        <member name="M:Spring.Threading.Slot.#ctor(System.Type)">
            <summary> Create a buffer with the given capacity, using
            the supplied Semaphore class for semaphores.
            </summary>
        </member>
        <member name="M:Spring.Threading.Slot.#ctor">
            <summary> Create a new Slot using default Semaphore implementations 
            
            </summary>
        </member>
        <member name="F:Spring.Threading.Slot.item_">
            <summary>The slot *</summary>
        </member>
        <member name="M:Spring.Threading.Slot.Insert(System.Object)">
            <summary>Set the item in preparation for a take *</summary>
        </member>
        <member name="M:Spring.Threading.Slot.Extract">
            <summary>Take item known to exist *</summary>
        </member>
        <member name="M:Spring.Threading.Slot.Peek">
            <summary>
            <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Spring.Threading.SynchronousChannel">
            <summary> A rendezvous channel, similar to those used in CSP and Ada.
            
            <p>Each put must wait for a take, and vice versa.</p>
            
            <p>Synchronous channels
            are well suited for handoff designs, in which an object running in
            one thread must synch up with an object running in another thread
            in order to hand it some information, event, or task. 
            </p>  
            </summary>  	
        </member>
        <member name="F:Spring.Threading.SynchronousChannel.Cancelled">
            <summary> Special marker used in queue nodes to indicate that
            the thread waiting for a change in the node has timed out
            or been interrupted.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.SynchronousChannel.waitingPuts">
            <summary>
            put queue
            </summary>
        </member>
        <member name="F:Spring.Threading.SynchronousChannel.waitingTakes">
            <summary>
            take queue
            </summary>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Peek">
            <returns><c>null</c>: synchronous channels do 
            not hold contents unless actively taken
            </returns>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Put(System.Object)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Take">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Take"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Offer(System.Object,System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Poll(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.ITakable.Poll(System.Int64)"/>
            </summary>
        </member>
        <member name="P:Spring.Threading.SynchronousChannel.Capacity">
            <summary>
            <see cref="P:Spring.Threading.IBoundedChannel.Capacity"/>
            </summary>
        </member>
        <member name="T:Spring.Threading.SynchronousChannel.Queue">
            <summary> Simple FIFO queue class to hold waiting puts/takes.
            
            </summary>
        </member>
        <member name="F:Spring.Threading.SynchronousChannel.Queue.head">
            <summary>
            Queue's head
            </summary>
        </member>
        <member name="F:Spring.Threading.SynchronousChannel.Queue.last">
            <summary>
            Queue's end
            </summary>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Queue.Enq(Spring.Threading.LinkedNode)">
            <summary>
            Enqueue
            </summary>
            <param name="p">node to enqueue</param>
        </member>
        <member name="M:Spring.Threading.SynchronousChannel.Queue.Deq">
            <summary>
            Dequeue
            </summary>
            <returns></returns>
        </member>
        <member name="T:Spring.Threading.ThreadedExecutor">
            <summary> 
            An implementation of Executor that creates a new
            Thread that invokes the run method of the supplied command.
            </summary>
        </member>
        <member name="M:Spring.Threading.ThreadedExecutor.Execute(Spring.Threading.IRunnable)">
            <summary> 
            Execute the given command in a new thread.
            </summary>
        </member>
        <member name="M:Spring.Threading.ThreadedExecutor.Execute(System.Action)">
            <summary>
            Execute the given <paramref name="action"/> in a new thread.
            </summary>
            <param name="action">The task to be executed.</param>
        </member>
        <member name="T:Spring.Threading.Void">
            <summary>
            A never instantialable class that can be used as generic type paramter
            to indicate that the type is irrelevant and ignored.
            </summary>
        </member>
        <member name="T:Spring.Threading.WaiterPreferenceSemaphore">
            <summary> An implementation of counting Semaphores that
            enforces enough fairness for applications that
            need to avoid indefinite overtaking without
            necessarily requiring FIFO ordered access.
            Empirically, very little is paid for this property
            unless there is a lot of contention among threads
            or very unfair JVM scheduling.
            The acquire method waits even if there are permits
            available but have not yet been claimed by threads that have
            been notified but not yet resumed. This makes the semaphore
            almost as fair as the underlying Java primitives allow. 
            So, if synch lock entry and notify are both fair
            so is the semaphore -- almost:  Rewaits stemming
            from timeouts in attempt, along with potentials for
            interrupted threads to be notified can compromise fairness,
            possibly allowing later-arriving threads to pass before
            later arriving ones. However, in no case can a newly
            entering thread obtain a permit if there are still others waiting.
            Also, signalling order need not coincide with
            resumption order. Later-arriving threads might get permits
            and continue before other resumable threads are actually resumed.
            However, all of these potential fairness breaches are
            very rare in practice unless the underlying JVM
            performs strictly LIFO notifications (which has, sadly enough, 
            been known to occur) in which case you need to use
            a FIFOSemaphore to maintain a reasonable approximation
            of fairness.
            <p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package. </a>]</p>
            
            </summary>
        </member>
        <member name="M:Spring.Threading.WaiterPreferenceSemaphore.#ctor(System.Int64)">
            <summary> 
            Create a Semaphore with the given initial number of permits.
            </summary>
        </member>
        <member name="F:Spring.Threading.WaiterPreferenceSemaphore.waits_">
            <summary>Number of waiting threads *</summary>
        </member>
        <member name="M:Spring.Threading.WaiterPreferenceSemaphore.Acquire">
            <summary>
            <see cref="M:Spring.Threading.Semaphore.Acquire"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.WaiterPreferenceSemaphore.Attempt(System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.Semaphore.Attempt(System.Int64)"/>
            </summary>
            <param name="msecs"></param>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.WaiterPreferenceSemaphore.Release">
            <summary>
            <see cref="M:Spring.Threading.ISync.Release"/>
            </summary>
        </member>
        <member name="M:Spring.Threading.WaiterPreferenceSemaphore.Release(System.Int64)">
            <summary>Release N permits *</summary>
        </member>
        <member name="T:Spring.Threading.WaitFreeQueue">
            <summary> A wait-free linked list based queue implementation.
            <p>
            
            While this class conforms to the full Channel interface, only the
            <code>put</code> and <code>poll</code> methods are useful in most
            applications. Because the queue does not support blocking
            operations, <code>take</code> relies on spin-loops, which can be
            extremely wasteful.  </p>
            <p>
            This class is adapted from the algorithm described in <a href="http://www.cs.rochester.edu/u/michael/PODC96.html"> Simple,
            Fast, and Practical Non-Blocking and Blocking Concurrent Queue
            Algorithms</a> by Maged M. Michael and Michael L. Scott.  This
            implementation is not strictly wait-free since it relies on locking
            for basic atomicity and visibility requirements.  Locks can impose
            unbounded waits, although this should not be a major practical
            concern here since each lock is held for the duration of only a few
            statements. (However, the overhead of using so many locks can make
            it less attractive than other Channel implementations on JVMs where
            locking operations are very slow.)
            </p>
            
            </summary>
            <seealso cref="T:Spring.Threading.BoundedLinkedQueue">
            </seealso>
            <seealso cref="T:Spring.Threading.LinkedQueue">
            </seealso>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.#ctor">
            <summary>
            Creates a new <see cref="T:Spring.Threading.WaitFreeQueue"/> instance.
            </summary>
        </member>
        <member name="F:Spring.Threading.WaitFreeQueue.head">
            <summary>Head of list is always a dummy node *</summary>
        </member>
        <member name="F:Spring.Threading.WaitFreeQueue.tail">
            <summary>Pointer to last node on list *</summary>
        </member>
        <member name="F:Spring.Threading.WaitFreeQueue.tailLock">
            <summary>Lock for simulating CAS for tail field  *</summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.CASHead(Spring.Threading.WaitFreeQueue.Node,Spring.Threading.WaitFreeQueue.Node)">
            <summary>Simulate CAS for head field, using 'this' lock *</summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.CASTail(Spring.Threading.WaitFreeQueue.Node,Spring.Threading.WaitFreeQueue.Node)">
            <summary>Simulate CAS for tail field *</summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Put(System.Object)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Put(System.Object)"/>
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Offer(System.Object,System.Int64)">
            <summary>
            <see cref="M:Spring.Threading.IPuttable.Offer(System.Object,System.Int64)"/>
            </summary>
            <param name="x"></param>
            <param name="msecs"></param>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Extract">
            <summary>Main dequeue algorithm, called by poll, take. *</summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Peek">
            <summary>
            <see cref="M:Spring.Threading.IChannel.Peek"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Take">
            <summary> Spin until poll returns a non-null value.
            You probably don't want to call this method.
            A Thread.sleep(0) is performed on each iteration
            as a heuristic to reduce contention. If you would
            rather use, for example, an exponential backoff, 
            you could manually set this up using poll. 
            
            </summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Poll(System.Int64)">
            <summary> Spin until poll returns a non-null value or time elapses.
            if msecs is positive, a Thread.sleep(0) is performed on each iteration
            as a heuristic to reduce contention.
            
            </summary>
        </member>
        <member name="T:Spring.Threading.WaitFreeQueue.Node">
            <summary>List nodes for Queue *</summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Node.#ctor(System.Object)">
            <summary>Make a new node with indicated item, and null link *</summary>
        </member>
        <member name="M:Spring.Threading.WaitFreeQueue.Node.CASNext(Spring.Threading.WaitFreeQueue.Node,Spring.Threading.WaitFreeQueue.Node)">
            <summary>Simulate a CAS operation for 'next' field *</summary>
        </member>
        <member name="T:Spring.Utility.SerializationUtilities">
            <summary>
            Collection of static methods that aid in serialization.
            </summary>
        </member>
        <member name="M:Spring.Utility.SerializationUtilities.DefaultWriteObject(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Object)">
            <summary>
            Writes the serializable fields to the SerializationInfo object, which stores all the data needed to serialize the specified object object.
            </summary>
            <param name="info">SerializationInfo parameter from the GetObjectData method.</param>
            <param name="context">StreamingContext parameter from the GetObjectData method.</param>
            <param name="instance">Object to serialize.</param>
        </member>
        <member name="M:Spring.Utility.SerializationUtilities.DefaultReadObject(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Object)">
            <summary>
            Reads the serialized fields written by the DefaultWriteObject method.
            </summary>
            <param name="info">SerializationInfo parameter from the special deserialization constructor.</param>
            <param name="context">StreamingContext parameter from the special deserialization constructor</param>
            <param name="instance">Object to deserialize.</param>
        </member>
    </members>
</doc>
